; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\planeofblocks.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EA@OOMJLBPB@MVTools?3?5error?5while?5trying?5to?5a@ ; `string'
PUBLIC	??_C@_0CK@INGOFGFH@return_obj?$CI?$CJ?3?5cannot?5allocate?5a?5@ ; `string'
PUBLIC	??_C@_0CN@NLNDHOHM@bad?5?5blk?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5sad?$DN?$CFd?5mea@ ; `string'
PUBLIC	??_C@_0CF@IAFINEIK@best?5blk?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5sad?$DN?$CFd?5ite@ ; `string'
PUBLIC	??_R2WorkingAreaFactory@PlaneOfBlocks@@8	; PlaneOfBlocks::WorkingAreaFactory::`RTTI Base Class Array'
PUBLIC	??_R4?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@ ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`RTTI Complete Object Locator'
PUBLIC	??_R3WorkingAreaFactory@PlaneOfBlocks@@8	; PlaneOfBlocks::WorkingAreaFactory::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AioSub@H@conc@@8				; conc::AioSub<int>::`RTTI Base Class Array'
PUBLIC	??_R2?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$AioSub@H@conc@@@8			; conc::AioSub<int> `RTTI Type Descriptor'
PUBLIC	??_R4WorkingAreaFactory@PlaneOfBlocks@@6B@	; PlaneOfBlocks::WorkingAreaFactory::`RTTI Complete Object Locator'
PUBLIC	??_R3?$AioAdd@_J@conc@@8			; conc::AioAdd<__int64>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`RTTI Complete Object Locator'
PUBLIC	??_7?$AioAdd@_J@conc@@6B@			; conc::AioAdd<__int64>::`vftable'
PUBLIC	??_R1A@?0A@EA@WorkingAreaFactory@PlaneOfBlocks@@8 ; PlaneOfBlocks::WorkingAreaFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7WorkingArea@PlaneOfBlocks@@6B@		; PlaneOfBlocks::WorkingArea::`vftable'
PUBLIC	??_R1A@?0A@EA@?$AioSub@H@conc@@8		; conc::AioSub<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$AioSub@H@conc@@6B@			; conc::AioSub<int>::`vftable'
PUBLIC	??_7?$AioSub@I@conc@@6B@			; conc::AioSub<unsigned int>::`vftable'
PUBLIC	??_R1A@?0A@EA@?$AioAdd@_J@conc@@8		; conc::AioAdd<__int64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> > `RTTI Type Descriptor'
PUBLIC	??_R4WorkingArea@PlaneOfBlocks@@6B@		; PlaneOfBlocks::WorkingArea::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8 ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *> `RTTI Type Descriptor'
PUBLIC	??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`vftable'
PUBLIC	??_R1A@?0A@EA@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVWorkingArea@PlaneOfBlocks@@@8		; PlaneOfBlocks::WorkingArea `RTTI Type Descriptor'
PUBLIC	??_R2?$AioSub@I@conc@@8				; conc::AioSub<unsigned int>::`RTTI Base Class Array'
PUBLIC	??_R3WorkingArea@PlaneOfBlocks@@8		; PlaneOfBlocks::WorkingArea::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@WorkingArea@PlaneOfBlocks@@8	; PlaneOfBlocks::WorkingArea::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7WorkingAreaFactory@PlaneOfBlocks@@6B@	; PlaneOfBlocks::WorkingAreaFactory::`vftable'
PUBLIC	??_R2?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`RTTI Base Class Array'
PUBLIC	??_7?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`vftable'
PUBLIC	??_R4?$AioSub@H@conc@@6B@			; conc::AioSub<int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8 ; conc::CellPool<PlaneOfBlocks::WorkingArea *> `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$AioAdd@_J@conc@@@8			; conc::AioAdd<__int64> `RTTI Type Descriptor'
PUBLIC	??_R2WorkingArea@PlaneOfBlocks@@8		; PlaneOfBlocks::WorkingArea::`RTTI Base Class Array'
PUBLIC	??_R3?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$AioSub@I@conc@@6B@			; conc::AioSub<unsigned int>::`RTTI Complete Object Locator'
PUBLIC	??_R2?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$AioSub@I@conc@@8				; conc::AioSub<unsigned int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`RTTI Base Class Array'
PUBLIC	??_R2?$AioAdd@_J@conc@@8			; conc::AioAdd<__int64>::`RTTI Base Class Array'
PUBLIC	??_R3?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$AioSub@I@conc@@@8			; conc::AioSub<unsigned int> `RTTI Type Descriptor'
PUBLIC	??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`vftable'
PUBLIC	??_R0?AVWorkingAreaFactory@PlaneOfBlocks@@@8	; PlaneOfBlocks::WorkingAreaFactory `RTTI Type Descriptor'
PUBLIC	??_R4?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@@8 ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$AioSub@I@conc@@8		; conc::AioSub<unsigned int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`vftable'
PUBLIC	??_R3?$AioSub@H@conc@@8				; conc::AioSub<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@@8 ; conc::ObjPool<PlaneOfBlocks::WorkingArea> `RTTI Type Descriptor'
PUBLIC	??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@ ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`vftable'
PUBLIC	??_R4?$AioAdd@_J@conc@@6B@			; conc::AioAdd<__int64>::`RTTI Complete Object Locator'
EXTRN	_SadDummy:PROC
;	COMDAT ??_R4?$AioAdd@_J@conc@@6B@
rdata$r	SEGMENT
??_R4?$AioAdd@_J@conc@@6B@ DD 00H			; conc::AioAdd<__int64>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AioAdd@_J@conc@@@8
	DD	FLAT:??_R3?$AioAdd@_J@conc@@8
rdata$r	ENDS
;	COMDAT ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
CONST	SEGMENT
??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@ DD FLAT:??_R4?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@ ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`vftable'
	DD	FLAT:??_E?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::ObjPool<PlaneOfBlocks::WorkingArea> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$AioSub@H@conc@@8
rdata$r	SEGMENT
??_R3?$AioSub@H@conc@@8 DD 00H				; conc::AioSub<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$AioSub@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_7?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
CONST	SEGMENT
??_7?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ DD FLAT:??_R4?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`vftable'
	DD	FLAT:??_E?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AioSub@I@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AioSub@I@conc@@8 DD FLAT:??_R0?AV?$AioSub@I@conc@@@8 ; conc::AioSub<unsigned int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AioSub@I@conc@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@c'
	DB	'onc@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8 DD FLAT:??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8 DD FLAT:??_R0?AV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@@8 ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R4?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ DD 00H ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@@8
	DD	FLAT:??_R3?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWorkingAreaFactory@PlaneOfBlocks@@@8
data$r	SEGMENT
??_R0?AVWorkingAreaFactory@PlaneOfBlocks@@@8 DD FLAT:??_7type_info@@6B@ ; PlaneOfBlocks::WorkingAreaFactory `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWorkingAreaFactory@PlaneOfBlocks@@', 00H
data$r	ENDS
;	COMDAT ??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
CONST	SEGMENT
??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ DD FLAT:??_R4?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`vftable'
	DD	FLAT:??_E?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R0?AV?$AioSub@I@conc@@@8
data$r	SEGMENT
??_R0?AV?$AioSub@I@conc@@@8 DD FLAT:??_7type_info@@6B@	; conc::AioSub<unsigned int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AioSub@I@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R2?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R3?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8 DD 00H ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AioAdd@_J@conc@@8
rdata$r	SEGMENT
??_R2?$AioAdd@_J@conc@@8 DD FLAT:??_R1A@?0A@EA@?$AioAdd@_J@conc@@8 ; conc::AioAdd<__int64>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8
rdata$r	SEGMENT
??_R2?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 DD FLAT:??_R0?AV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8 ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R4?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ DD 00H ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@@8
	DD	FLAT:??_R3?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R3?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8 DD 00H ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AioSub@I@conc@@8
rdata$r	SEGMENT
??_R3?$AioSub@I@conc@@8 DD 00H				; conc::AioSub<unsigned int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$AioSub@I@conc@@8
rdata$r	ENDS
;	COMDAT ??_R4?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ DD 00H ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8
	DD	FLAT:??_R3?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8
rdata$r	SEGMENT
??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8 DD 00H ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 DD FLAT:??_R0?AV?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8 ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R2?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R2?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4?$AioSub@I@conc@@6B@
rdata$r	SEGMENT
??_R4?$AioSub@I@conc@@6B@ DD 00H			; conc::AioSub<unsigned int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AioSub@I@conc@@@8
	DD	FLAT:??_R3?$AioSub@I@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R3?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 DD 00H ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R2WorkingArea@PlaneOfBlocks@@8
rdata$r	SEGMENT
??_R2WorkingArea@PlaneOfBlocks@@8 DD FLAT:??_R1A@?0A@EA@WorkingArea@PlaneOfBlocks@@8 ; PlaneOfBlocks::WorkingArea::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AioAdd@_J@conc@@@8
data$r	SEGMENT
??_R0?AV?$AioAdd@_J@conc@@@8 DD FLAT:??_7type_info@@6B@	; conc::AioAdd<__int64> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AioAdd@_J@conc@@', 00H
data$r	ENDS
;	COMDAT ?hex4@?3??UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@2@HHH@Z@4QAY01$$CBHA
CONST	SEGMENT
?hex4@?3??UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@2@HHH@Z@4QAY01$$CBHA DD 0fffffffcH ; `PlaneOfBlocks::UMHSearch'::`4'::hex4
	DD	02H
	DD	0fffffffcH
	DD	01H
	DD	0fffffffcH
	DD	00H
	DD	0fffffffcH
	DD	0ffffffffH
	DD	0fffffffcH
	DD	0fffffffeH
	DD	04H
	DD	0fffffffeH
	DD	04H
	DD	0ffffffffH
	DD	04H
	DD	00H
	DD	04H
	DD	01H
	DD	04H
	DD	02H
	DD	02H
	DD	03H
	DD	00H
	DD	04H
	DD	0fffffffeH
	DD	03H
	DD	0fffffffeH
	DD	0fffffffdH
	DD	00H
	DD	0fffffffcH
	DD	02H
	DD	0fffffffdH
CONST	ENDS
;	COMDAT ??_R0?AV?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::CellPool<PlaneOfBlocks::WorkingArea *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$AioSub@H@conc@@6B@
rdata$r	SEGMENT
??_R4?$AioSub@H@conc@@6B@ DD 00H			; conc::AioSub<int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AioSub@H@conc@@@8
	DD	FLAT:??_R3?$AioSub@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_7?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
CONST	SEGMENT
??_7?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ DD FLAT:??_R4?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`vftable'
	DD	FLAT:??_E?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R2?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7WorkingAreaFactory@PlaneOfBlocks@@6B@
CONST	SEGMENT
??_7WorkingAreaFactory@PlaneOfBlocks@@6B@ DD FLAT:??_R4WorkingAreaFactory@PlaneOfBlocks@@6B@ ; PlaneOfBlocks::WorkingAreaFactory::`vftable'
	DD	FLAT:??_EWorkingAreaFactory@PlaneOfBlocks@@UAEPAXI@Z
	DD	FLAT:?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@WorkingArea@PlaneOfBlocks@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@WorkingArea@PlaneOfBlocks@@8 DD FLAT:??_R0?AVWorkingArea@PlaneOfBlocks@@@8 ; PlaneOfBlocks::WorkingArea::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3WorkingArea@PlaneOfBlocks@@8
rdata$r	ENDS
;	COMDAT ??_R3WorkingArea@PlaneOfBlocks@@8
rdata$r	SEGMENT
??_R3WorkingArea@PlaneOfBlocks@@8 DD 00H		; PlaneOfBlocks::WorkingArea::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2WorkingArea@PlaneOfBlocks@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AioSub@I@conc@@8
rdata$r	SEGMENT
??_R2?$AioSub@I@conc@@8 DD FLAT:??_R1A@?0A@EA@?$AioSub@I@conc@@8 ; conc::AioSub<unsigned int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVWorkingArea@PlaneOfBlocks@@@8
data$r	SEGMENT
??_R0?AVWorkingArea@PlaneOfBlocks@@@8 DD FLAT:??_7type_info@@6B@ ; PlaneOfBlocks::WorkingArea `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWorkingArea@PlaneOfBlocks@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8 DD FLAT:??_R0?AV?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@@8 ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
CONST	SEGMENT
??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ DD FLAT:??_R4?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`vftable'
	DD	FLAT:??_E?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@'
	DB	'@', 00H
data$r	ENDS
;	COMDAT ??_R4WorkingArea@PlaneOfBlocks@@6B@
rdata$r	SEGMENT
??_R4WorkingArea@PlaneOfBlocks@@6B@ DD 00H		; PlaneOfBlocks::WorkingArea::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWorkingArea@PlaneOfBlocks@@@8
	DD	FLAT:??_R3WorkingArea@PlaneOfBlocks@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@Pl'
	DB	'aneOfBlocks@@@conc@@@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AioAdd@_J@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AioAdd@_J@conc@@8 DD FLAT:??_R0?AV?$AioAdd@_J@conc@@@8 ; conc::AioAdd<__int64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AioAdd@_J@conc@@8
rdata$r	ENDS
;	COMDAT ??_7?$AioSub@I@conc@@6B@
CONST	SEGMENT
??_7?$AioSub@I@conc@@6B@ DD FLAT:??_R4?$AioSub@I@conc@@6B@ ; conc::AioSub<unsigned int>::`vftable'
	DD	FLAT:??_E?$AioSub@I@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$AioSub@H@conc@@6B@
CONST	SEGMENT
??_7?$AioSub@H@conc@@6B@ DD FLAT:??_R4?$AioSub@H@conc@@6B@ ; conc::AioSub<int>::`vftable'
	DD	FLAT:??_E?$AioSub@H@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R3?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8 DD 00H ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AioSub@H@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AioSub@H@conc@@8 DD FLAT:??_R0?AV?$AioSub@H@conc@@@8 ; conc::AioSub<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AioSub@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_7WorkingArea@PlaneOfBlocks@@6B@
CONST	SEGMENT
??_7WorkingArea@PlaneOfBlocks@@6B@ DD FLAT:??_R4WorkingArea@PlaneOfBlocks@@6B@ ; PlaneOfBlocks::WorkingArea::`vftable'
	DD	FLAT:??_EWorkingArea@PlaneOfBlocks@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@WorkingAreaFactory@PlaneOfBlocks@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@WorkingAreaFactory@PlaneOfBlocks@@8 DD FLAT:??_R0?AVWorkingAreaFactory@PlaneOfBlocks@@@8 ; PlaneOfBlocks::WorkingAreaFactory::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3WorkingAreaFactory@PlaneOfBlocks@@8
rdata$r	ENDS
;	COMDAT ??_7?$AioAdd@_J@conc@@6B@
CONST	SEGMENT
??_7?$AioAdd@_J@conc@@6B@ DD FLAT:??_R4?$AioAdd@_J@conc@@6B@ ; conc::AioAdd<__int64>::`vftable'
	DD	FLAT:??_E?$AioAdd@_J@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@ DD 00H ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@@8
	DD	FLAT:??_R3?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AioAdd@_J@conc@@8
rdata$r	SEGMENT
??_R3?$AioAdd@_J@conc@@8 DD 00H				; conc::AioAdd<__int64>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$AioAdd@_J@conc@@8
rdata$r	ENDS
;	COMDAT ??_R4WorkingAreaFactory@PlaneOfBlocks@@6B@
rdata$r	SEGMENT
??_R4WorkingAreaFactory@PlaneOfBlocks@@6B@ DD 00H	; PlaneOfBlocks::WorkingAreaFactory::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWorkingAreaFactory@PlaneOfBlocks@@@8
	DD	FLAT:??_R3WorkingAreaFactory@PlaneOfBlocks@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AioSub@H@conc@@@8
data$r	SEGMENT
??_R0?AV?$AioSub@H@conc@@@8 DD FLAT:??_7type_info@@6B@	; conc::AioSub<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AioSub@H@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	SEGMENT
??_R2?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@8 ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$AioSub@H@conc@@8
rdata$r	SEGMENT
??_R2?$AioSub@H@conc@@8 DD FLAT:??_R1A@?0A@EA@?$AioSub@H@conc@@8 ; conc::AioSub<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3WorkingAreaFactory@PlaneOfBlocks@@8
rdata$r	SEGMENT
??_R3WorkingAreaFactory@PlaneOfBlocks@@8 DD 00H		; PlaneOfBlocks::WorkingAreaFactory::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2WorkingAreaFactory@PlaneOfBlocks@@8
rdata$r	ENDS
;	COMDAT ??_R4?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@ DD 00H ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@@8
	DD	FLAT:??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R2WorkingAreaFactory@PlaneOfBlocks@@8
rdata$r	SEGMENT
??_R2WorkingAreaFactory@PlaneOfBlocks@@8 DD FLAT:??_R1A@?0A@EA@WorkingAreaFactory@PlaneOfBlocks@@8 ; PlaneOfBlocks::WorkingAreaFactory::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CF@IAFINEIK@best?5blk?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5sad?$DN?$CFd?5ite@
CONST	SEGMENT
??_C@_0CF@IAFINEIK@best?5blk?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5sad?$DN?$CFd?5ite@ DB 'b'
	DB	'est blk=%d x=%d y=%d sad=%d iter=%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NLNDHOHM@bad?5?5blk?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5sad?$DN?$CFd?5mea@
CONST	SEGMENT
??_C@_0CN@NLNDHOHM@bad?5?5blk?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5sad?$DN?$CFd?5mea@ DB 'b'
	DB	'ad  blk=%d x=%d y=%d sad=%d mean=%d iter=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@INGOFGFH@return_obj?$CI?$CJ?3?5cannot?5allocate?5a?5@
CONST	SEGMENT
??_C@_0CK@INGOFGFH@return_obj?$CI?$CJ?3?5cannot?5allocate?5a?5@ DB 'retur'
	DB	'n_obj(): cannot allocate a new cell.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OOMJLBPB@MVTools?3?5error?5while?5trying?5to?5a@
CONST	SEGMENT
??_C@_0EA@OOMJLBPB@MVTools?3?5error?5while?5trying?5to?5a@ DB 'MVTools: e'
	DB	'rror while trying to allocate DCT objects using FFTW.', 00H ; `string'
?zeroMV@@3UVECTOR@@B DD 00H				; zeroMV
	DD	00H
	DD	0ffffffffH
	ORG $+4
?hex2@@3QAY01$$CBHA DD 0ffffffffH			; hex2
	DD	0fffffffeH
	DD	0fffffffeH
	DD	00H
	DD	0ffffffffH
	DD	02H
	DD	01H
	DD	02H
	DD	02H
	DD	00H
	DD	01H
	DD	0fffffffeH
	DD	0ffffffffH
	DD	0fffffffeH
	DD	0fffffffeH
	DD	00H
?mod6m1@@3QBHB DD 05H					; mod6m1
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	00H
PUBLIC	?construct@?$AllocAlign@E$0BA@@@QAEXPAEABE@Z	; AllocAlign<unsigned char,16>::construct
PUBLIC	??$_Construct1@EE@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXU?$integral_constant@_N$0A@@1@AAV?$AllocAlign@E$0BA@@@PAE$$QAE@Z ; std::allocator_traits<AllocAlign<unsigned char,16> >::_Construct1<unsigned char,unsigned char>
PUBLIC	??R?$AioSub@I@conc@@QBEII@Z			; conc::AioSub<unsigned int>::operator()
PUBLIC	??$construct@EE@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAE$$QAE@Z ; std::allocator_traits<AllocAlign<unsigned char,16> >::construct<unsigned char,unsigned char>
PUBLIC	??$forward@E@std@@YA$$QAEAAE@Z			; std::forward<unsigned char>
PUBLIC	??$exec_both@IV?$AioSub@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioSub@I@1@AAI2@Z ; conc::AtomicIntOp::exec_both<unsigned int,conc::AioSub<unsigned int> >
PUBLIC	?destroy@?$AllocAlign@E$0BA@@@QAEXPAE@Z		; AllocAlign<unsigned char,16>::destroy
PUBLIC	??$_Destroy1@E@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAEU?$integral_constant@_N$0A@@1@@Z ; std::allocator_traits<AllocAlign<unsigned char,16> >::_Destroy1<unsigned char>
PUBLIC	??$construct@EE@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAE$$QAE@Z ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::construct<unsigned char,unsigned char>
PUBLIC	??$_Copy_memmove@PAPAVDCTClass@@PAPAV1@@std@@YAPAPAVDCTClass@@PAPAV1@00@Z ; std::_Copy_memmove<DCTClass * *,DCTClass * *>
PUBLIC	??$construct@UVECTOR@@$$V@?$allocator@UVECTOR@@@std@@QAEXPAUVECTOR@@@Z ; std::allocator<VECTOR>::construct<VECTOR>
PUBLIC	??$exec@IV?$AioSub@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioSub@I@1@@Z ; conc::AtomicIntOp::exec<unsigned int,conc::AioSub<unsigned int> >
PUBLIC	??0?$AioSub@I@conc@@QAE@I@Z			; conc::AioSub<unsigned int>::AioSub<unsigned int>
PUBLIC	??$move@AAE@std@@YA$$QAEAAE@Z			; std::move<unsigned char &>
PUBLIC	??_G?$AioSub@I@conc@@UAEPAXI@Z			; conc::AioSub<unsigned int>::`scalar deleting destructor'
PUBLIC	??1?$AioSub@I@conc@@UAE@XZ			; conc::AioSub<unsigned int>::~AioSub<unsigned int>
PUBLIC	??$destroy@E@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAE@Z ; std::allocator_traits<AllocAlign<unsigned char,16> >::destroy<unsigned char>
PUBLIC	??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >
PUBLIC	??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ; std::_Ptr_move_cat<unsigned char,unsigned char>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAVDCTClass@@PAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked1<DCTClass *,DCTClass *,std::allocator<DCTClass *> >
PUBLIC	??$_Ptr_move_cat@PAVDCTClass@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVDCTClass@@0@Z ; std::_Ptr_move_cat<DCTClass *,DCTClass *>
PUBLIC	??$construct@UVECTOR@@$$V@?$allocator_traits@V?$allocator@UVECTOR@@@std@@@std@@SAXAAV?$allocator@UVECTOR@@@1@PAUVECTOR@@@Z ; std::allocator_traits<std::allocator<VECTOR> >::construct<VECTOR>
PUBLIC	??R?$AioAdd@_J@conc@@QBE_J_J@Z			; conc::AioAdd<__int64>::operator()
PUBLIC	?cas_combi@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@CAXAATCombi@12@0ABT312@1@Z ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas_combi
PUBLIC	?read_ptr@?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@ABEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::read_ptr
PUBLIC	?cas@?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@PAV32@0@Z ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas
PUBLIC	?cas@?$AtomicInt@_J@conc@@QAE_J_J0@Z		; conc::AtomicInt<__int64>::cas
PUBLIC	??Z?$AtomicInt@I@conc@@QAEAAV01@ABI@Z		; conc::AtomicInt<unsigned int>::operator-=
PUBLIC	??0?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ; conc::LockFreeCell<PlaneOfBlocks::WorkingArea *>::LockFreeCell<PlaneOfBlocks::WorkingArea *>
PUBLIC	??$destroy@E@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAE@Z ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::destroy<unsigned char>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >
PUBLIC	??$_Rechecked@PAPAVDCTClass@@PAPAV1@@std@@YAAAPAPAVDCTClass@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<DCTClass * *,DCTClass * *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAPAVDCTClass@@PAPAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<DCTClass * *,DCTClass * *,std::allocator<DCTClass *> >
PUBLIC	??$_Unchecked@PAPAVDCTClass@@@std@@YAPAPAVDCTClass@@PAPAV1@@Z ; std::_Unchecked<DCTClass * *>
PUBLIC	??$construct@UVECTOR@@$$V@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEXPAUVECTOR@@@Z ; std::_Wrap_alloc<std::allocator<VECTOR> >::construct<VECTOR>
PUBLIC	??$construct@PAVDCTClass@@ABQAV1@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@ABQAV2@@Z ; std::allocator<DCTClass *>::construct<DCTClass *,DCTClass * const &>
PUBLIC	??$construct@PAVDCTClass@@AAPAV1@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@AAPAV2@@Z ; std::allocator<DCTClass *>::construct<DCTClass *,DCTClass * &>
PUBLIC	??$destroy@PAVDCTClass@@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@@Z ; std::allocator<DCTClass *>::destroy<DCTClass *>
PUBLIC	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
PUBLIC	??$_Unfancy@UVECTOR@@@std@@YAPAUVECTOR@@PAU1@@Z	; std::_Unfancy<VECTOR>
PUBLIC	??$_Unfancy@E@std@@YAPAEPAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	??R?$AioSub@H@conc@@QBEHH@Z			; conc::AioSub<int>::operator()
PUBLIC	?compute_total_size_for_zones@?$CellPool@PAVDCTClass@@@conc@@CAIH@Z ; conc::CellPool<DCTClass *>::compute_total_size_for_zones
PUBLIC	?cas2@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE_NPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@H0H@Z ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas2
PUBLIC	?get_val@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEHXZ ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::get_val
PUBLIC	?get_ptr@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::get_ptr
PUBLIC	?set@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEXPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@H@Z ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::set
PUBLIC	??0?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE@XZ ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >
PUBLIC	??A?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@$0EA@@conc@@QAEAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@1@J@Z ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>::operator[]
PUBLIC	??B?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@1@XZ ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::operator conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> *
PUBLIC	??4?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEAAV01@PAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@1@@Z ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::operator=
PUBLIC	??0?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE@XZ ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >
PUBLIC	?compute_total_size_for_zones@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@CAIH@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::compute_total_size_for_zones
PUBLIC	?compute_grown_size@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@CAII@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::compute_grown_size
PUBLIC	?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::allocate_zone
PUBLIC	?delete_obj_stack@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@AAEHAAV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::delete_obj_stack
PUBLIC	??F?$AtomicInt@I@conc@@QAEAAV01@XZ		; conc::AtomicInt<unsigned int>::operator--
PUBLIC	??0?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@$0EA@@conc@@QAE@XZ ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>
PUBLIC	??$_Destroy_range1@V?$allocator@UVECTOR@@@std@@PAUVECTOR@@@std@@YAXPAUVECTOR@@0AAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<VECTOR>,VECTOR *>
PUBLIC	??$_Destroy_range1@V?$AllocAlign@E$0BA@@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<AllocAlign<unsigned char,16>,unsigned char *>
PUBLIC	??$_Uninitialized_move@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z ; std::_Uninitialized_move<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >
PUBLIC	??$_Destroy_range1@V?$allocator@PAVDCTClass@@@std@@PAPAVDCTClass@@@std@@YAXPAPAVDCTClass@@0AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<DCTClass *>,DCTClass * *>
PUBLIC	??$_Uninitialized_move@PAPAVDCTClass@@PAPAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z ; std::_Uninitialized_move<DCTClass * *,DCTClass * *,std::allocator<DCTClass *> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<VECTOR *,unsigned int,std::allocator<VECTOR> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAEIV?$AllocAlign@E$0BA@@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_default_fill_n1<unsigned char *,unsigned int,AllocAlign<unsigned char,16> >
PUBLIC	??$construct@PAVDCTClass@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@ABQAV3@@Z ; std::allocator_traits<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * const &>
PUBLIC	??$forward@ABQAVDCTClass@@@std@@YAABQAVDCTClass@@ABQAV1@@Z ; std::forward<DCTClass * const &>
PUBLIC	??$construct@PAVDCTClass@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@AAPAV3@@Z ; std::allocator_traits<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * &>
PUBLIC	??$forward@AAPAVDCTClass@@@std@@YAAAPAVDCTClass@@AAPAV1@@Z ; std::forward<DCTClass * &>
PUBLIC	??$destroy@PAVDCTClass@@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@@Z ; std::allocator_traits<std::allocator<DCTClass *> >::destroy<DCTClass *>
PUBLIC	??$FetchPredictors@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ; PlaneOfBlocks::FetchPredictors<unsigned short>
PUBLIC	??$FetchPredictors@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ; PlaneOfBlocks::FetchPredictors<unsigned char>
PUBLIC	??$exec_both@HV?$AioSub@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioSub@H@1@AAH2@Z ; conc::AtomicIntOp::exec_both<int,conc::AioSub<int> >
PUBLIC	??$exec@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@@Z ; conc::AtomicIntOp::exec<__int64,conc::AioAdd<__int64> >
PUBLIC	??0?$AioAdd@_J@conc@@QAE@_J@Z			; conc::AioAdd<__int64>::AioAdd<__int64>
PUBLIC	?take_cell@?$CellPool@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@_N@Z ; conc::CellPool<DCTClass *>::take_cell
PUBLIC	??A?$Array@VTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@J@Z ; conc::Array<MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::TaskData,64>::operator[]
PUBLIC	?pop@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::pop
PUBLIC	?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push
PUBLIC	??0?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::LockFreeStack<PlaneOfBlocks::WorkingArea *>
PUBLIC	?return_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::return_cell
PUBLIC	?take_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::take_cell
PUBLIC	?expand_to@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXI@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::expand_to
PUBLIC	?clear_all@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::clear_all
PUBLIC	??0?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::CellPool<PlaneOfBlocks::WorkingArea *>
PUBLIC	?cleanup@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::cleanup
PUBLIC	?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::create
PUBLIC	?max_size@?$AllocAlign@E$0BA@@@QBEIXZ		; AllocAlign<unsigned char,16>::max_size
PUBLIC	?redirect_task@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::redirect_task
PUBLIC	?create@?$ObjFactoryInterface@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ ; conc::ObjFactoryInterface<DCTClass>::create
PUBLIC	??0?$allocator@UVECTOR@@@std@@QAE@XZ		; std::allocator<VECTOR>::allocator<VECTOR>
PUBLIC	??0?$AllocAlign@E$0BA@@@QAE@XZ			; AllocAlign<unsigned char,16>::AllocAlign<unsigned char,16>
PUBLIC	??0?$allocator@PAVDCTClass@@@std@@QAE@XZ	; std::allocator<DCTClass *>::allocator<DCTClass *>
PUBLIC	??_G?$AioAdd@_J@conc@@UAEPAXI@Z			; conc::AioAdd<__int64>::`scalar deleting destructor'
PUBLIC	??A?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEABUVECTOR@@I@Z ; std::vector<VECTOR,std::allocator<VECTOR> >::operator[]
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<VECTOR> >::_Wrap_alloc<std::allocator<VECTOR> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<VECTOR> >::_Vector_val<std::_Simple_types<VECTOR> >
PUBLIC	??0?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAE@XZ ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::_Wrap_alloc<AllocAlign<unsigned char,16> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<DCTClass *> >::_Wrap_alloc<std::allocator<DCTClass *> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DCTClass *> >::_Vector_val<std::_Simple_types<DCTClass *> >
PUBLIC	?access@?$MTSlicer_Access@VPlaneOfBlocks@@V1@@@SAPAVPlaneOfBlocks@@PAV2@@Z ; MTSlicer_Access<PlaneOfBlocks,PlaneOfBlocks>::access
PUBLIC	??1?$AioAdd@_J@conc@@UAE@XZ			; conc::AioAdd<__int64>::~AioAdd<__int64>
PUBLIC	??_G?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`scalar deleting destructor'
PUBLIC	??_G?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`scalar deleting destructor'
PUBLIC	??$_Fn@V?$AllocAlign@E$0BA@@@@_Alloc_max_size@std@@SAIHABV?$AllocAlign@E$0BA@@@@Z ; std::_Alloc_max_size::_Fn<AllocAlign<unsigned char,16> >
PUBLIC	??$_Destroy_range@V?$allocator@UVECTOR@@@std@@PAUVECTOR@@@std@@YAXPAUVECTOR@@0AAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<VECTOR>,VECTOR *>
PUBLIC	??$_Destroy_range@V?$AllocAlign@E$0BA@@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z ; std::_Destroy_range<AllocAlign<unsigned char,16>,unsigned char *>
PUBLIC	??$_Umove@PAE@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Umove<unsigned char *>
PUBLIC	??$_Destroy_range@V?$allocator@PAVDCTClass@@@std@@PAPAVDCTClass@@@std@@YAXPAPAVDCTClass@@0AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<DCTClass *>,DCTClass * *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??$_Umove@PAPAVDCTClass@@@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEPAPAVDCTClass@@PAPAV2@00@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Umove<DCTClass * *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1><>
PUBLIC	??$_Uninitialized_default_fill_n@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<VECTOR *,unsigned int,std::allocator<VECTOR> >
PUBLIC	??$_Uninitialized_default_fill_n@PAEIV?$AllocAlign@E$0BA@@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z ; std::_Uninitialized_default_fill_n<unsigned char *,unsigned int,AllocAlign<unsigned char,16> >
PUBLIC	??$construct@PAVDCTClass@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * const &>
PUBLIC	??$construct@PAVDCTClass@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * &>
PUBLIC	??$addressof@QAVDCTClass@@@std@@YAPBQAVDCTClass@@ABQAV1@@Z ; std::addressof<DCTClass * const>
PUBLIC	??$destroy@PAVDCTClass@@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@@Z ; std::_Wrap_alloc<std::allocator<DCTClass *> >::destroy<DCTClass *>
PUBLIC	??$_Unfancy@PAVDCTClass@@@std@@YAPAPAVDCTClass@@PAPAV1@@Z ; std::_Unfancy<DCTClass *>
PUBLIC	??$PseudoEPZSearch@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ; PlaneOfBlocks::PseudoEPZSearch<unsigned short>
PUBLIC	??$PseudoEPZSearch@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ; PlaneOfBlocks::PseudoEPZSearch<unsigned char>
PUBLIC	??$exec_new@HV?$AioSub@H@conc@@@AtomicIntOp@conc@@SAHAAV?$AtomicInt@H@1@AAV?$AioSub@H@1@@Z ; conc::AtomicIntOp::exec_new<int,conc::AioSub<int> >
PUBLIC	??0?$AioSub@H@conc@@QAE@H@Z			; conc::AioSub<int>::AioSub<int>
PUBLIC	??$recalculate_mv_slice@G@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::recalculate_mv_slice<unsigned short>
PUBLIC	??$recalculate_mv_slice@E@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::recalculate_mv_slice<unsigned char>
PUBLIC	??1?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::~CellPool<PlaneOfBlocks::WorkingArea *>
PUBLIC	?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::return_obj
PUBLIC	?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::take_obj
PUBLIC	?set_factory@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::set_factory
PUBLIC	??1?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::~ObjPool<PlaneOfBlocks::WorkingArea>
PUBLIC	??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::ObjPool<PlaneOfBlocks::WorkingArea>
PUBLIC	?deallocate@?$AllocAlign@E$0BA@@@QAEXPAEI@Z	; AllocAlign<unsigned char,16>::deallocate
PUBLIC	?allocate@?$AllocAlign@E$0BA@@@QAEPAEIPBX@Z	; AllocAlign<unsigned char,16>::allocate
PUBLIC	??Y?$AtomicInt@_J@conc@@QAEAAV01@AB_J@Z		; conc::AtomicInt<__int64>::operator+=
PUBLIC	??B?$AtomicInt@_J@conc@@QBE_JXZ			; conc::AtomicInt<__int64>::operator __int64
PUBLIC	??4?$AtomicInt@_J@conc@@QAEAAV01@_J@Z		; conc::AtomicInt<__int64>::operator=
PUBLIC	??0?$AtomicInt@_J@conc@@QAE@XZ			; conc::AtomicInt<__int64>::AtomicInt<__int64>
PUBLIC	??A?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@J@Z ; conc::Array<std::vector<int,std::allocator<int> >,2>::operator[]
PUBLIC	?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z ; conc::ObjPool<DCTClass>::return_obj
PUBLIC	?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ ; conc::ObjPool<DCTClass>::take_obj
PUBLIC	?use_factory@?$ObjPool@VDCTClass@@@conc@@QBEAAV?$ObjFactoryInterface@VDCTClass@@@2@XZ ; conc::ObjPool<DCTClass>::use_factory
PUBLIC	?start@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXHAAVPlaneOfBlocks@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::start
PUBLIC	?max_size@?$allocator@UVECTOR@@@std@@QBEIXZ	; std::allocator<VECTOR>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UVECTOR@@@std@@@std@@SAIABV?$allocator@UVECTOR@@@2@@Z ; std::allocator_traits<std::allocator<VECTOR> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAIABV?$AllocAlign@E$0BA@@@@Z ; std::allocator_traits<AllocAlign<unsigned char,16> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
PUBLIC	?max_size@?$allocator@PAVDCTClass@@@std@@QBEIXZ	; std::allocator<DCTClass *>::max_size
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator+=
PUBLIC	?deallocate@?$allocator@UVECTOR@@@std@@QAEXPAUVECTOR@@I@Z ; std::allocator<VECTOR>::deallocate
PUBLIC	?allocate@?$allocator@UVECTOR@@@std@@QAEPAUVECTOR@@I@Z ; std::allocator<VECTOR>::allocate
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<VECTOR> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_second
PUBLIC	?capacity@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myend
PUBLIC	?max_size@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@I@Z ; std::allocator<DCTClass *>::deallocate
PUBLIC	?allocate@?$allocator@PAVDCTClass@@@std@@QAEPAPAVDCTClass@@I@Z ; std::allocator<DCTClass *>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAIABV?$allocator@PAVDCTClass@@@2@@Z ; std::allocator_traits<std::allocator<DCTClass *> >::max_size
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAE@PAPAVDCTClass@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_second
PUBLIC	?max_size@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEIXZ ; std::vector<VECTOR,std::allocator<VECTOR> >::max_size
PUBLIC	?_Destroy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAEXPAUVECTOR@@0@Z ; std::vector<VECTOR,std::allocator<VECTOR> >::_Destroy
PUBLIC	?_Xlen@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IBEXXZ ; std::vector<VECTOR,std::allocator<VECTOR> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEPAUVECTOR@@I@Z ; std::_Wrap_alloc<std::allocator<VECTOR> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEXPAUVECTOR@@I@Z ; std::_Wrap_alloc<std::allocator<VECTOR> >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_first
PUBLIC	?_Unused_capacity@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Unused_capacity
PUBLIC	?max_size@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::max_size
PUBLIC	?_Destroy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Destroy
PUBLIC	?_Grow_to@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IBEII@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Reallocate
PUBLIC	?_Xlen@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IBEXXZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEPAEI@Z ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAEI@Z ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Unused_capacity@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Unused_capacity
PUBLIC	?size@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::size
PUBLIC	?_Destroy@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXPAPAVDCTClass@@0@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEII@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Grow_to
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEPAPAVDCTClass@@I@Z ; std::_Wrap_alloc<std::allocator<DCTClass *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@I@Z ; std::_Wrap_alloc<std::allocator<DCTClass *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<DCTClass *> >::max_size
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAE@PAPAVDCTClass@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator-=
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBEABQAVDCTClass@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_first
PUBLIC	?_Buy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAE_NI@Z ; std::vector<VECTOR,std::allocator<VECTOR> >::_Buy
PUBLIC	?_Tidy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAEXXZ ; std::vector<VECTOR,std::allocator<VECTOR> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABQAUVECTOR@@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABQAUVECTOR@@XZ ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Mylast
PUBLIC	??1?$AllocAlign@E$0BA@@@QAE@XZ			; AllocAlign<unsigned char,16>::~AllocAlign<unsigned char,16>
PUBLIC	?size@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::size
PUBLIC	?_Pop_back_n@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Pop_back_n
PUBLIC	?_Buy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAE_NI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Buy
PUBLIC	?_Reserve@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Reserve
PUBLIC	?_Tidy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXXZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Mylast
PUBLIC	?capacity@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::capacity
PUBLIC	?end@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@2@XZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::end
PUBLIC	?max_size@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::max_size
PUBLIC	?_Inside@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBE_NPBQAVDCTClass@@@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXXZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEXXZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEXPAPAVDCTClass@@0@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Orphan_range
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myend
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBEAAPAVDCTClass@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator*
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator-
PUBLIC	??1?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAE@XZ ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::~_Wrap_alloc<AllocAlign<unsigned char,16> >
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::~_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::~_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >
PUBLIC	??_G?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`scalar deleting destructor'
PUBLIC	??_G?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAEPAXI@Z ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`scalar deleting destructor'
PUBLIC	??_G?$AioSub@H@conc@@UAEPAXI@Z			; conc::AioSub<int>::`scalar deleting destructor'
PUBLIC	??0?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@I@Z ; std::vector<VECTOR,std::allocator<VECTOR> >::vector<VECTOR,std::allocator<VECTOR> >
PUBLIC	??1?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ ; std::vector<VECTOR,std::allocator<VECTOR> >::~vector<VECTOR,std::allocator<VECTOR> >
PUBLIC	?size@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEIXZ ; std::vector<VECTOR,std::allocator<VECTOR> >::size
PUBLIC	??A?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAEAAUVECTOR@@I@Z ; std::vector<VECTOR,std::allocator<VECTOR> >::operator[]
PUBLIC	??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::vector<unsigned char,AllocAlign<unsigned char,16> >
PUBLIC	??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@I@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::vector<unsigned char,AllocAlign<unsigned char,16> >
PUBLIC	??1?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::~vector<unsigned char,AllocAlign<unsigned char,16> >
PUBLIC	?resize@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::resize
PUBLIC	??A?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEAAEI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::operator[]
PUBLIC	??1?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::~ObjFactoryInterface<PlaneOfBlocks::WorkingArea>
PUBLIC	??1?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::~LockFreeStack<PlaneOfBlocks::WorkingArea *>
PUBLIC	??1?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAE@XZ ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::~AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >
PUBLIC	??0?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::vector<DCTClass *,std::allocator<DCTClass *> >
PUBLIC	??1?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::~vector<DCTClass *,std::allocator<DCTClass *> >
PUBLIC	?reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXI@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::reserve
PUBLIC	?empty@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBE_NXZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::empty
PUBLIC	?back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEAAPAVDCTClass@@XZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::back
PUBLIC	?push_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXABQAVDCTClass@@@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::push_back
PUBLIC	?pop_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXXZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::pop_back
PUBLIC	??1?$AioSub@H@conc@@UAE@XZ			; conc::AioSub<int>::~AioSub<int>
PUBLIC	?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ ; PlaneOfBlocks::WorkingAreaFactory::do_create
PUBLIC	??_G?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`scalar deleting destructor'
PUBLIC	??0?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>
PUBLIC	??_GWorkingAreaFactory@PlaneOfBlocks@@UAEPAXI@Z	; PlaneOfBlocks::WorkingAreaFactory::`scalar deleting destructor'
PUBLIC	??0WorkingAreaFactory@PlaneOfBlocks@@QAE@HHHHHHHHH@Z ; PlaneOfBlocks::WorkingAreaFactory::WorkingAreaFactory
PUBLIC	?MotionDistorsion@WorkingArea@PlaneOfBlocks@@QBEHHH@Z ; PlaneOfBlocks::WorkingArea::MotionDistorsion
PUBLIC	?IsVectorOK@WorkingArea@PlaneOfBlocks@@QBE_NHH@Z ; PlaneOfBlocks::WorkingArea::IsVectorOK
PUBLIC	??1WorkingArea@PlaneOfBlocks@@UAE@XZ		; PlaneOfBlocks::WorkingArea::~WorkingArea
PUBLIC	??_GWorkingArea@PlaneOfBlocks@@UAEPAXI@Z	; PlaneOfBlocks::WorkingArea::`scalar deleting destructor'
PUBLIC	??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z	; PlaneOfBlocks::WorkingArea::WorkingArea
PUBLIC	?search_mv_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::search_mv_slice
PUBLIC	?SquareDifferenceNorm@PlaneOfBlocks@@CAIABUVECTOR@@HH@Z ; PlaneOfBlocks::SquareDifferenceNorm
PUBLIC	?Median@PlaneOfBlocks@@CAHHHH@Z			; PlaneOfBlocks::Median
PUBLIC	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV
PUBLIC	?ClipMVy@PlaneOfBlocks@@AAEHAAVWorkingArea@1@H@Z ; PlaneOfBlocks::ClipMVy
PUBLIC	?ClipMVx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@H@Z ; PlaneOfBlocks::ClipMVx
PUBLIC	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir
PUBLIC	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
PUBLIC	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
PUBLIC	?CheckMV0@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV0
PUBLIC	?LumaSAD@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSAD
PUBLIC	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
PUBLIC	?GetRefBlockV@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::GetRefBlockV
PUBLIC	?GetRefBlockU@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::GetRefBlockU
PUBLIC	?GetRefBlock@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::GetRefBlock
PUBLIC	?estimate_global_mv_doubled_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::estimate_global_mv_doubled_slice
PUBLIC	?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z ; PlaneOfBlocks::UMHSearch
PUBLIC	?CrossSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHHH@Z ; PlaneOfBlocks::CrossSearch
PUBLIC	?Hex2Search@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::Hex2Search
PUBLIC	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch
PUBLIC	?OneTimeSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::OneTimeSearch
PUBLIC	?NStepSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::NStepSearch
PUBLIC	?DiamondSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::DiamondSearch
PUBLIC	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z	; PlaneOfBlocks::Refine
PUBLIC	?WriteHeaderToArray@PlaneOfBlocks@@QAEXPAH@Z	; PlaneOfBlocks::WriteHeaderToArray
PUBLIC	??1WorkingAreaFactory@PlaneOfBlocks@@UAE@XZ	; PlaneOfBlocks::WorkingAreaFactory::~WorkingAreaFactory
PUBLIC	??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ ; conc::Array<std::vector<int,std::allocator<int> >,2>::~Array<std::vector<int,std::allocator<int> >,2>
PUBLIC	??0?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ ; conc::Array<std::vector<int,std::allocator<int> >,2>::Array<std::vector<int,std::allocator<int> >,2>
PUBLIC	?GetVPadding@MVPlane@@QBEHXZ			; MVPlane::GetVPadding
PUBLIC	?GetHPadding@MVPlane@@QBEHXZ			; MVPlane::GetHPadding
PUBLIC	?GetAbsolutePelPointer@MVPlane@@QBEPBEHH@Z	; MVPlane::GetAbsolutePelPointer
PUBLIC	?cas@?$AtomicMem@$02@conc@@SA_JAC_J_J1@Z	; conc::AtomicMem<3>::cas
PUBLIC	?swap@?$AtomicMem@$02@conc@@SA_JAC_J_J@Z	; conc::AtomicMem<3>::swap
PUBLIC	?GetMode@MVFrame@@QAEHXZ			; MVFrame::GetMode
PUBLIC	?GetReducedHeight@FakePlaneOfBlocks@@QBEHXZ	; FakePlaneOfBlocks::GetReducedHeight
PUBLIC	?GetReducedWidth@FakePlaneOfBlocks@@QBEHXZ	; FakePlaneOfBlocks::GetReducedWidth
PUBLIC	?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z ; PlaneOfBlocks::RecalculateMVs
PUBLIC	?EstimateGlobalMVDoubled@PlaneOfBlocks@@QAEXPAUVECTOR@@AAV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::EstimateGlobalMVDoubled
PUBLIC	?GetArraySize@PlaneOfBlocks@@QAEHH@Z		; PlaneOfBlocks::GetArraySize
PUBLIC	?WriteDefaultToArray@PlaneOfBlocks@@QAEHPAHH@Z	; PlaneOfBlocks::WriteDefaultToArray
PUBLIC	??$InterpolatePrediction@G@PlaneOfBlocks@@QAEXABV0@@Z ; PlaneOfBlocks::InterpolatePrediction<unsigned short>
PUBLIC	??$InterpolatePrediction@E@PlaneOfBlocks@@QAEXABV0@@Z ; PlaneOfBlocks::InterpolatePrediction<unsigned char>
PUBLIC	?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z ; PlaneOfBlocks::SearchMVs
PUBLIC	??1PlaneOfBlocks@@QAE@XZ			; PlaneOfBlocks::~PlaneOfBlocks
PUBLIC	??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z ; PlaneOfBlocks::PlaneOfBlocks
EXTRN	??_E?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z:PROC ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`vector deleting destructor'
EXTRN	??_E?$AioSub@H@conc@@UAEPAXI@Z:PROC		; conc::AioSub<int>::`vector deleting destructor'
EXTRN	??_E?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z:PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`vector deleting destructor'
EXTRN	??_E?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAEPAXI@Z:PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`vector deleting destructor'
EXTRN	??_E?$AioSub@I@conc@@UAEPAXI@Z:PROC		; conc::AioSub<unsigned int>::`vector deleting destructor'
EXTRN	??_E?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z:PROC ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`vector deleting destructor'
EXTRN	??_E?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z:PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`vector deleting destructor'
EXTRN	??_E?$AioAdd@_J@conc@@UAEPAXI@Z:PROC		; conc::AioAdd<__int64>::`vector deleting destructor'
EXTRN	??_EWorkingAreaFactory@PlaneOfBlocks@@UAEPAXI@Z:PROC ; PlaneOfBlocks::WorkingAreaFactory::`vector deleting destructor'
EXTRN	??_EWorkingArea@PlaneOfBlocks@@UAEPAXI@Z:PROC	; PlaneOfBlocks::WorkingArea::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1PlaneOfBlocks@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1PlaneOfBlocks@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1PlaneOfBlocks@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1PlaneOfBlocks@@QAE@XZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ$3
__catchsym$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z$2
__catchsym$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ$3
__catchsym$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z$2
__catchsym$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\dctfactory.cpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z
_TEXT	SEGMENT
$T2 = -48						; size = 12
_dct_stack$3 = -36					; size = 12
__InitData$4 = -24					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv1419 = 8						; size = 4
__nBlkX$ = 8						; size = 4
tv1421 = 12						; size = 4
__nBlkY$ = 12						; size = 4
tv1365 = 16						; size = 4
_nbr_threads$1$ = 16					; size = 4
__nBlkSizeX$ = 16					; size = 4
_nLogyRatioUV$1$ = 20					; size = 4
tv1361 = 20						; size = 4
__nBlkSizeY$ = 20					; size = 4
__nPel$ = 24						; size = 4
_yRatioUV$1$ = 28					; size = 4
__nLevel$ = 28						; size = 4
_xRatioUV$1$ = 32					; size = 4
tv1363 = 32						; size = 4
_dct_cnt$1$ = 32					; size = 4
__nFlags$ = 32						; size = 4
_pixelsize$1$ = 36					; size = 4
__nOverlapX$ = 36					; size = 4
_bits_per_pixel$1$ = 40					; size = 4
__nOverlapY$ = 40					; size = 4
_dct_ptr$5 = 44						; size = 4
__xRatioUV$ = 44					; size = 4
__yRatioUV$ = 48					; size = 4
__pixelsize$ = 52					; size = 4
__bits_per_pixel$ = 56					; size = 4
_dct_pool_ptr$ = 60					; size = 4
tv1367 = 64						; size = 4
$T6 = 64						; size = 4
_mt_flag$ = 64						; size = 1
_err_flag$1$ = 67					; size = 1
??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z PROC ; PlaneOfBlocks::PlaneOfBlocks, COMDAT
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H

; 45   :   , nBlkY(_nBlkY)

	mov	eax, DWORD PTR __nBlkY$[ebp]

; 46   :   , nBlkSizeX(_nBlkSizeX)
; 47   :   , nBlkSizeY(_nBlkSizeY)
; 48   :   , nBlkCount(_nBlkX * _nBlkY)
; 49   :   , nPel(_nPel)

	mov	edx, DWORD PTR __nPel$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	ecx, DWORD PTR __nBlkSizeX$[ebp]
	push	edi
	mov	edi, DWORD PTR __nBlkX$[ebp]
	mov	DWORD PTR [esi], edi
	imul	edi, eax
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR __nBlkSizeY$[ebp]
	mov	DWORD PTR [esi+12], ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 25   : 	int result = 0;

	xor	ecx, ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 45   :   , nBlkY(_nBlkY)

	mov	DWORD PTR [esi+4], eax

; 50   :   , nLogPel(ilog2(_nPel))	// nLogPel=0 for nPel=1, 1 for nPel=2, 2 for nPel=4, i.e. (x*nPel) = (x<<nLogPel)

	mov	eax, edx
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edx
; File c:\github\mvtools\sources\commonfunctions.h

; 26   : 	while ( i > 1 ) { i /= 2; result++; }

	cmp	edx, 1
	jle	SHORT $LN34@PlaneOfBlo
	npad	2
$LL33@PlaneOfBlo:
	cdq
	inc	ecx
	sub	eax, edx
	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL33@PlaneOfBlo
$LN34@PlaneOfBlo:

; 7    : 	return ~(a >> (sizeof(int)*8 - 1)) & a;

	mov	edx, DWORD PTR __nLevel$[ebp]

; 33   : 	return 1 << satz(i);

	mov	eax, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 50   :   , nLogPel(ilog2(_nPel))	// nLogPel=0 for nPel=1, 1 for nPel=2, 2 for nPel=4, i.e. (x*nPel) = (x<<nLogPel)

	mov	DWORD PTR [esi+24], ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 7    : 	return ~(a >> (sizeof(int)*8 - 1)) & a;

	mov	ecx, edx
	sar	ecx, 31					; 0000001fH
	not	ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 51   :   , nLogScale(_nLevel)

	mov	DWORD PTR [esi+32], edx
; File c:\github\mvtools\sources\commonfunctions.h

; 7    : 	return ~(a >> (sizeof(int)*8 - 1)) & a;

	and	ecx, edx

; 33   : 	return 1 << satz(i);

	shl	eax, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 56   :   , xRatioUV(_xRatioUV) // PF

	lea	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR __nFlags$[ebp]
	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR __nOverlapX$[ebp]
	mov	DWORD PTR [esi+40], eax
	mov	eax, DWORD PTR __nOverlapY$[ebp]
	mov	DWORD PTR [esi+44], eax
	mov	eax, DWORD PTR __xRatioUV$[ebp]
	mov	DWORD PTR tv1421[ebp], ecx
	mov	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 25   : 	int result = 0;

	xor	ecx, ecx

; 26   : 	while ( i > 1 ) { i /= 2; result++; }

	cmp	eax, 1
	jle	SHORT $LN42@PlaneOfBlo
	npad	5
$LL41@PlaneOfBlo:
	cdq
	inc	ecx
	sub	eax, edx
	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL41@PlaneOfBlo
$LN42@PlaneOfBlo:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 58   :   , yRatioUV(_yRatioUV)

	mov	eax, DWORD PTR __yRatioUV$[ebp]
	mov	DWORD PTR [esi+52], ecx
	lea	ecx, DWORD PTR [esi+56]
	mov	DWORD PTR tv1419[ebp], ecx
	mov	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 25   : 	int result = 0;

	xor	ecx, ecx

; 26   : 	while ( i > 1 ) { i /= 2; result++; }

	cmp	eax, 1
	jle	SHORT $LN46@PlaneOfBlo
$LL45@PlaneOfBlo:
	cdq
	inc	ecx
	sub	eax, edx
	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL45@PlaneOfBlo
$LN46@PlaneOfBlo:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 60   :   , pixelsize(_pixelsize) // PF

	mov	eax, DWORD PTR __pixelsize$[ebp]
	mov	DWORD PTR [esi+60], ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 25   : 	int result = 0;

	xor	ecx, ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 60   :   , pixelsize(_pixelsize) // PF

	mov	DWORD PTR [esi+64], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 26   : 	while ( i > 1 ) { i /= 2; result++; }

	cmp	eax, 1
	jle	SHORT $LN50@PlaneOfBlo
	npad	5
$LL49@PlaneOfBlo:
	cdq
	inc	ecx
	sub	eax, edx
	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL49@PlaneOfBlo
$LN50@PlaneOfBlo:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 62   :   , bits_per_pixel(_bits_per_pixel) // PF

	mov	eax, DWORD PTR __bits_per_pixel$[ebp]
	mov	DWORD PTR [esi+72], eax

; 63   :   , _mt_flag(mt_flag)

	mov	al, BYTE PTR _mt_flag$[ebp]
	mov	DWORD PTR [esi+68], ecx

; 64   :   , SAD(0)
; 65   :   , LUMA(0)
; 66   :   , VAR(0)
; 67   :   , BLITLUMA(0)
; 68   :   , BLITCHROMA(0)
; 69   :   , SADCHROMA(0)
; 70   :   , SATD(0)
; 71   :   , vectors(nBlkCount)

	lea	ecx, DWORD PTR [esi+108]
	push	edi
	mov	BYTE PTR [esi+76], al
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+100], 0
	mov	DWORD PTR [esi+104], 0
	call	??0?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@I@Z ; std::vector<VECTOR,std::allocator<VECTOR> >::vector<VECTOR,std::allocator<VECTOR> >

; 72   :   , smallestPlane((_nFlags & MOTION_SMALLEST_PLANE) != 0)

	mov	ecx, DWORD PTR __nFlags$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edi, DWORD PTR __nBlkSizeX$[ebp]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 72   :   , smallestPlane((_nFlags & MOTION_SMALLEST_PLANE) != 0)

	shr	eax, 7
	and	al, 1

; 76   :   , dctpitch(std::max(_nBlkSizeX, 16))

	mov	DWORD PTR $T6[ebp], 16			; 00000010H
	mov	BYTE PTR [esi+120], al
	mov	eax, ecx
	shr	eax, 5
	and	al, 1
	shr	ecx, 11					; 0000000bH
	mov	BYTE PTR [esi+121], al
	and	cl, 1
	mov	BYTE PTR [esi+122], cl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T6[ebp]
	cmp	edi, 16					; 00000010H
	lea	ecx, DWORD PTR __nBlkSizeX$[ebp]
	cmovge	eax, ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 76   :   , dctpitch(std::max(_nBlkSizeX, 16))

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+124], eax

; 77   :   , _dct_pool_ptr(dct_pool_ptr)

	mov	eax, DWORD PTR _dct_pool_ptr$[ebp]
	mov	DWORD PTR [esi+128], eax

; 79   :   , freqArray()

	lea	eax, DWORD PTR [esi+132]
	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	push	OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	push	2
	push	12					; 0000000cH
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??_L@YGXPAXIIP6EX0@Z1@Z

; 78   :   , verybigSAD(_nBlkSizeX * _nBlkSizeY * (pixelsize == 4 ? 1 : (1 << bits_per_pixel))) // * 256, pixelsize==2 -> 65536. Float:1

	cmp	DWORD PTR [esi+64], 4
	mov	eax, 1
	je	SHORT $LN24@PlaneOfBlo
	mov	ecx, DWORD PTR [esi+72]
	shl	eax, cl
$LN24@PlaneOfBlo:
	imul	eax, edi

; 80   :   , dctmode(0)

	mov	DWORD PTR [esi+216], 0
	imul	eax, DWORD PTR __nBlkSizeY$[ebp]
	mov	DWORD PTR [esi+156], eax
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 54   : :	_val ()

	mov	DWORD PTR [esi+256], 0
	mov	DWORD PTR [esi+264], 0
	mov	DWORD PTR [esi+268], 0
	mov	DWORD PTR [esi+272], 0
	mov	DWORD PTR [esi+276], 0
; File c:\github\mvtools\sources\planeofblocks.cpp

; 81   :   , _workarea_fact(nBlkSizeX, nBlkSizeY, dctpitch, nLogxRatioUV, xRatioUV, nLogyRatioUV, yRatioUV, pixelsize, bits_per_pixel)

	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR _bits_per_pixel$1$[ebp], eax
	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR _pixelsize$1$[ebp], eax
	mov	eax, DWORD PTR tv1419[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _yRatioUV$1$[ebp], eax
	mov	eax, DWORD PTR [esi+60]
	mov	esi, DWORD PTR [esi+52]
	mov	DWORD PTR _nLogyRatioUV$1$[ebp], eax
	mov	eax, DWORD PTR tv1421[ebp]
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _xRatioUV$1$[ebp], edi

; 2515 : {

	mov	edi, DWORD PTR _this$[ebp]

; 81   :   , _workarea_fact(nBlkSizeX, nBlkSizeY, dctpitch, nLogxRatioUV, xRatioUV, nLogyRatioUV, yRatioUV, pixelsize, bits_per_pixel)

	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+124]
	mov	eax, DWORD PTR [eax+8]

; 2506 :   : _blk_size_x(nBlkSizeX)

	mov	DWORD PTR [edi+336], eax

; 2507 :   , _blk_size_y(nBlkSizeY)

	mov	eax, edi
	mov	DWORD PTR [edi+332], OFFSET ??_7WorkingAreaFactory@PlaneOfBlocks@@6B@

; 2508 :   , _dctpitch(dctpitch)
; 2509 :   , _x_ratio_uv_log(nLogxRatioUV)
; 2510 :   , _x_ratio_uv(xRatioUV)

	mov	edi, DWORD PTR _xRatioUV$1$[ebp]
	mov	DWORD PTR [eax+344], edx
	mov	DWORD PTR [eax+340], ecx
	lea	ecx, DWORD PTR [eax+332]

; 2511 :   , _y_ratio_uv_log(nLogyRatioUV)

	mov	eax, DWORD PTR _nLogyRatioUV$1$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 2512 :   , _y_ratio_uv(yRatioUV)

	mov	eax, DWORD PTR _yRatioUV$1$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 2513 :   , _pixelsize(pixelsize)

	mov	eax, DWORD PTR _pixelsize$1$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2514 :   , _bits_per_pixel(bits_per_pixel)

	mov	eax, DWORD PTR _bits_per_pixel$1$[ebp]
	mov	DWORD PTR [ecx+16], esi
	mov	DWORD PTR [ecx+20], edi
	mov	DWORD PTR [ecx+36], eax

; 81   :   , _workarea_fact(nBlkSizeX, nBlkSizeY, dctpitch, nLogxRatioUV, xRatioUV, nLogyRatioUV, yRatioUV, pixelsize, bits_per_pixel)

	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 82   :   , _workarea_pool()

	mov	esi, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [esi+376]
	call	??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::ObjPool<PlaneOfBlocks::WorkingArea>

; 89   :   freqArray[0].resize(8192 * _nPel * 2);

	mov	edi, DWORD PTR __nPel$[ebp]
; File c:\github\mvtools\sources\conc\objpool.hpp

; 93   : 	_factory_ptr = &fact;

	lea	eax, DWORD PTR [esi+332]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 82   :   , _workarea_pool()

	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 89   :   freqArray[0].resize(8192 * _nPel * 2);

	lea	ecx, DWORD PTR [esi+132]
	mov	DWORD PTR [esi+760], 0
	shl	edi, 14					; 0000000eH
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 63   : :	_val (val)

	mov	DWORD PTR [esi+764], 0
; File c:\github\mvtools\sources\planeofblocks.cpp

; 89   :   freqArray[0].resize(8192 * _nPel * 2);

	push	edi
; File c:\github\mvtools\sources\conc\objpool.hpp

; 93   : 	_factory_ptr = &fact;

	mov	DWORD PTR [esi+384], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 89   :   freqArray[0].resize(8192 * _nPel * 2);

	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize

; 90   :   freqArray[1].resize(8192 * _nPel * 2);

	push	edi
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	ecx, DWORD PTR [esi+144]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 90   :   freqArray[1].resize(8192 * _nPel * 2);

	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize

; 91   : 
; 92   :   bool sse2 = (bool)(nFlags & CPU_SSE2); // no tricks for really old processors. If SSE2 is reported, use it

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, eax
	shr	ecx, 17					; 00000011H
	and	ecx, -255				; ffffff01H
	mov	DWORD PTR tv1361[ebp], ecx

; 93   :   bool sse41 = (bool)(nFlags & CPUF_SSE4_1); 

	mov	ecx, eax
	shr	ecx, 10					; 0000000aH
	and	ecx, -255				; ffffff01H
	mov	DWORD PTR tv1363[ebp], ecx

; 94   :   bool avx = (bool)(nFlags & CPU_AVX);

	mov	ecx, eax
	shr	ecx, 25					; 00000019H
	and	ecx, -255				; ffffff01H

; 95   :   bool avx2 = (bool)(nFlags & CPU_AVX2);

	shr	eax, 26					; 0000001aH
	mov	DWORD PTR tv1365[ebp], ecx
	and	eax, -255				; ffffff01H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi+112]
	sub	ecx, DWORD PTR [esi+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 95   :   bool avx2 = (bool)(nFlags & CPU_AVX2);

	mov	DWORD PTR tv1367[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 106  :   memset(&vectors[0], 0, vectors.size() * sizeof(vectors[0]));

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	push	0
	push	DWORD PTR [esi+108]
	call	_memset

; 107  : 
; 108  :   // function's pointers 
; 109  :   // Sad_C: SadFunction.cpp
; 110  :   // Var_c: Variance.h   PF nowhere used!!!
; 111  :   // Luma_c: Variance.h 
; 112  :   // Copy_C: CopyCode
; 113  : 
; 114  : 
; 115  :   SATD = SadDummy; //for now disable SATD if default functions are used
; 116  : 
; 117  :                      // in overlaps.h
; 118  :                      // OverlapsLsbFunction
; 119  :                      // OverlapsFunction
; 120  :                      // in M(V)DegrainX: DenoiseXFunction
; 121  :   arch_t arch;
; 122  :   if (isse && avx2)

	mov	al, BYTE PTR [esi+121]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+104], OFFSET _SadDummy
	test	al, al
	je	SHORT $LN13@PlaneOfBlo
	cmp	BYTE PTR tv1367[ebp], 0
	je	SHORT $LN7@PlaneOfBlo

; 123  :     arch = USE_AVX2;

	mov	edi, 6
	jmp	SHORT $LN14@PlaneOfBlo
$LN7@PlaneOfBlo:

; 124  :   else if (isse && avx)

	test	al, al
	je	SHORT $LN13@PlaneOfBlo
	cmp	BYTE PTR tv1365[ebp], 0
	je	SHORT $LN9@PlaneOfBlo

; 125  :     arch = USE_AVX;

	mov	edi, 5
	jmp	SHORT $LN14@PlaneOfBlo
$LN9@PlaneOfBlo:

; 126  :   else if (isse && sse41)

	test	al, al
	je	SHORT $LN13@PlaneOfBlo
	cmp	BYTE PTR tv1363[ebp], 0
	je	SHORT $LN11@PlaneOfBlo

; 127  :     arch = USE_SSE41;

	mov	edi, 3
	jmp	SHORT $LN14@PlaneOfBlo
$LN11@PlaneOfBlo:

; 128  :   else if (isse && sse2)

	test	al, al
	je	SHORT $LN13@PlaneOfBlo
	cmp	BYTE PTR tv1361[ebp], 0
	je	SHORT $LN13@PlaneOfBlo

; 129  :     arch = USE_SSE2;

	mov	edi, 2

; 130  :   else

	jmp	SHORT $LN14@PlaneOfBlo
$LN13@PlaneOfBlo:

; 131  :     arch = NO_SIMD;

	xor	edi, edi
$LN14@PlaneOfBlo:

; 132  : 
; 133  :   SAD = get_sad_function(nBlkSizeX, nBlkSizeY, pixelsize, arch);

	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	push	edi
	push	DWORD PTR [esi+64]
	call	?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ; get_sad_function

; 134  :   SADCHROMA = get_sad_function(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, pixelsize, arch);

	mov	ecx, DWORD PTR tv1419[ebp]
	mov	DWORD PTR [esi+80], eax
	mov	eax, DWORD PTR [esi+12]
	cdq
	idiv	DWORD PTR [ecx]
	push	edi
	push	DWORD PTR [esi+64]
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+8]
	mov	esi, DWORD PTR tv1421[ebp]
	cdq
	idiv	DWORD PTR [esi]
	mov	edx, ecx
	mov	ecx, eax
	call	?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ; get_sad_function
	mov	esi, DWORD PTR _this$[ebp]

; 135  :   BLITLUMA = get_copy_function(nBlkSizeX, nBlkSizeY, pixelsize, arch);

	push	edi
	push	DWORD PTR [esi+64]
	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+100], eax
	call	?get_copy_function@@YAP6AXPAEHPBEH@ZHHHW4arch_t@@@Z ; get_copy_function

; 136  :   BLITCHROMA = get_copy_function(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, pixelsize, arch);

	mov	ecx, DWORD PTR tv1419[ebp]
	mov	DWORD PTR [esi+92], eax
	mov	eax, DWORD PTR [esi+12]
	cdq
	idiv	DWORD PTR [ecx]
	push	edi
	push	DWORD PTR [esi+64]
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+8]
	mov	esi, DWORD PTR tv1421[ebp]
	cdq
	idiv	DWORD PTR [esi]
	mov	edx, ecx
	mov	ecx, eax
	call	?get_copy_function@@YAP6AXPAEHPBEH@ZHHHW4arch_t@@@Z ; get_copy_function
	mov	esi, DWORD PTR _this$[ebp]

; 137  :   //VAR        = get_var_function(nBlkSizeX/xRatioUV, nBlkSizeY/yRatioUV, pixelsize, arch); // variance.h PF: no VAR
; 138  :   LUMA = get_luma_function(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, pixelsize, arch); // variance.h

	mov	ecx, DWORD PTR tv1419[ebp]
	push	edi
	mov	DWORD PTR [esi+96], eax
	mov	eax, DWORD PTR [esi+12]
	cdq
	idiv	DWORD PTR [ecx]
	push	DWORD PTR [esi+64]
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+8]
	mov	esi, DWORD PTR tv1421[ebp]
	cdq
	idiv	DWORD PTR [esi]
	mov	edx, ecx
	mov	ecx, eax
	call	?get_luma_function@@YAP6AIPBEH@ZHHHW4arch_t@@@Z ; get_luma_function
	mov	esi, DWORD PTR _this$[ebp]

; 139  :   SATD = get_satd_function(nBlkSizeX, nBlkSizeY, pixelsize, arch); // P.F. 2.7.0.22d SATD made live

	push	edi
	push	DWORD PTR [esi+64]
	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+84], eax
	call	?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ; get_satd_function
	add	esp, 48					; 00000030H
	mov	DWORD PTR [esi+104], eax

; 140  :   if (SATD == nullptr)

	test	eax, eax
	jne	SHORT $LN15@PlaneOfBlo

; 141  :     SATD = SadDummy;

	mov	DWORD PTR [esi+104], OFFSET _SadDummy
$LN15@PlaneOfBlo:

; 142  : 
; 143  :   if (!chroma)

	cmp	BYTE PTR [esi+122], 0
	jne	SHORT $LN16@PlaneOfBlo

; 144  :   {
; 145  :     SADCHROMA = SadDummy;

	mov	DWORD PTR [esi+100], OFFSET _SadDummy
$LN16@PlaneOfBlo:

; 146  :   }
; 147  : 
; 148  :   // for debug:
; 149  :   //         SAD = x264_pixel_sad_4x4_mmx2;
; 150  :   //         VAR = Var_C<8>;
; 151  :   //         LUMA = Luma_C<8>;
; 152  :   //         BLITLUMA = Copy_C<16,16>;
; 153  :   //		 BLITCHROMA = Copy_C<8,8>; // idem
; 154  :   //		 SADCHROMA = x264_pixel_sad_8x8_mmx2;
; 155  : 
; 156  : #ifdef ALLOW_DCT
; 157  :   if (_dct_pool_ptr != 0)

	mov	eax, DWORD PTR [esi+128]
	test	eax, eax
	je	$LN268@PlaneOfBlo

; 158  :   {
; 159  :     DCTFactory &	dct_fact =

	push	1
	push	OFFSET ??_R0?AVDCTFactory@@@8
	push	OFFSET ??_R0?AV?$ObjFactoryInterface@VDCTClass@@@conc@@@8
	push	0
	push	DWORD PTR [eax+8]
	call	___RTDynamicCast
	add	esp, 20					; 00000014H

; 160  :       dynamic_cast <DCTFactory &> (_dct_pool_ptr->use_factory());
; 161  :     dctmode = dct_fact.get_dctmode();

	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+216], ecx
; File c:\github\mvtools\sources\dctfactory.cpp

; 92   : 	return (_fftw_flag);

	mov	al, BYTE PTR [eax+25]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 166  :     if (dct_fact.use_fftw())

	test	al, al
	je	$LN268@PlaneOfBlo

; 169  :         (_mt_flag)

	cmp	BYTE PTR [esi+76], 0
	je	SHORT $LN25@PlaneOfBlo
	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 132  : 	return (_avstp_get_nbr_threads_ptr ());

	mov	eax, DWORD PTR [eax+16]
	call	eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 169  :         (_mt_flag)

	jmp	SHORT $LN391@PlaneOfBlo
$LN25@PlaneOfBlo:
	mov	eax, 1
$LN391@PlaneOfBlo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	xor	edi, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 169  :         (_mt_flag)

	mov	DWORD PTR _nbr_threads$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR _dct_stack$3[ebp], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR _dct_stack$3[ebp+4], edi

; 487  : 		_Myend()

	mov	DWORD PTR _dct_stack$3[ebp+8], edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 173  :       std::vector <DCTClass *>	dct_stack;

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1033 : 		if (capacity() < _Count)

	test	eax, eax
	je	SHORT $LN127@PlaneOfBlo

; 1034 : 			{	// something to do, check and reallocate
; 1035 : 			if (max_size() < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN128@PlaneOfBlo

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN392@PlaneOfBlo:
$LN128@PlaneOfBlo:

; 1037 : 			_Reallocate(_Count);

	push	eax
	lea	ecx, DWORD PTR _dct_stack$3[ebp]
	call	?_Reallocate@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reallocate
	mov	edi, DWORD PTR _dct_stack$3[ebp+4]
	mov	eax, DWORD PTR _nbr_threads$1$[ebp]
$LN127@PlaneOfBlo:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 175  :       bool				err_flag = false;

	xor	cl, cl

; 176  :       for (int dct_cnt = 0; dct_cnt < nbr_threads && !err_flag; ++dct_cnt)

	mov	DWORD PTR _dct_cnt$1$[ebp], 0
	mov	BYTE PTR _err_flag$1$[ebp], cl
	test	eax, eax
	jle	SHORT $LN366@PlaneOfBlo
	mov	edi, DWORD PTR _nbr_threads$1$[ebp]
$LL4@PlaneOfBlo:
	test	cl, cl
	jne	SHORT $LN385@PlaneOfBlo

; 177  :       {
; 178  :         DCTClass *			dct_ptr = _dct_pool_ptr->take_obj();

	mov	ecx, DWORD PTR [esi+128]
	call	?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ ; conc::ObjPool<DCTClass>::take_obj
	mov	DWORD PTR _dct_ptr$5[ebp], eax

; 179  :         if (dct_ptr == 0)

	test	eax, eax
	jne	SHORT $LN19@PlaneOfBlo

; 180  :         {
; 181  :           err_flag = true;

	mov	cl, 1
	mov	BYTE PTR _err_flag$1$[ebp], cl

; 182  :         }
; 183  :         else

	jmp	SHORT $LN2@PlaneOfBlo
$LN19@PlaneOfBlo:

; 184  :         {
; 185  :           dct_stack.push_back(dct_ptr);

	lea	eax, DWORD PTR _dct_ptr$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _dct_stack$3[ebp]
	call	?push_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXABQAVDCTClass@@@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::push_back
	mov	cl, BYTE PTR _err_flag$1$[ebp]
$LN2@PlaneOfBlo:

; 176  :       for (int dct_cnt = 0; dct_cnt < nbr_threads && !err_flag; ++dct_cnt)

	mov	eax, DWORD PTR _dct_cnt$1$[ebp]
	inc	eax
	mov	DWORD PTR _dct_cnt$1$[ebp], eax
	cmp	eax, edi
	jl	SHORT $LL4@PlaneOfBlo
$LN385@PlaneOfBlo:
	mov	edi, DWORD PTR _dct_stack$3[ebp+4]
$LN366@PlaneOfBlo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR _dct_stack$3[ebp]
	cmp	eax, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 188  :       while (!dct_stack.empty())

	je	SHORT $LN6@PlaneOfBlo
	npad	9
$LL5@PlaneOfBlo:

; 189  :       {
; 190  :         DCTClass *			dct_ptr = dct_stack.back();
; 191  :         _dct_pool_ptr->return_obj(*dct_ptr);

	push	DWORD PTR [edi-4]
	mov	ecx, DWORD PTR [esi+128]
	call	?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z ; conc::ObjPool<DCTClass>::return_obj
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR _dct_stack$3[ebp]

; 1315 : 		--this->_Mylast();

	sub	edi, 4
	mov	DWORD PTR _dct_stack$3[ebp+4], edi

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	cmp	eax, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 188  :       while (!dct_stack.empty())

	jne	SHORT $LL5@PlaneOfBlo
$LN6@PlaneOfBlo:

; 192  :         dct_stack.pop_back();
; 193  :       }
; 194  :       if (err_flag)

	cmp	BYTE PTR _err_flag$1$[ebp], 0
	je	SHORT $LN21@PlaneOfBlo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h

; 55   :         __std_exception_copy(&_InitData, &_Data);

	lea	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR $T2[ebp], OFFSET ??_7exception@std@@6B@
	push	eax
	lea	eax, DWORD PTR __InitData$4[ebp]
	mov	DWORD PTR __InitData$4[ebp], OFFSET ??_C@_0EA@OOMJLBPB@MVTools?3?5error?5while?5trying?5to?5a@
	xorps	xmm0, xmm0

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	BYTE PTR __InitData$4[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	movq	QWORD PTR $T2[ebp+4], xmm0
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept

; 168  : 		{	// construct from message string

	mov	DWORD PTR $T2[ebp], OFFSET ??_7runtime_error@std@@6B@
; File c:\github\mvtools\sources\planeofblocks.cpp

; 196  :         throw std::runtime_error(

	lea	eax, DWORD PTR $T2[ebp]
	push	OFFSET __TI2?AVruntime_error@std@@
	push	eax
	call	__CxxThrowException@8
$LN393@PlaneOfBlo:
$LN21@PlaneOfBlo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	eax, eax
	je	SHORT $LN268@PlaneOfBlo

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR _dct_stack$3[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
$LN268@PlaneOfBlo:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 203  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	60					; 0000003cH
$LN387@PlaneOfBlo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ ; std::vector<VECTOR,std::allocator<VECTOR> >::~vector<VECTOR,std::allocator<VECTOR> >
__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ
__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 332				; 0000014cH
	jmp	??1WorkingAreaFactory@PlaneOfBlocks@@UAE@XZ
__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::~ObjPool<PlaneOfBlocks::WorkingArea>
__unwindfunclet$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$4:
	lea	ecx, DWORD PTR _dct_stack$3[ebp]
	jmp	??1?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ ; std::vector<DCTClass *,std::allocator<DCTClass *> >::~vector<DCTClass *,std::allocator<DCTClass *> >
__ehhandler$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z ENDP ; PlaneOfBlocks::PlaneOfBlocks
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\objfactoryinterface.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??1PlaneOfBlocks@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1PlaneOfBlocks@@QAE@XZ PROC				; PlaneOfBlocks::~PlaneOfBlocks, COMDAT
; _this$ = ecx

; 208  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1PlaneOfBlocks@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 210  : }

	lea	ecx, DWORD PTR [esi+376]
	call	??1?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::~ObjPool<PlaneOfBlocks::WorkingArea>
; File c:\github\mvtools\sources\conc\objfactoryinterface.h

; 47   : 	virtual			~ObjFactoryInterface () {}

	mov	DWORD PTR [esi+332], OFFSET ??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	push	2
	push	12					; 0000000cH
	lea	eax, DWORD PTR [esi+132]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+108]
	test	ecx, ecx
	je	SHORT $LN16@PlaneOfBlo

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+116]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+108], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+112], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+116], 0
$LN16@PlaneOfBlo:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 210  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1PlaneOfBlocks@@QAE@XZ$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1PlaneOfBlocks@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1PlaneOfBlocks@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1PlaneOfBlocks@@QAE@XZ ENDP				; PlaneOfBlocks::~PlaneOfBlocks
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z
_TEXT	SEGMENT
_slicer$ = -1060					; size = 1044
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__pSrcFrame$ = 8					; size = 4
__pRefFrame$ = 12					; size = 4
_st$ = 16						; size = 4
_stp$ = 20						; size = 4
_lambda$ = 24						; size = 4
_lsad$ = 28						; size = 4
_pnew$ = 32						; size = 4
_plevel$ = 36						; size = 4
_flags$ = 40						; size = 4
_out$ = 44						; size = 4
_globalMVec$ = 48					; size = 4
_outfilebuf$ = 52					; size = 4
$T3 = 56						; size = 4
_fieldShift$ = 56					; size = 4
_pmeanLumaChange$ = 60					; size = 4
_divideExtra$dead$ = 64					; size = 4
__pzero$ = 68						; size = 4
__pglobal$ = 72						; size = 4
__badSAD$ = 76						; size = 4
__badrange$ = 80					; size = 4
_meander$ = 84						; size = 1
_vecPrev$ = 88						; size = 4
__tryMany$ = 92						; size = 1
?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z PROC ; PlaneOfBlocks::SearchMVs, COMDAT
; _this$ = ecx

; 221  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1048				; 00000418H

; 231  :   dctweight16 = std::min((sad_t)16, (abs(*pmeanLumaChange) >> (bits_per_pixel-8)) / (nBlkSizeX*nBlkSizeY)); //equal dct and spatial weights for meanLumaChange=8 (empirical)

	mov	eax, DWORD PTR _pmeanLumaChange$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _fieldShift$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR $T2[ebp], 16			; 00000010H

; 529  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	mov	ebx, DWORD PTR _out$[ebp]

; 231  :   dctweight16 = std::min((sad_t)16, (abs(*pmeanLumaChange) >> (bits_per_pixel-8)) / (nBlkSizeX*nBlkSizeY)); //equal dct and spatial weights for meanLumaChange=8 (empirical)

	mov	ecx, DWORD PTR [edi+72]
	mov	DWORD PTR [edi+204], 0
	sub	ecx, 8
	mov	DWORD PTR [edi+208], esi
	mov	DWORD PTR [edi+212], 0
	mov	eax, DWORD PTR [eax]
	cdq
	xor	eax, edx
	sub	eax, edx
	sar	eax, cl
	mov	ecx, DWORD PTR [edi+12]
	imul	ecx, DWORD PTR [edi+8]
	cdq
	idiv	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	edx, DWORD PTR $T2[ebp]
	cmp	eax, 16					; 00000010H
; File c:\github\mvtools\sources\planeofblocks.cpp

; 231  :   dctweight16 = std::min((sad_t)16, (abs(*pmeanLumaChange) >> (bits_per_pixel-8)) / (nBlkSizeX*nBlkSizeY)); //equal dct and spatial weights for meanLumaChange=8 (empirical)

	mov	DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T3[ebp]
	cmovge	ecx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 236  :   _glob_mv_pred_def.x = globalMVec->x * nPel;	// v1.8.2

	mov	edx, DWORD PTR _globalMVec$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+220], eax
	mov	eax, DWORD PTR __badSAD$[ebp]
	mov	DWORD PTR [edi+248], eax
	mov	eax, DWORD PTR __badrange$[ebp]
	mov	DWORD PTR [edi+252], eax
	mov	eax, DWORD PTR [edx]
	imul	eax, DWORD PTR [edi+20]

; 250  : 
; 251  :   pSrcFrame = _pSrcFrame;

	mov	ecx, DWORD PTR __pSrcFrame$[ebp]
	mov	DWORD PTR [edi+280], eax
	mov	eax, DWORD PTR [edx+4]
	imul	eax, DWORD PTR [edi+20]
	add	eax, esi
	mov	DWORD PTR [edi+284], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [edi+288], eax

; 529  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	mov	eax, DWORD PTR [edi+16]
	lea	eax, DWORD PTR [eax+eax*2]
	inc	eax
	mov	DWORD PTR [ebx], eax

; 237  :   _glob_mv_pred_def.y = globalMVec->y * nPel + fieldShift;
; 238  :   _glob_mv_pred_def.sad = globalMVec->sad;
; 239  : 
; 240  :   //	int nOutPitchY = nBlkX * (nBlkSizeX - nOverlapX) + nOverlapX;
; 241  :   //	int nOutPitchUV = (nBlkX * (nBlkSizeX - nOverlapX) + nOverlapX) / 2; // xRatioUV=2
; 242  :   //	char debugbuf[128];
; 243  :   //	wsprintf(debugbuf,"MVCOMP1: nOutPitchUV=%d, nOverlap=%d, nBlkX=%d, nBlkSize=%d",nOutPitchUV, nOverlap, nBlkX, nBlkSize);
; 244  :   //	OutputDebugString(debugbuf);
; 245  : 
; 246  :     // write the plane's header
; 247  :   WriteHeaderToArray(out);
; 248  : 
; 249  :   nFlags |= flags;

	mov	eax, DWORD PTR _flags$[ebp]
	or	DWORD PTR [edi+36], eax

; 252  :   pRefFrame = _pRefFrame;

	mov	eax, DWORD PTR __pRefFrame$[ebp]
	mov	DWORD PTR [edi+160], ecx
	mov	DWORD PTR [edi+164], eax
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [ecx]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 255  :   nSrcPitch_plane[0] = pSrcFrame->GetPlane(YPLANE)->GetPitch();

	mov	DWORD PTR [edi+192], eax

; 256  :   if (chroma)

	cmp	BYTE PTR [edi+122], 0
	je	SHORT $LN2@SearchMVs
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 258  :     nSrcPitch_plane[1] = pSrcFrame->GetPlane(UPLANE)->GetPitch();

	mov	DWORD PTR [edi+196], eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [ecx+8]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 259  :     nSrcPitch_plane[2] = pSrcFrame->GetPlane(VPLANE)->GetPitch();

	mov	DWORD PTR [edi+200], eax
$LN2@SearchMVs:

; 260  :   }
; 261  :   nSrcPitch[0] = pixelsize * nBlkSizeX;

	mov	eax, DWORD PTR [edi+64]
	imul	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+168], eax

; 262  :   nSrcPitch[1] = pixelsize * nBlkSizeX / xRatioUV; // PF xRatio instead of /2: after 2.7.0.22c;

	mov	eax, DWORD PTR [edi+64]
	imul	eax, DWORD PTR [edi+8]
	cdq
	idiv	DWORD PTR [edi+48]
	mov	DWORD PTR [edi+172], eax

; 263  :   nSrcPitch[2] = pixelsize * nBlkSizeX / xRatioUV;

	mov	eax, DWORD PTR [edi+64]
	imul	eax, DWORD PTR [edi+8]
	cdq
	idiv	DWORD PTR [edi+48]
	mov	DWORD PTR [edi+176], eax

; 272  :   nRefPitch[0] = pRefFrame->GetPlane(YPLANE)->GetPitch();

	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 272  :   nRefPitch[0] = pRefFrame->GetPlane(YPLANE)->GetPitch();

	mov	DWORD PTR [edi+180], eax

; 273  :   if (chroma)

	cmp	BYTE PTR [edi+122], 0
	je	SHORT $LN3@SearchMVs

; 275  :     nRefPitch[1] = pRefFrame->GetPlane(UPLANE)->GetPitch();

	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 275  :     nRefPitch[1] = pRefFrame->GetPlane(UPLANE)->GetPitch();

	mov	DWORD PTR [edi+184], eax

; 276  :     nRefPitch[2] = pRefFrame->GetPlane(VPLANE)->GetPitch();

	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 276  :     nRefPitch[2] = pRefFrame->GetPlane(VPLANE)->GetPitch();

	mov	DWORD PTR [edi+188], eax
$LN3@SearchMVs:

; 277  :   }
; 278  : 
; 279  :   searchType = st;		// ( nLogScale == 0 ) ? st : EXHAUSTIVE;

	mov	eax, DWORD PTR _st$[ebp]

; 280  :   nSearchParam = stp;	// *nPel;	// v1.8.2 - redesigned in v1.8.5
; 281  : 
; 282  :   _lambda_level = lambda / (nPel * nPel);

	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR [edi+224], eax
	mov	eax, DWORD PTR _stp$[ebp]
	mov	DWORD PTR [edi+228], eax
	mov	eax, DWORD PTR _lambda$[ebp]
	imul	ecx, ecx
	cdq
	idiv	ecx
	mov	edx, eax

; 283  :   if (plevel == 1)

	mov	eax, DWORD PTR _plevel$[ebp]
	mov	DWORD PTR [edi+292], edx
	cmp	eax, 1
	jne	SHORT $LN4@SearchMVs

; 284  :   {
; 285  :     _lambda_level *= nScale;	// scale lambda - Fizick

	mov	ecx, DWORD PTR [edi+28]
	imul	ecx, edx
	mov	DWORD PTR [edi+292], ecx
	jmp	SHORT $LN6@SearchMVs
$LN4@SearchMVs:

; 286  :   }
; 287  :   else if (plevel == 2)

	cmp	eax, 2
	jne	SHORT $LN6@SearchMVs

; 288  :   {
; 289  :     _lambda_level *= nScale*nScale;

	mov	eax, DWORD PTR [edi+28]
	imul	eax, eax
	imul	eax, edx
	mov	DWORD PTR [edi+292], eax
$LN6@SearchMVs:

; 290  :   }
; 291  : 
; 292  :   temporal = (vecPrev != 0);

	mov	esi, DWORD PTR _vecPrev$[ebp]

; 293  :   if (vecPrev)
; 294  :   {
; 295  :     vecPrev += 1; // Just skips the header
; 296  :   }
; 297  : 
; 298  :   penaltyZero = _pzero;
; 299  :   pglobal = _pglobal;
; 300  :   badcount = 0;

	lea	ecx, DWORD PTR [edi+256]
	test	esi, esi
	setne	al
	mov	BYTE PTR [edi+260], al
	mov	eax, DWORD PTR __pzero$[ebp]
	mov	DWORD PTR [edi+240], eax
	mov	eax, DWORD PTR __pglobal$[ebp]
	mov	DWORD PTR [edi+244], eax
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 301  :   tryMany = _tryMany;

	mov	al, BYTE PTR __tryMany$[ebp]

; 302  :   planeSAD = 0;

	lea	ecx, DWORD PTR [edi+264]
	sub	esp, 8
	mov	BYTE PTR [edi+261], al
	call	??4?$AtomicInt@_J@conc@@QAEAAV01@_J@Z	; conc::AtomicInt<__int64>::operator=

; 303  :   sumLumaChange = 0;

	sub	esp, 8
	lea	ecx, DWORD PTR [edi+272]
	call	??4?$AtomicInt@_J@conc@@QAEAAV01@_J@Z	; conc::AtomicInt<__int64>::operator=

; 304  : 
; 305  :   _out = out;
; 306  :   _outfilebuf = outfilebuf;

	mov	eax, DWORD PTR _outfilebuf$[ebp]
	test	esi, esi
	mov	DWORD PTR [edi+300], eax
	lea	eax, DWORD PTR [esi+4]
	cmove	eax, esi
	mov	DWORD PTR [edi+296], ebx

; 307  :   _vecPrev = vecPrev;
; 308  :   _meander_flag = meander;
; 309  :   _pnew = pnew;
; 310  :   _lsad = lsad;
; 311  : 
; 312  :   // -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
; 313  : 
; 314  :   Slicer			slicer(_mt_flag);

	mov	bl, BYTE PTR [edi+76]
	mov	DWORD PTR [edi+304], eax
	mov	al, BYTE PTR _meander$[ebp]
	mov	BYTE PTR [edi+308], al
	mov	eax, DWORD PTR _pnew$[ebp]
	mov	DWORD PTR [edi+312], eax
	mov	eax, DWORD PTR _lsad$[ebp]
	mov	DWORD PTR [edi+316], eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 70   : {

	mov	DWORD PTR _slicer$[ebp], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR _slicer$[ebp+4], eax

; 66   : ,	_proc_ptr (0)
; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR _slicer$[ebp+16]
	push	1024					; 00000400H
	push	0
	mov	DWORD PTR _slicer$[ebp+8], 0
	push	eax
	mov	DWORD PTR _slicer$[ebp+12], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 69   : ,	_mt_flag (mt_flag)

	mov	BYTE PTR _slicer$[ebp+1040], bl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 315  :   slicer.start(nBlkY, *this, &PlaneOfBlocks::search_mv_slice, 4);

	push	4
	push	OFFSET ?search_mv_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::search_mv_slice
	push	edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _slicer$[ebp]
	push	DWORD PTR [edi+4]
	call	?start@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXHAAVPlaneOfBlocks@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::start
; File c:\github\mvtools\sources\mtslicer.hpp

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer$[ebp+1040], 0
	je	SHORT $LN79@SearchMVs

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer$[ebp+4]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer$[ebp+4]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN79@SearchMVs:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 320  :   if (smallestPlane)

	cmp	BYTE PTR [edi+120], 0
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR _slicer$[ebp+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer$[ebp+12], 0
; File c:\github\mvtools\sources\planeofblocks.cpp

; 320  :   if (smallestPlane)

	je	SHORT $LN8@SearchMVs

; 322  :     *pmeanLumaChange = (sad_t)(sumLumaChange / nBlkCount); // for all finer planes

	mov	eax, DWORD PTR [edi+16]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 93   : 	return (T (_val));

	mov	esi, DWORD PTR [edi+272]
	mov	ecx, DWORD PTR [edi+276]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 322  :     *pmeanLumaChange = (sad_t)(sumLumaChange / nBlkCount); // for all finer planes

	cdq
	push	edx
	push	eax
	push	ecx
	push	esi
	call	__alldiv
	mov	ecx, DWORD PTR _pmeanLumaChange$[ebp]
	mov	DWORD PTR [ecx], eax
$LN8@SearchMVs:
	pop	edi
; File c:\github\mvtools\sources\mtslicer.hpp

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR _slicer$[ebp+12], 0
	pop	esi

; 86   : {

	mov	DWORD PTR _slicer$[ebp], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@
	pop	ebx

; 87   : 	if (_dispatcher_ptr != 0)

	je	SHORT $LN88@SearchMVs

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer$[ebp+1040], 0
	je	SHORT $LN92@SearchMVs

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer$[ebp+4]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer$[ebp+4]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN92@SearchMVs:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR _slicer$[ebp+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer$[ebp+12], 0
$LN88@SearchMVs:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 325  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	88					; 00000058H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z$0:
	lea	ecx, DWORD PTR _slicer$[ebp]
	jmp	??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::~MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>
__unwindfunclet$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z:
	mov	eax, OFFSET __ehfuncinfo$?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z ENDP ; PlaneOfBlocks::SearchMVs
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??$InterpolatePrediction@E@PlaneOfBlocks@@QAEXABV0@@Z
_TEXT	SEGMENT
_v2$1$ = -124						; size = 4
_v1$1$ = -120						; size = 4
_v3$1$ = -116						; size = 4
tv699 = -116						; size = 4
_v4$1$ = -112						; size = 4
_iper2$1$ = -112					; size = 4
tv647 = -108						; size = 4
_normov$1$ = -104					; size = 4
_offx$1$ = -100						; size = 4
_l$1$ = -96						; size = 4
_a21$1$ = -92						; size = 4
_offy$1$ = -92						; size = 4
_a22$1$ = -88						; size = 4
_ax2$1$ = -88						; size = 4
_i$1$ = -88						; size = 4
_normFactor$2$ = -84					; size = 4
tv717 = -80						; size = 4
_k$1$ = -76						; size = 4
_index$1$ = -72						; size = 4
_jper2$1$ = -68						; size = 4
_aevenx$1$ = -64					; size = 4
_aoddx$1$ = -60						; size = 4
_aeveny$1$ = -56					; size = 4
_aoddy$1$ = -52						; size = 4
_v3$1 = -48						; size = 12
_v4$2 = -36						; size = 12
_v2$3 = -24						; size = 12
_v1$4 = -12						; size = 12
_pob$ = 8						; size = 4
??$InterpolatePrediction@E@PlaneOfBlocks@@QAEXABV0@@Z PROC ; PlaneOfBlocks::InterpolatePrediction<unsigned char>, COMDAT
; _this$ = ecx

; 432  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 124				; 0000007cH

; 433  :   int normFactor = 3 - nLogPel + pob.nLogPel;

	mov	eax, DWORD PTR _pob$[ebp]
	xor	edx, edx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [eax+24]
	push	edi
	sub	eax, DWORD PTR [esi+24]
	add	eax, 3

; 434  :   int mulFactor = (normFactor < 0) ? -normFactor : 0;
; 435  :   normFactor = (normFactor < 0) ? 0 : normFactor;
; 436  :   int normov = (nBlkSizeX - nOverlapX)*(nBlkSizeY - nOverlapY);

	mov	edi, DWORD PTR [esi+12]
	mov	ecx, eax
	neg	ecx
	test	eax, eax
	cmovns	ecx, edx
	mov	edx, DWORD PTR [esi+40]
	mov	DWORD PTR tv717[esp+136], ecx
	xor	ecx, ecx
	test	eax, eax
	cmovs	eax, ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _normFactor$2$[esp+136], eax
	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR _normov$1$[esp+136], eax
	mov	eax, edi
	sub	eax, DWORD PTR [esi+44]

; 437  :   int aoddx = (nBlkSizeX * 3 - nOverlapX * 2);

	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	ebx, DWORD PTR _normov$1$[esp+136]
	imul	ebx, eax
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR _normov$1$[esp+136], ebx
	mov	ebx, ecx
	sub	ebx, eax

; 438  :   int aevenx = (nBlkSizeX * 3 - nOverlapX * 4);

	lea	eax, DWORD PTR [edx*4]
	sub	ecx, eax
	mov	DWORD PTR _aoddx$1$[esp+136], ebx

; 439  :   int aoddy = (nBlkSizeY * 3 - nOverlapY * 2);

	mov	ebx, DWORD PTR [esi+44]
	mov	DWORD PTR _aevenx$1$[esp+136], ecx
	lea	ecx, DWORD PTR [edi+edi*2]
	mov	edx, ecx
	lea	eax, DWORD PTR [ebx+ebx]
	sub	edx, eax

; 440  :   int aeveny = (nBlkSizeY * 3 - nOverlapY * 4);

	lea	eax, DWORD PTR [ebx*4]
	sub	ecx, eax
	mov	DWORD PTR _aoddy$1$[esp+136], edx

; 441  :   // note: overlapping is still (v2.5.7) not processed properly
; 442  :   // PF todo make faster
; 443  :   for (int l = 0, index = 0; l < nBlkY; l++)

	xor	eax, eax
	mov	DWORD PTR _aeveny$1$[esp+136], ecx
	xor	ebx, ebx
	mov	DWORD PTR _index$1$[esp+136], eax
	mov	DWORD PTR _l$1$[esp+136], ebx
	cmp	DWORD PTR [esi+4], eax
	jle	$LN3@Interpolat
$LL4@Interpolat:

; 444  :   {
; 445  :     for (int k = 0; k < nBlkX; k++, index++)

	xor	ecx, ecx
	mov	DWORD PTR _k$1$[esp+136], ecx
	cmp	DWORD PTR [esi], ecx
	jle	$LN2@Interpolat
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	mov	DWORD PTR tv647[esp+136], eax
	npad	5
$LL7@Interpolat:

; 446  :     {
; 447  :       VECTOR v1, v2, v3, v4;
; 448  :       int i = k;
; 449  :       int j = l;
; 450  :       if (i >= 2 * pob.nBlkX)

	mov	eax, DWORD PTR _pob$[ebp]
	mov	edx, ecx
	mov	DWORD PTR _i$1$[esp+136], ecx
	mov	edi, DWORD PTR [eax]
	lea	eax, DWORD PTR [edi+edi]
	cmp	ecx, eax
	jl	SHORT $LN8@Interpolat

; 451  :       {
; 452  :         i = 2 * pob.nBlkX - 1;

	lea	edx, DWORD PTR [eax-1]
	mov	DWORD PTR _i$1$[esp+136], edx
$LN8@Interpolat:

; 453  :       }
; 454  :       if (j >= 2 * pob.nBlkY)

	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ecx
	mov	DWORD PTR tv699[esp+136], ecx
	cmp	DWORD PTR _l$1$[esp+136], ecx
	jl	SHORT $LN9@Interpolat

; 455  :       {
; 456  :         j = 2 * pob.nBlkY - 1;

	lea	ebx, DWORD PTR [ecx-1]
$LN9@Interpolat:

; 457  :       }
; 458  :       int offy = -1 + 2 * (j % 2);

	mov	eax, ebx
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN255@Interpolat
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN255@Interpolat:
	lea	eax, DWORD PTR [eax*2-1]
	mov	DWORD PTR _offy$1$[esp+136], eax

; 459  :       int offx = -1 + 2 * (i % 2);

	mov	eax, edx
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN256@Interpolat
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN256@Interpolat:
	lea	eax, DWORD PTR [eax*2-1]
	mov	DWORD PTR _offx$1$[esp+136], eax

; 460  :       int iper2 = i / 2;

	mov	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iper2$1$[esp+136], eax

; 461  :       int jper2 = j / 2;

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, eax

; 462  : 
; 463  :       if ((i == 0) || (i >= 2 * pob.nBlkX - 1))

	mov	eax, DWORD PTR _i$1$[esp+136]
	sar	edx, 1
	mov	DWORD PTR _jper2$1$[esp+136], edx
	test	eax, eax
	je	$LN12@Interpolat
	lea	ecx, DWORD PTR [edi*2-1]
	cmp	eax, ecx
	jge	$LN254@Interpolat

; 473  :         }
; 474  :       }
; 475  :       else if ((j == 0) || (j >= 2 * pob.nBlkY - 1))

	test	ebx, ebx
	je	$LN18@Interpolat
	mov	eax, DWORD PTR tv699[esp+136]
	dec	eax
	cmp	ebx, eax
	jge	$LN18@Interpolat
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _pob$[ebp]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 482  :         v1 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	mov	ecx, edi
	imul	ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, DWORD PTR [eax+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 482  :         v1 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	add	ecx, DWORD PTR _iper2$1$[esp+136]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [ecx+ecx*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 482  :         v1 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+eax*4+8]
	mov	DWORD PTR _v1$1$[esp+136], eax

; 483  :         v2 = pob.vectors[iper2 + offx + (jper2) * pob.nBlkX];

	mov	eax, DWORD PTR _offx$1$[esp+136]
	add	eax, ecx
	movq	QWORD PTR _v1$4[esp+136], xmm0

; 484  :         v3 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	mov	ecx, DWORD PTR _offy$1$[esp+136]
	add	ecx, DWORD PTR _jper2$1$[esp+136]
	imul	ecx, edi

; 485  :         v4 = pob.vectors[iper2 + offx + (jper2 + offy) * pob.nBlkX];

	mov	edi, DWORD PTR _v1$1$[esp+136]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 483  :         v2 = pob.vectors[iper2 + offx + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+eax*4+8]
	mov	DWORD PTR _v2$1$[esp+136], eax

; 484  :         v3 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	add	ecx, DWORD PTR _iper2$1$[esp+136]
	movq	QWORD PTR _v2$3[esp+136], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [ecx+ecx*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 484  :         v3 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR [edx+eax*4+8]

; 485  :         v4 = pob.vectors[iper2 + offx + (jper2 + offy) * pob.nBlkX];

	mov	eax, DWORD PTR _offx$1$[esp+136]
	add	eax, ecx
	movq	QWORD PTR _v3$1[esp+136], xmm0
	mov	DWORD PTR _v3$1$[esp+136], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 485  :         v4 = pob.vectors[iper2 + offx + (jper2 + offy) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	mov	edx, DWORD PTR _v2$1$[esp+136]
	movq	QWORD PTR _v4$2[esp+136], xmm0
	mov	DWORD PTR _v4$1$[esp+136], ecx
	jmp	$LN14@Interpolat
$LN18@Interpolat:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _pob$[ebp]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 477  :         v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	mov	ecx, DWORD PTR _iper2$1$[esp+136]
	imul	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, DWORD PTR [eax+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 477  :         v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	add	ecx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [ecx+ecx*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 477  :         v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	mov	ebx, DWORD PTR [edx+eax*4+8]
	mov	edi, ebx
	movq	xmm0, QWORD PTR [edx+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _offx$1$[esp+136]
	add	eax, ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 477  :         v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	QWORD PTR _v2$3[esp+136], xmm0
	movq	xmm0, xmm0
	mov	DWORD PTR _v2$1$[esp+136], ebx
	movq	QWORD PTR _v1$4[esp+136], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 478  :         v3 = v4 = pob.vectors[iper2 + offx + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [edx+eax*4+8]
	mov	ebx, ecx
	movq	QWORD PTR _v4$2[esp+136], xmm0

; 479  :       }
; 480  :       else

	mov	edx, edi
	movq	xmm0, xmm0
	mov	DWORD PTR _v4$1$[esp+136], ecx
	movq	QWORD PTR _v3$1[esp+136], xmm0
	mov	DWORD PTR _v3$1$[esp+136], ebx
	jmp	$LN257@Interpolat
$LN254@Interpolat:
	mov	ecx, DWORD PTR tv699[esp+136]
$LN12@Interpolat:

; 464  :       {
; 465  :         if ((j == 0) || (j >= 2 * pob.nBlkY - 1))

	test	ebx, ebx
	je	SHORT $LN15@Interpolat
	lea	eax, DWORD PTR [ecx-1]
	cmp	ebx, eax
	jge	SHORT $LN15@Interpolat
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, edi
	imul	eax, edx
	add	eax, DWORD PTR _iper2$1$[esp+136]
	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 471  :           v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [ecx+eax*4+8]
	mov	eax, ebx
	mov	DWORD PTR _v1$1$[esp+136], eax

; 472  :           v3 = v4 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	mov	eax, DWORD PTR _offy$1$[esp+136]
	add	eax, edx
	movq	QWORD PTR _v2$3[esp+136], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	imul	eax, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 471  :           v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	xmm0, xmm0

; 472  :           v3 = v4 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	mov	edi, DWORD PTR _v1$1$[esp+136]
	movq	QWORD PTR _v1$4[esp+136], xmm0
	mov	DWORD PTR _v2$1$[esp+136], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	add	eax, DWORD PTR _iper2$1$[esp+136]
	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 472  :           v3 = v4 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	movq	xmm0, QWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	mov	ebx, edx
	movq	QWORD PTR _v4$2[esp+136], xmm0
	movq	xmm0, xmm0
	mov	DWORD PTR _v4$1$[esp+136], edx
	mov	edx, DWORD PTR _v2$1$[esp+136]
	movq	QWORD PTR _v3$1[esp+136], xmm0
	mov	DWORD PTR _v3$1$[esp+136], ebx
	jmp	SHORT $LN14@Interpolat
$LN15@Interpolat:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _pob$[ebp]
	imul	edi, edx
	mov	eax, DWORD PTR [eax+108]
	add	edi, DWORD PTR _iper2$1$[esp+136]
	lea	ecx, DWORD PTR [edi+edi*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 467  :           v1 = v2 = v3 = v4 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [eax+ecx*4+8]
	mov	edi, edx
	movq	QWORD PTR _v4$2[esp+136], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR _v3$1[esp+136], xmm0
	movq	xmm0, QWORD PTR [eax+ecx*4]
	movq	QWORD PTR _v2$3[esp+136], xmm0
	movq	xmm0, xmm0
	mov	DWORD PTR _v4$1$[esp+136], edx
	mov	DWORD PTR _v3$1$[esp+136], edx
	mov	DWORD PTR _v2$1$[esp+136], edx
	movq	QWORD PTR _v1$4[esp+136], xmm0
$LN257@Interpolat:
	mov	DWORD PTR _v1$1$[esp+136], edi
$LN14@Interpolat:

; 486  :       }
; 487  :       typedef typename std::conditional < sizeof(pixel_t) == 1, sad_t, bigsad_t >::type cumulated_sad_t;
; 488  :       cumulated_sad_t tmp_sad; // 16 bit worst case: 16 * sad_max: 16 * 3x32x32x65536 = 4+5+5+16 > 2^31 over limit
; 489  :       // in case of BlockSize > 32, e.g. 128x128x65536 is even more: 7+7+16=30 bits
; 490  : 
; 491  :       if (nOverlapX == 0 && nOverlapY == 0)

	mov	ebx, DWORD PTR [esi+40]
	test	ebx, ebx
	jne	SHORT $LN19@Interpolat
	cmp	DWORD PTR [esi+44], ebx
	jne	SHORT $LN19@Interpolat

; 492  :       {
; 493  :         vectors[index].x = 9 * v1.x + 3 * v2.x + 3 * v3.x + v4.x;

	mov	ecx, DWORD PTR _v1$4[esp+136]
	mov	eax, DWORD PTR _v3$1[esp+136]
	mov	ebx, DWORD PTR tv647[esp+136]
	lea	edx, DWORD PTR [eax+ecx*2]
	mov	eax, DWORD PTR _v4$2[esp+136]
	add	edx, ecx
	add	edx, DWORD PTR _v2$3[esp+136]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	eax, DWORD PTR [esi+108]
	add	ecx, edx
	mov	DWORD PTR [ebx+eax], ecx

; 494  :         vectors[index].y = 9 * v1.y + 3 * v2.y + 3 * v3.y + v4.y;

	mov	ecx, DWORD PTR _v1$4[esp+140]
	mov	eax, DWORD PTR _v3$1[esp+140]
	lea	edx, DWORD PTR [eax+ecx*2]
	mov	eax, DWORD PTR _v4$2[esp+140]
	add	edx, ecx
	add	edx, DWORD PTR _v2$3[esp+140]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	eax, DWORD PTR [esi+108]
	add	ecx, edx
	mov	DWORD PTR [eax+ebx+4], ecx

; 495  :         tmp_sad = 9 * (cumulated_sad_t)v1.sad + 3 * (cumulated_sad_t)v2.sad + 3 * (cumulated_sad_t)v3.sad + (cumulated_sad_t)v4.sad + 8;

	mov	eax, DWORD PTR _v3$1$[esp+136]
	lea	ecx, DWORD PTR [eax+edi*2]
	add	ecx, edi
	mov	edi, DWORD PTR _v4$1$[esp+136]
	add	ecx, DWORD PTR _v2$1$[esp+136]
	add	edi, 8
	lea	edi, DWORD PTR [edi+ecx*2]
	add	edi, ecx
	jmp	$LN22@Interpolat
$LN19@Interpolat:

; 496  :         
; 497  :       }
; 498  :       else if (nOverlapX <= (nBlkSizeX >> 1) && nOverlapY <= (nBlkSizeY >> 1)) // corrected in v1.4.11

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _ax2$1$[esp+136], eax
	sar	eax, 1
	cmp	ebx, eax
	jg	$LN21@Interpolat
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, ecx
	sar	eax, 1
	cmp	DWORD PTR [esi+44], eax
	jg	$LN21@Interpolat

; 499  :       {
; 500  :         int	ax1 = (offx > 0) ? aoddx : aevenx;

	cmp	DWORD PTR _offx$1$[esp+136], 0

; 501  :         int ax2 = (nBlkSizeX - nOverlapX) * 4 - ax1;

	mov	edx, DWORD PTR _ax2$1$[esp+136]
	mov	eax, DWORD PTR _aevenx$1$[esp+136]
	cmovg	eax, DWORD PTR _aoddx$1$[esp+136]
	sub	edx, ebx
	shl	edx, 2
	sub	edx, eax

; 502  :         int ay1 = (offy > 0) ? aoddy : aeveny;

	cmp	DWORD PTR _offy$1$[esp+136], 0
	mov	DWORD PTR _ax2$1$[esp+136], edx
	mov	edx, DWORD PTR _aeveny$1$[esp+136]
	cmovg	edx, DWORD PTR _aoddy$1$[esp+136]

; 503  :         int ay2 = (nBlkSizeY - nOverlapY) * 4 - ay1;

	sub	ecx, DWORD PTR [esi+44]

; 504  :         int a11 = ax1*ay1, a12 = ax1*ay2, a21 = ax2*ay1, a22 = ax2*ay2;

	mov	ebx, edx
	shl	ecx, 2
	sub	ecx, edx
	imul	ebx, eax
	imul	edx, DWORD PTR _ax2$1$[esp+136]
	mov	edi, ecx
	imul	ecx, DWORD PTR _ax2$1$[esp+136]
	imul	edi, eax
	mov	DWORD PTR _a21$1$[esp+136], edx

; 505  :         vectors[index].x = (a11*v1.x + a21*v2.x + a12*v3.x + a22*v4.x) / normov;

	imul	edx, DWORD PTR _v2$3[esp+136]
	mov	eax, ecx
	imul	eax, DWORD PTR _v4$2[esp+136]
	mov	DWORD PTR _a22$1$[esp+136], ecx
	mov	ecx, edi
	imul	ecx, DWORD PTR _v3$1[esp+136]
	add	eax, ecx
	mov	ecx, ebx
	imul	ecx, DWORD PTR _v1$4[esp+136]
	add	eax, edx
	add	eax, ecx
	mov	ecx, DWORD PTR [esi+108]
	cdq
	idiv	DWORD PTR _normov$1$[esp+136]
	mov	edx, DWORD PTR tv647[esp+136]
	mov	DWORD PTR [edx+ecx], eax

; 506  :         vectors[index].y = (a11*v1.y + a21*v2.y + a12*v3.y + a22*v4.y) / normov;

	mov	ecx, edi
	imul	ecx, DWORD PTR _v3$1[esp+140]
	mov	eax, DWORD PTR _a22$1$[esp+136]
	imul	eax, DWORD PTR _v4$2[esp+140]

; 507  :         tmp_sad = ((cumulated_sad_t)a11*v1.sad + (cumulated_sad_t)a21*v2.sad + (cumulated_sad_t)a12*v3.sad + (cumulated_sad_t)a22*v4.sad) / normov;

	imul	edi, DWORD PTR _v3$1$[esp+136]
	add	eax, ecx
	mov	ecx, DWORD PTR _a21$1$[esp+136]
	imul	ecx, DWORD PTR _v2$3[esp+140]
	add	eax, ecx
	mov	ecx, ebx
	imul	ecx, DWORD PTR _v1$4[esp+140]
	add	eax, ecx
	mov	ecx, DWORD PTR [esi+108]
	cdq
	idiv	DWORD PTR _normov$1$[esp+136]
	mov	edx, DWORD PTR tv647[esp+136]
	mov	DWORD PTR [ecx+edx+4], eax
	mov	ecx, DWORD PTR _a22$1$[esp+136]
	imul	ecx, DWORD PTR _v4$1$[esp+136]
	mov	eax, DWORD PTR _a21$1$[esp+136]
	imul	eax, DWORD PTR _v2$1$[esp+136]
	add	ecx, edi
	add	ecx, eax
	mov	eax, DWORD PTR _v1$1$[esp+136]
	imul	eax, ebx

; 508  :       }
; 509  :       else // large overlap. Weights are not quite correct but let it be

	mov	ebx, DWORD PTR tv647[esp+136]
	add	eax, ecx
	cdq
	idiv	DWORD PTR _normov$1$[esp+136]
	mov	edi, eax
	jmp	SHORT $LN22@Interpolat
$LN21@Interpolat:

; 510  :       {
; 511  :         vectors[index].x = (v1.x + v2.x + v3.x + v4.x) << 2;

	mov	ecx, DWORD PTR _v3$1[esp+136]
	add	ecx, DWORD PTR _v4$2[esp+136]
	add	ecx, DWORD PTR _v2$3[esp+136]
	add	ecx, DWORD PTR _v1$4[esp+136]
	mov	eax, DWORD PTR [esi+108]
	mov	ebx, DWORD PTR tv647[esp+136]
	shl	ecx, 2
	mov	DWORD PTR [ebx+eax], ecx

; 512  :         vectors[index].y = (v1.y + v2.y + v3.y + v4.y) << 2;

	mov	ecx, DWORD PTR _v3$1[esp+140]
	add	ecx, DWORD PTR _v4$2[esp+140]
	add	ecx, DWORD PTR _v2$3[esp+140]
	mov	eax, DWORD PTR [esi+108]
	add	ecx, DWORD PTR _v1$4[esp+140]
	shl	ecx, 2
	mov	DWORD PTR [eax+ebx+4], ecx

; 513  :         tmp_sad = ((cumulated_sad_t)v1.sad + v2.sad + v3.sad + v4.sad + 2) << 2;

	mov	eax, DWORD PTR _v3$1$[esp+136]
	add	eax, DWORD PTR _v4$1$[esp+136]
	add	eax, edx
	add	eax, edi
	lea	edi, DWORD PTR [eax*4+8]
$LN22@Interpolat:

; 514  :       }
; 515  :       vectors[index].x = (vectors[index].x >> normFactor) << mulFactor;

	mov	edx, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR _normFactor$2$[esp+136]

; 516  :       vectors[index].y = (vectors[index].y >> normFactor) << mulFactor;
; 517  :       vectors[index].sad = (sad_t)(tmp_sad >> 4);

	sar	edi, 4
	mov	eax, DWORD PTR [edx+ebx]
	sar	eax, cl
	mov	ecx, DWORD PTR tv717[esp+136]
	shl	eax, cl
	mov	ecx, DWORD PTR _normFactor$2$[esp+136]
	mov	DWORD PTR [edx+ebx], eax
	mov	edx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [edx+ebx+4]
	sar	eax, cl
	mov	ecx, DWORD PTR tv717[esp+136]
	shl	eax, cl
	mov	ecx, DWORD PTR _k$1$[esp+136]
	mov	DWORD PTR [edx+ebx+4], eax
	inc	ecx
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR _k$1$[esp+136], ecx
	mov	DWORD PTR [eax+ebx+8], edi
	add	ebx, 12					; 0000000cH
	mov	eax, DWORD PTR _index$1$[esp+136]
	inc	eax
	mov	DWORD PTR tv647[esp+136], ebx
	mov	ebx, DWORD PTR _l$1$[esp+136]
	mov	DWORD PTR _index$1$[esp+136], eax
	cmp	ecx, DWORD PTR [esi]
	jl	$LL7@Interpolat
$LN2@Interpolat:

; 441  :   // note: overlapping is still (v2.5.7) not processed properly
; 442  :   // PF todo make faster
; 443  :   for (int l = 0, index = 0; l < nBlkY; l++)

	inc	ebx
	mov	DWORD PTR _l$1$[esp+136], ebx
	cmp	ebx, DWORD PTR [esi+4]
	jl	$LL4@Interpolat
$LN3@Interpolat:

; 518  :     }	// for k < nBlkX
; 519  :   }	// for l < nBlkY
; 520  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$InterpolatePrediction@E@PlaneOfBlocks@@QAEXABV0@@Z ENDP ; PlaneOfBlocks::InterpolatePrediction<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??$InterpolatePrediction@G@PlaneOfBlocks@@QAEXABV0@@Z
_TEXT	SEGMENT
tv244 = -124						; size = 4
_v3$1$ = -120						; size = 4
_jper2$1$ = -120					; size = 4
_v2$1$ = -116						; size = 4
tv437 = -116						; size = 4
_v1$1$ = -112						; size = 4
_i$1$ = -112						; size = 4
_v4$1$ = -108						; size = 4
_iper2$1$ = -108					; size = 4
_normov$1$ = -104					; size = 4
_this$1$ = -100						; size = 4
_ax2$1$ = -96						; size = 4
_offx$1$ = -96						; size = 4
_l$1$ = -92						; size = 4
_a22$1$ = -88						; size = 4
_offy$1$ = -88						; size = 4
_k$1$ = -84						; size = 4
_normFactor$2$ = -80					; size = 4
tv454 = -76						; size = 4
_index$1$ = -72						; size = 4
_aevenx$1$ = -68					; size = 4
_aoddx$1$ = -64						; size = 4
_aeveny$1$ = -60					; size = 4
_aoddy$1$ = -56						; size = 4
_a21$1$ = -52						; size = 4
tv407 = -52						; size = 4
_v3$1 = -48						; size = 12
_v4$2 = -36						; size = 12
_v2$3 = -24						; size = 12
_v1$4 = -12						; size = 12
_pob$ = 8						; size = 4
??$InterpolatePrediction@G@PlaneOfBlocks@@QAEXABV0@@Z PROC ; PlaneOfBlocks::InterpolatePrediction<unsigned short>, COMDAT
; _this$ = ecx

; 432  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 124				; 0000007cH

; 433  :   int normFactor = 3 - nLogPel + pob.nLogPel;

	mov	eax, DWORD PTR _pob$[ebp]
	xor	edx, edx
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _this$1$[esp+132], ebx
	sub	eax, DWORD PTR [ebx+24]

; 434  :   int mulFactor = (normFactor < 0) ? -normFactor : 0;
; 435  :   normFactor = (normFactor < 0) ? 0 : normFactor;
; 436  :   int normov = (nBlkSizeX - nOverlapX)*(nBlkSizeY - nOverlapY);

	mov	esi, DWORD PTR [ebx+12]
	add	eax, 3
	mov	ecx, eax
	neg	ecx
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR [ebx+44]
	cmovns	ecx, edx
	mov	edx, DWORD PTR [ebx+40]
	mov	DWORD PTR tv454[esp+136], ecx
	xor	ecx, ecx
	test	eax, eax
	cmovs	eax, ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR _normFactor$2$[esp+136], eax
	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR _normov$1$[esp+136], eax
	mov	eax, esi
	mov	ebx, DWORD PTR _normov$1$[esp+136]

; 437  :   int aoddx = (nBlkSizeX * 3 - nOverlapX * 2);

	lea	ecx, DWORD PTR [ecx+ecx*2]
	sub	eax, edi
	imul	ebx, eax
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR _normov$1$[esp+136], ebx
	mov	ebx, ecx
	sub	ebx, eax

; 438  :   int aevenx = (nBlkSizeX * 3 - nOverlapX * 4);

	lea	eax, DWORD PTR [edx*4]
	sub	ecx, eax
	mov	DWORD PTR _aoddx$1$[esp+136], ebx

; 439  :   int aoddy = (nBlkSizeY * 3 - nOverlapY * 2);
; 440  :   int aeveny = (nBlkSizeY * 3 - nOverlapY * 4);
; 441  :   // note: overlapping is still (v2.5.7) not processed properly
; 442  :   // PF todo make faster
; 443  :   for (int l = 0, index = 0; l < nBlkY; l++)

	mov	ebx, DWORD PTR _this$1$[esp+136]
	lea	eax, DWORD PTR [edi+edi]
	mov	DWORD PTR _aevenx$1$[esp+136], ecx
	lea	ecx, DWORD PTR [esi+esi*2]
	mov	edx, ecx
	sub	edx, eax
	lea	eax, DWORD PTR [edi*4]
	sub	ecx, eax
	mov	DWORD PTR _aoddy$1$[esp+136], edx
	xor	eax, eax
	mov	DWORD PTR _aeveny$1$[esp+136], ecx
	xor	ecx, ecx
	mov	DWORD PTR _index$1$[esp+136], eax
	mov	DWORD PTR _l$1$[esp+136], ecx
	cmp	DWORD PTR [ebx+4], eax
	jle	$LN3@Interpolat
	npad	6
$LL4@Interpolat:

; 444  :   {
; 445  :     for (int k = 0; k < nBlkX; k++, index++)

	xor	edx, edx
	mov	DWORD PTR _k$1$[esp+136], edx
	cmp	DWORD PTR [ebx], edx
	jle	$LN2@Interpolat
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	mov	DWORD PTR tv244[esp+136], eax
	npad	8
$LL7@Interpolat:

; 446  :     {
; 447  :       VECTOR v1, v2, v3, v4;
; 448  :       int i = k;
; 449  :       int j = l;

	mov	edi, ecx
	mov	DWORD PTR _i$1$[esp+136], edx

; 450  :       if (i >= 2 * pob.nBlkX)

	mov	ecx, DWORD PTR _pob$[ebp]
	mov	esi, DWORD PTR [ecx]
	lea	eax, DWORD PTR [esi+esi]
	cmp	DWORD PTR _k$1$[esp+136], eax
	jl	SHORT $LN8@Interpolat

; 451  :       {
; 452  :         i = 2 * pob.nBlkX - 1;

	lea	edx, DWORD PTR [eax-1]
	mov	DWORD PTR _i$1$[esp+136], edx
$LN8@Interpolat:

; 453  :       }
; 454  :       if (j >= 2 * pob.nBlkY)

	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, ecx
	mov	DWORD PTR tv437[esp+136], ecx
	cmp	DWORD PTR _l$1$[esp+136], ecx
	jl	SHORT $LN9@Interpolat

; 455  :       {
; 456  :         j = 2 * pob.nBlkY - 1;

	lea	edi, DWORD PTR [ecx-1]
$LN9@Interpolat:

; 457  :       }
; 458  :       int offy = -1 + 2 * (j % 2);

	mov	eax, edi
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN255@Interpolat
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN255@Interpolat:
	lea	eax, DWORD PTR [eax*2-1]
	mov	DWORD PTR _offy$1$[esp+136], eax

; 459  :       int offx = -1 + 2 * (i % 2);

	mov	eax, edx
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN256@Interpolat
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN256@Interpolat:
	lea	eax, DWORD PTR [eax*2-1]
	mov	DWORD PTR _offx$1$[esp+136], eax

; 460  :       int iper2 = i / 2;

	mov	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iper2$1$[esp+136], eax

; 461  :       int jper2 = j / 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edx, eax

; 462  : 
; 463  :       if ((i == 0) || (i >= 2 * pob.nBlkX - 1))

	mov	eax, DWORD PTR _i$1$[esp+136]
	sar	edx, 1
	mov	DWORD PTR _jper2$1$[esp+136], edx
	test	eax, eax
	je	$LN12@Interpolat
	lea	ecx, DWORD PTR [esi*2-1]
	cmp	eax, ecx
	jge	$LN254@Interpolat

; 473  :         }
; 474  :       }
; 475  :       else if ((j == 0) || (j >= 2 * pob.nBlkY - 1))

	test	edi, edi
	je	$LN18@Interpolat
	mov	eax, DWORD PTR tv437[esp+136]
	dec	eax
	cmp	edi, eax
	jge	$LN18@Interpolat
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _pob$[ebp]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 482  :         v1 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	mov	ecx, esi
	imul	ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, DWORD PTR [eax+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 482  :         v1 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	add	ecx, DWORD PTR _iper2$1$[esp+136]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [ecx+ecx*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 482  :         v1 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+eax*4+8]
	mov	DWORD PTR _v1$1$[esp+136], eax

; 483  :         v2 = pob.vectors[iper2 + offx + (jper2) * pob.nBlkX];

	mov	eax, DWORD PTR _offx$1$[esp+136]
	add	eax, ecx
	movq	QWORD PTR _v1$4[esp+136], xmm0

; 484  :         v3 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	mov	ecx, DWORD PTR _offy$1$[esp+136]
	add	ecx, DWORD PTR _jper2$1$[esp+136]
	imul	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 483  :         v2 = pob.vectors[iper2 + offx + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edx+eax*4+8]
	mov	DWORD PTR _v2$1$[esp+136], eax

; 484  :         v3 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	add	ecx, DWORD PTR _iper2$1$[esp+136]
	movq	QWORD PTR _v2$3[esp+136], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [ecx+ecx*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 484  :         v3 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [edx+eax*4+8]

; 485  :         v4 = pob.vectors[iper2 + offx + (jper2 + offy) * pob.nBlkX];

	mov	eax, DWORD PTR _offx$1$[esp+136]
	add	eax, ecx
	movq	QWORD PTR _v3$1[esp+136], xmm0
	mov	DWORD PTR _v3$1$[esp+136], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 485  :         v4 = pob.vectors[iper2 + offx + (jper2 + offy) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [edx+eax*4+8]
	movq	QWORD PTR _v4$2[esp+136], xmm0
	jmp	$LN257@Interpolat
$LN18@Interpolat:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _pob$[ebp]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 477  :         v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	mov	ecx, DWORD PTR _iper2$1$[esp+136]
	imul	esi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, DWORD PTR [eax+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 477  :         v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [ecx+ecx*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 477  :         v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	mov	edi, DWORD PTR [edx+eax*4+8]
	mov	esi, edi
	movq	xmm0, QWORD PTR [edx+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _offx$1$[esp+136]
	add	eax, ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 477  :         v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	QWORD PTR _v2$3[esp+136], xmm0
	movq	xmm0, xmm0
	mov	DWORD PTR _v2$1$[esp+136], edi
	movq	QWORD PTR _v1$4[esp+136], xmm0
	mov	DWORD PTR _v1$1$[esp+136], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 478  :         v3 = v4 = pob.vectors[iper2 + offx + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [edx+eax*4+8]
	mov	esi, edi
	movq	QWORD PTR _v4$2[esp+136], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR _v3$1[esp+136], xmm0
	mov	DWORD PTR _v3$1$[esp+136], esi

; 479  :       }
; 480  :       else

	jmp	$LN257@Interpolat
$LN254@Interpolat:
	mov	ecx, DWORD PTR tv437[esp+136]
$LN12@Interpolat:

; 464  :       {
; 465  :         if ((j == 0) || (j >= 2 * pob.nBlkY - 1))

	test	edi, edi
	je	SHORT $LN15@Interpolat
	lea	eax, DWORD PTR [ecx-1]
	cmp	edi, eax
	jge	SHORT $LN15@Interpolat
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _pob$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, esi
	imul	eax, edx
	add	eax, DWORD PTR _iper2$1$[esp+136]
	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 471  :           v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [ecx+eax*4+8]
	mov	eax, ebx
	mov	DWORD PTR _v1$1$[esp+136], eax

; 472  :           v3 = v4 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	mov	eax, DWORD PTR _offy$1$[esp+136]
	add	eax, edx
	movq	QWORD PTR _v2$3[esp+136], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	imul	eax, esi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 471  :           v1 = v2 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	xmm0, xmm0
	movq	QWORD PTR _v1$4[esp+136], xmm0
	mov	DWORD PTR _v2$1$[esp+136], ebx

; 472  :           v3 = v4 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	mov	ebx, DWORD PTR _this$1$[esp+136]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	add	eax, DWORD PTR _iper2$1$[esp+136]
	lea	eax, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 472  :           v3 = v4 = pob.vectors[iper2 + (jper2 + offy) * pob.nBlkX];

	movq	xmm0, QWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR [ecx+eax*4+8]
	mov	esi, edi
	movq	QWORD PTR _v4$2[esp+136], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR _v3$1[esp+136], xmm0
	mov	DWORD PTR _v3$1$[esp+136], esi
	jmp	SHORT $LN257@Interpolat
$LN15@Interpolat:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _pob$[ebp]
	imul	esi, edx
	mov	eax, DWORD PTR [eax+108]
	add	esi, DWORD PTR _iper2$1$[esp+136]
	lea	ecx, DWORD PTR [esi+esi*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 467  :           v1 = v2 = v3 = v4 = pob.vectors[iper2 + (jper2) * pob.nBlkX];

	movq	xmm0, QWORD PTR [eax+ecx*4]
	mov	edi, DWORD PTR [eax+ecx*4+8]
	mov	edx, edi
	movq	QWORD PTR _v4$2[esp+136], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR _v3$1[esp+136], xmm0
	movq	xmm0, QWORD PTR [eax+ecx*4]
	mov	eax, edi
	movq	QWORD PTR _v2$3[esp+136], xmm0
	movq	xmm0, xmm0
	mov	DWORD PTR _v3$1$[esp+136], edx
	mov	DWORD PTR _v2$1$[esp+136], edx
	movq	QWORD PTR _v1$4[esp+136], xmm0
	mov	DWORD PTR _v1$1$[esp+136], eax
$LN257@Interpolat:

; 486  :       }
; 487  :       typedef typename std::conditional < sizeof(pixel_t) == 1, sad_t, bigsad_t >::type cumulated_sad_t;
; 488  :       cumulated_sad_t tmp_sad; // 16 bit worst case: 16 * sad_max: 16 * 3x32x32x65536 = 4+5+5+16 > 2^31 over limit
; 489  :       // in case of BlockSize > 32, e.g. 128x128x65536 is even more: 7+7+16=30 bits
; 490  : 
; 491  :       if (nOverlapX == 0 && nOverlapY == 0)

	mov	ecx, DWORD PTR [ebx+40]
	mov	DWORD PTR _v4$1$[esp+136], edi
	test	ecx, ecx
	jne	SHORT $LN19@Interpolat
	cmp	DWORD PTR [ebx+44], ecx
	jne	SHORT $LN19@Interpolat

; 492  :       {
; 493  :         vectors[index].x = 9 * v1.x + 3 * v2.x + 3 * v3.x + v4.x;

	mov	ecx, DWORD PTR _v1$4[esp+136]
	mov	eax, DWORD PTR _v3$1[esp+136]
	mov	edi, DWORD PTR tv244[esp+136]
	lea	edx, DWORD PTR [eax+ecx*2]
	mov	eax, DWORD PTR _v4$2[esp+136]
	add	edx, ecx
	add	edx, DWORD PTR _v2$3[esp+136]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	eax, DWORD PTR [ebx+108]
	add	ecx, edx

; 494  :         vectors[index].y = 9 * v1.y + 3 * v2.y + 3 * v3.y + v4.y;

	mov	edx, DWORD PTR _v1$4[esp+140]
	mov	DWORD PTR [edi+eax], ecx
	mov	ecx, DWORD PTR _v3$1[esp+140]

; 495  :         tmp_sad = 9 * (cumulated_sad_t)v1.sad + 3 * (cumulated_sad_t)v2.sad + 3 * (cumulated_sad_t)v3.sad + (cumulated_sad_t)v4.sad + 8;

	mov	eax, DWORD PTR _v3$1$[esp+136]
	lea	esi, DWORD PTR [ecx+edx*2]
	mov	ecx, DWORD PTR _v4$2[esp+140]
	add	esi, edx
	add	esi, DWORD PTR _v2$3[esp+140]
	lea	edx, DWORD PTR [ecx+esi*2]
	mov	ecx, DWORD PTR [ebx+108]
	add	edx, esi
	mov	DWORD PTR [ecx+edi+4], edx
	mov	ecx, 3
	imul	ecx
	mov	edi, eax
	mov	esi, edx
	mov	eax, DWORD PTR _v2$1$[esp+136]
	imul	ecx
	mov	ecx, 9
	add	edi, eax
	mov	eax, DWORD PTR _v1$1$[esp+136]
	adc	esi, edx
	imul	ecx
	add	edi, eax
	mov	eax, DWORD PTR _v4$1$[esp+136]
	adc	esi, edx
	cdq
	jmp	$LN258@Interpolat
$LN19@Interpolat:

; 496  :         
; 497  :       }
; 498  :       else if (nOverlapX <= (nBlkSizeX >> 1) && nOverlapY <= (nBlkSizeY >> 1)) // corrected in v1.4.11

	mov	esi, DWORD PTR [ebx+8]
	mov	eax, esi
	sar	eax, 1
	cmp	ecx, eax
	jg	$LN21@Interpolat
	mov	eax, DWORD PTR [ebx+44]
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR tv407[esp+136], eax
	mov	eax, edx
	sar	eax, 1
	cmp	DWORD PTR [ebx+44], eax
	jg	$LN21@Interpolat

; 499  :       {
; 500  :         int	ax1 = (offx > 0) ? aoddx : aevenx;

	cmp	DWORD PTR _offx$1$[esp+136], 0
	mov	eax, DWORD PTR _aevenx$1$[esp+136]
	cmovg	eax, DWORD PTR _aoddx$1$[esp+136]

; 501  :         int ax2 = (nBlkSizeX - nOverlapX) * 4 - ax1;

	sub	esi, ecx
	shl	esi, 2
	sub	esi, eax

; 502  :         int ay1 = (offy > 0) ? aoddy : aeveny;

	cmp	DWORD PTR _offy$1$[esp+136], 0
	mov	DWORD PTR _ax2$1$[esp+136], esi
	mov	esi, DWORD PTR _aeveny$1$[esp+136]
	cmovg	esi, DWORD PTR _aoddy$1$[esp+136]

; 503  :         int ay2 = (nBlkSizeY - nOverlapY) * 4 - ay1;

	sub	edx, DWORD PTR tv407[esp+136]

; 504  :         int a11 = ax1*ay1, a12 = ax1*ay2, a21 = ax2*ay1, a22 = ax2*ay2;

	mov	ebx, esi
	imul	ebx, eax
	shl	edx, 2
	sub	edx, esi
	imul	esi, DWORD PTR _ax2$1$[esp+136]
	mov	edi, edx
	imul	edx, DWORD PTR _ax2$1$[esp+136]
	imul	edi, eax
	mov	DWORD PTR _a21$1$[esp+136], esi

; 505  :         vectors[index].x = (a11*v1.x + a21*v2.x + a12*v3.x + a22*v4.x) / normov;

	mov	eax, edx
	mov	DWORD PTR _a22$1$[esp+136], edx
	imul	eax, DWORD PTR _v4$2[esp+136]
	mov	ecx, edi
	imul	ecx, DWORD PTR _v3$1[esp+136]
	add	eax, ecx
	mov	ecx, esi
	imul	ecx, DWORD PTR _v2$3[esp+136]

; 506  :         vectors[index].y = (a11*v1.y + a21*v2.y + a12*v3.y + a22*v4.y) / normov;

	imul	esi, DWORD PTR _v2$3[esp+140]
	add	eax, ecx
	mov	ecx, ebx
	imul	ecx, DWORD PTR _v1$4[esp+136]
	add	eax, ecx
	mov	ecx, DWORD PTR _this$1$[esp+136]
	cdq
	idiv	DWORD PTR _normov$1$[esp+136]
	mov	ecx, DWORD PTR [ecx+108]
	mov	edx, DWORD PTR tv244[esp+136]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, edi
	imul	ecx, DWORD PTR _v3$1[esp+140]
	mov	eax, DWORD PTR _a22$1$[esp+136]
	imul	eax, DWORD PTR _v4$2[esp+140]
	add	eax, ecx
	mov	ecx, ebx
	imul	ecx, DWORD PTR _v1$4[esp+140]
	add	eax, esi
	add	eax, ecx
	mov	ecx, DWORD PTR _this$1$[esp+136]
	cdq
	idiv	DWORD PTR _normov$1$[esp+136]
	mov	ecx, DWORD PTR [ecx+108]
	mov	edx, DWORD PTR tv244[esp+136]
	mov	DWORD PTR [ecx+edx+4], eax

; 507  :         tmp_sad = ((cumulated_sad_t)a11*v1.sad + (cumulated_sad_t)a21*v2.sad + (cumulated_sad_t)a12*v3.sad + (cumulated_sad_t)a22*v4.sad) / normov;

	mov	eax, DWORD PTR _a22$1$[esp+136]
	imul	DWORD PTR _v4$1$[esp+136]
	mov	esi, eax
	mov	ecx, edx
	mov	eax, edi
	imul	DWORD PTR _v3$1$[esp+136]
	add	esi, eax
	mov	eax, DWORD PTR _a21$1$[esp+136]
	adc	ecx, edx
	imul	DWORD PTR _v2$1$[esp+136]
	add	esi, eax
	mov	eax, ebx
	adc	ecx, edx
	imul	DWORD PTR _v1$1$[esp+136]
	add	esi, eax
	mov	eax, DWORD PTR _normov$1$[esp+136]
	adc	ecx, edx
	cdq
	push	edx
	push	eax
	push	ecx
	push	esi
	call	__alldiv

; 508  :       }
; 509  :       else // large overlap. Weights are not quite correct but let it be

	mov	ebx, DWORD PTR _this$1$[esp+136]
	mov	edi, eax
	mov	esi, edx
	jmp	SHORT $LN22@Interpolat
$LN21@Interpolat:

; 510  :       {
; 511  :         vectors[index].x = (v1.x + v2.x + v3.x + v4.x) << 2;

	mov	ecx, DWORD PTR _v3$1[esp+136]
	add	ecx, DWORD PTR _v4$2[esp+136]
	add	ecx, DWORD PTR _v2$3[esp+136]
	add	ecx, DWORD PTR _v1$4[esp+136]
	mov	eax, DWORD PTR [ebx+108]
	mov	edx, DWORD PTR tv244[esp+136]
	shl	ecx, 2
	mov	DWORD PTR [edx+eax], ecx

; 512  :         vectors[index].y = (v1.y + v2.y + v3.y + v4.y) << 2;

	mov	ecx, DWORD PTR _v3$1[esp+140]
	add	ecx, DWORD PTR _v4$2[esp+140]
	add	ecx, DWORD PTR _v2$3[esp+140]
	add	ecx, DWORD PTR _v1$4[esp+140]
	mov	eax, DWORD PTR [ebx+108]
	shl	ecx, 2
	mov	DWORD PTR [eax+edx+4], ecx

; 513  :         tmp_sad = ((cumulated_sad_t)v1.sad + v2.sad + v3.sad + v4.sad + 2) << 2;

	mov	eax, edi
	mov	ecx, 4
	imul	ecx
	mov	edi, eax
	mov	esi, edx
	mov	eax, DWORD PTR _v3$1$[esp+136]
	imul	ecx
	add	edi, eax
	mov	eax, DWORD PTR _v2$1$[esp+136]
	adc	esi, edx
	imul	ecx
	add	edi, eax
	mov	eax, DWORD PTR _v1$1$[esp+136]
	adc	esi, edx
	imul	ecx
$LN258@Interpolat:
	add	edi, eax
	adc	esi, edx
	add	edi, 8
	adc	esi, 0
$LN22@Interpolat:

; 514  :       }
; 515  :       vectors[index].x = (vectors[index].x >> normFactor) << mulFactor;

	mov	edx, DWORD PTR [ebx+108]
	add	edx, DWORD PTR tv244[esp+136]
	mov	ecx, DWORD PTR _normFactor$2$[esp+136]

; 516  :       vectors[index].y = (vectors[index].y >> normFactor) << mulFactor;
; 517  :       vectors[index].sad = (sad_t)(tmp_sad >> 4);

	shrd	edi, esi, 4
	mov	eax, DWORD PTR [edx]
	sar	eax, cl
	mov	ecx, DWORD PTR tv454[esp+136]
	shl	eax, cl
	mov	ecx, DWORD PTR _normFactor$2$[esp+136]
	mov	DWORD PTR [edx], eax
	mov	edx, DWORD PTR [ebx+108]
	add	edx, DWORD PTR tv244[esp+136]
	sar	esi, 4
	mov	eax, DWORD PTR [edx+4]
	sar	eax, cl
	mov	ecx, DWORD PTR tv454[esp+136]
	shl	eax, cl
	mov	ecx, DWORD PTR tv244[esp+136]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ebx+108]
	mov	edx, DWORD PTR _k$1$[esp+136]
	inc	edx
	mov	DWORD PTR _k$1$[esp+136], edx
	mov	DWORD PTR [eax+ecx+8], edi
	add	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR _index$1$[esp+136]
	inc	eax
	mov	DWORD PTR tv244[esp+136], ecx
	mov	ecx, DWORD PTR _l$1$[esp+136]
	mov	DWORD PTR _index$1$[esp+136], eax
	cmp	edx, DWORD PTR [ebx]
	jl	$LL7@Interpolat
$LN2@Interpolat:

; 439  :   int aoddy = (nBlkSizeY * 3 - nOverlapY * 2);
; 440  :   int aeveny = (nBlkSizeY * 3 - nOverlapY * 4);
; 441  :   // note: overlapping is still (v2.5.7) not processed properly
; 442  :   // PF todo make faster
; 443  :   for (int l = 0, index = 0; l < nBlkY; l++)

	inc	ecx
	mov	DWORD PTR _l$1$[esp+136], ecx
	cmp	ecx, DWORD PTR [ebx+4]
	jl	$LL4@Interpolat
$LN3@Interpolat:

; 518  :     }	// for k < nBlkX
; 519  :   }	// for l < nBlkY
; 520  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$InterpolatePrediction@G@PlaneOfBlocks@@QAEXABV0@@Z ENDP ; PlaneOfBlocks::InterpolatePrediction<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?WriteDefaultToArray@PlaneOfBlocks@@QAEHPAHH@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
_divideMode$ = 12					; size = 4
?WriteDefaultToArray@PlaneOfBlocks@@QAEHPAHH@Z PROC	; PlaneOfBlocks::WriteDefaultToArray, COMDAT
; _this$ = ecx

; 536  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	mov	eax, DWORD PTR [ecx+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR _array$[esp+4]

; 537  :   //	int verybigSAD = nBlkSizeX*nBlkSizeY*256*  bits_per_pixel_factor;
; 538  :   for (int i = 0; i < nBlkCount*N_PER_BLOCK; i += N_PER_BLOCK)

	xor	esi, esi
	lea	eax, DWORD PTR [eax+eax*2]
	inc	eax
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+eax*2]
	test	eax, eax
	jle	SHORT $LN3@WriteDefau

; 536  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	lea	edx, DWORD PTR [edi+8]
	npad	2
$LL4@WriteDefau:

; 539  :   {
; 540  :     array[i + 1] = 0;

	mov	DWORD PTR [edx-4], 0
	lea	edx, DWORD PTR [edx+12]

; 541  :     array[i + 2] = 0;

	mov	DWORD PTR [edx-12], 0
	add	esi, 3

; 542  :     array[i + 3] = verybigSAD; // float or int!!

	mov	eax, DWORD PTR [ecx+156]
	mov	DWORD PTR [edx-8], eax
	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+eax*2]
	cmp	esi, eax
	jl	SHORT $LL4@WriteDefau
$LN3@WriteDefau:

; 543  :     //*(sad_t *)(&array[i + 3]) = verybigSAD; // float or int!!
; 544  :   }
; 545  : 
; 546  :   if (nLogScale == 0)

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN6@WriteDefau

; 547  :   {
; 548  :     array += array[0];
; 549  :     if (divideMode)

	cmp	DWORD PTR _divideMode$[esp+4], 0
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [edi+eax*4]
	je	SHORT $LN6@WriteDefau

; 550  :     {
; 551  :       // reserve space for divided subblocks extra level
; 552  :       array[0] = nBlkCount * N_PER_BLOCK * 4 + 1; // 4 subblocks

	mov	eax, DWORD PTR [ecx+16]

; 553  :       for (int i = 0; i < nBlkCount * 4 * N_PER_BLOCK; i += N_PER_BLOCK)

	xor	esi, esi
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax*4+1]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	test	eax, eax
	jle	SHORT $LN6@WriteDefau

; 550  :     {
; 551  :       // reserve space for divided subblocks extra level
; 552  :       array[0] = nBlkCount * N_PER_BLOCK * 4 + 1; // 4 subblocks

	add	edx, 8
	npad	6
$LL7@WriteDefau:

; 554  :       {
; 555  :         array[i + 1] = 0;

	mov	DWORD PTR [edx-4], 0
	lea	edx, DWORD PTR [edx+12]

; 556  :         array[i + 2] = 0;

	mov	DWORD PTR [edx-12], 0
	add	esi, 3

; 557  :         array[i + 3] = verybigSAD; // float or int!!

	mov	eax, DWORD PTR [ecx+156]
	mov	DWORD PTR [edx-8], eax
	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	cmp	esi, eax
	jl	SHORT $LL7@WriteDefau
$LN6@WriteDefau:

; 572  :   size += nBlkCount * N_PER_BLOCK;  // vectors, sad, luma src, luma ref, var

	mov	eax, DWORD PTR [ecx+16]
	pop	edi
	pop	esi
	lea	edx, DWORD PTR [eax*2+1]
	add	edx, eax

; 573  : 
; 574  :   if (nLogScale == 0)

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN24@WriteDefau

; 575  :   {
; 576  :     if (divideMode)

	cmp	DWORD PTR _divideMode$[esp-4], 0
	je	SHORT $LN24@WriteDefau

; 577  :     {
; 578  :       size += 1 + nBlkCount * N_PER_BLOCK * 4; // reserve space for divided subblocks extra level

	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax*4+1]
	add	eax, edx

; 564  : }

	ret	8
$LN24@WriteDefau:

; 558  :         //*(sad_t *)(&array[i + 3]) = verybigSAD; // float or int
; 559  :       }
; 560  :       array += array[0];
; 561  :     }
; 562  :   }
; 563  :   return GetArraySize(divideMode);

	mov	eax, edx

; 564  : }

	ret	8
?WriteDefaultToArray@PlaneOfBlocks@@QAEHPAHH@Z ENDP	; PlaneOfBlocks::WriteDefaultToArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?GetArraySize@PlaneOfBlocks@@QAEHH@Z
_TEXT	SEGMENT
_divideMode$ = 8					; size = 4
?GetArraySize@PlaneOfBlocks@@QAEHH@Z PROC		; PlaneOfBlocks::GetArraySize, COMDAT
; _this$ = ecx

; 570  :   int size = 0;
; 571  :   size += 1;              // mb data size storage
; 572  :   size += nBlkCount * N_PER_BLOCK;  // vectors, sad, luma src, luma ref, var

	mov	eax, DWORD PTR [ecx+16]
	lea	edx, DWORD PTR [eax*2+1]
	add	edx, eax

; 573  : 
; 574  :   if (nLogScale == 0)

	cmp	DWORD PTR [ecx+32], 0
	jne	SHORT $LN6@GetArraySi

; 575  :   {
; 576  :     if (divideMode)

	cmp	DWORD PTR _divideMode$[esp-4], 0
	je	SHORT $LN6@GetArraySi

; 577  :     {
; 578  :       size += 1 + nBlkCount * N_PER_BLOCK * 4; // reserve space for divided subblocks extra level

	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax*4+1]
	add	eax, edx

; 583  : }

	ret	4
$LN6@GetArraySi:

; 579  :     }
; 580  :   }
; 581  : 
; 582  :   return size;

	mov	eax, edx

; 583  : }

	ret	4
?GetArraySize@PlaneOfBlocks@@QAEHH@Z ENDP		; PlaneOfBlocks::GetArraySize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?EstimateGlobalMVDoubled@PlaneOfBlocks@@QAEXPAUVECTOR@@AAV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_globalMVec$ = 8					; size = 4
_slicer$ = 12						; size = 4
?EstimateGlobalMVDoubled@PlaneOfBlocks@@QAEXPAUVECTOR@@AAV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z PROC ; PlaneOfBlocks::EstimateGlobalMVDoubled, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	mov	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1368 :   _gvect_result_count = 2;

	lea	eax, DWORD PTR [ecx+764]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xchg	DWORD PTR [eax], edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1369 :   _gvect_estim_ptr = globalMVec;

	mov	eax, DWORD PTR _globalMVec$[esp-4]

; 1370 : 
; 1371 :   slicer.start(2, *this, &PlaneOfBlocks::estimate_global_mv_doubled_slice);

	push	1
	push	OFFSET ?estimate_global_mv_doubled_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::estimate_global_mv_doubled_slice
	push	ecx
	mov	DWORD PTR [ecx+760], eax
	mov	ecx, DWORD PTR _slicer$[esp+8]
	push	2
	call	?start@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXHAAVPlaneOfBlocks@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::start

; 1372 : }

	ret	8
?EstimateGlobalMVDoubled@PlaneOfBlocks@@QAEXPAUVECTOR@@AAV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ENDP ; PlaneOfBlocks::EstimateGlobalMVDoubled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z
_TEXT	SEGMENT
_slicer$ = -1056					; size = 1044
__$EHRec$ = -12						; size = 12
_mvClip$ = 8						; size = 4
__pSrcFrame$ = 12					; size = 4
__pRefFrame$ = 16					; size = 4
_st$ = 20						; size = 4
_stp$ = 24						; size = 4
_lambda$ = 28						; size = 4
_lsad$ = 32						; size = 4
_pnew$ = 36						; size = 4
_flags$ = 40						; size = 4
_out$ = 44						; size = 4
_outfilebuf$ = 48					; size = 4
_fieldShift$ = 52					; size = 4
_thSAD$ = 56						; size = 4
_divideExtra$dead$ = 60					; size = 4
_smooth$ = 64						; size = 4
_meander$ = 68						; size = 1
?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z PROC ; PlaneOfBlocks::RecalculateMVs, COMDAT
; _this$ = ecx

; 335  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z
	push	eax

; 340  :   zeroMVfieldShifted.y = fieldShift;

	mov	eax, DWORD PTR _fieldShift$[ebp]
	mov	DWORD PTR fs:0, esp
	sub	esp, 1044				; 00000414H
	push	esi
	mov	esi, ecx

; 361  : 
; 362  :   pSrcFrame = _pSrcFrame;

	mov	ecx, DWORD PTR __pSrcFrame$[ebp]
	push	edi

; 529  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	mov	edi, DWORD PTR _out$[ebp]

; 340  :   zeroMVfieldShifted.y = fieldShift;

	mov	DWORD PTR [esi+208], eax

; 348  :   _glob_mv_pred_def.y = fieldShift;

	mov	DWORD PTR [esi+284], eax

; 529  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	mov	eax, DWORD PTR [esi+16]

; 336  :   // -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
; 337  :   // Frame- and plane-related data preparation
; 338  : 
; 339  :   zeroMVfieldShifted.x = 0;

	mov	DWORD PTR [esi+204], 0

; 341  :   zeroMVfieldShifted.sad = 0; // vs

	mov	DWORD PTR [esi+212], 0

; 342  : #ifdef ALLOW_DCT
; 343  :   dctweight16 = 8;//min(16,abs(*pmeanLumaChange)/(nBlkSizeX*nBlkSizeY)); //equal dct and spatial weights for meanLumaChange=8 (empirical)

	mov	DWORD PTR [esi+220], 8

; 529  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	lea	eax, DWORD PTR [eax+eax*2]

; 344  : #endif	// ALLOW_DCT
; 345  : 
; 346  :   // Actually the global predictor is not used in RecalculateMVs().
; 347  :   _glob_mv_pred_def.x = 0;

	mov	DWORD PTR [esi+280], 0

; 529  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	inc	eax

; 349  :   _glob_mv_pred_def.sad = 9999999; // P.F. will be good for floats, too

	mov	DWORD PTR [esi+288], 9999999		; 0098967fH

; 529  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	mov	DWORD PTR [edi], eax

; 350  : 
; 351  :   //	int nOutPitchY = nBlkX * (nBlkSizeX - nOverlapX) + nOverlapX;
; 352  :   //	int nOutPitchUV = (nBlkX * (nBlkSizeX - nOverlapX) + nOverlapX) / 2; // xRatioUV=2
; 353  :   //	char debugbuf[128];
; 354  :   //	wsprintf(debugbuf,"MVCOMP1: nOutPitchUV=%d, nOverlap=%d, nBlkX=%d, nBlkSize=%d",nOutPitchUV, nOverlap, nBlkX, nBlkSize);
; 355  :   //	OutputDebugString(debugbuf);
; 356  : 
; 357  :     // write the plane's header
; 358  :   WriteHeaderToArray(out);
; 359  : 
; 360  :   nFlags |= flags;

	mov	eax, DWORD PTR _flags$[ebp]
	or	DWORD PTR [esi+36], eax

; 363  :   pRefFrame = _pRefFrame;

	mov	eax, DWORD PTR __pRefFrame$[ebp]
	mov	DWORD PTR [esi+160], ecx
	mov	DWORD PTR [esi+164], eax
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [ecx]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 366  :   nSrcPitch_plane[0] = pSrcFrame->GetPlane(YPLANE)->GetPitch();

	mov	DWORD PTR [esi+192], eax

; 367  :   if (chroma)

	cmp	BYTE PTR [esi+122], 0
	je	SHORT $LN2@Recalculat
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 369  :     nSrcPitch_plane[1] = pSrcFrame->GetPlane(UPLANE)->GetPitch();

	mov	DWORD PTR [esi+196], eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [ecx+8]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 370  :     nSrcPitch_plane[2] = pSrcFrame->GetPlane(VPLANE)->GetPitch();

	mov	DWORD PTR [esi+200], eax
$LN2@Recalculat:

; 371  :   }
; 372  :   nSrcPitch[0] = pixelsize * nBlkSizeX;

	mov	eax, DWORD PTR [esi+8]
	imul	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [esi+168], eax

; 373  :   nSrcPitch[1] = pixelsize * nBlkSizeX / xRatioUV; // PF after 2.7.0.22c

	mov	eax, DWORD PTR [esi+8]
	imul	eax, DWORD PTR [esi+64]
	cdq
	idiv	DWORD PTR [esi+48]
	mov	DWORD PTR [esi+172], eax

; 374  :   nSrcPitch[2] = pixelsize * nBlkSizeX / xRatioUV; // PF after 2.7.0.22c

	mov	eax, DWORD PTR [esi+8]
	imul	eax, DWORD PTR [esi+64]
	cdq
	idiv	DWORD PTR [esi+48]
	mov	DWORD PTR [esi+176], eax

; 383  :   nRefPitch[0] = pRefFrame->GetPlane(YPLANE)->GetPitch();

	mov	eax, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 383  :   nRefPitch[0] = pRefFrame->GetPlane(YPLANE)->GetPitch();

	mov	DWORD PTR [esi+180], eax

; 384  :   if (chroma)

	cmp	BYTE PTR [esi+122], 0
	je	SHORT $LN3@Recalculat

; 386  :     nRefPitch[1] = pRefFrame->GetPlane(UPLANE)->GetPitch();

	mov	eax, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 386  :     nRefPitch[1] = pRefFrame->GetPlane(UPLANE)->GetPitch();

	mov	DWORD PTR [esi+184], eax

; 387  :     nRefPitch[2] = pRefFrame->GetPlane(VPLANE)->GetPitch();

	mov	eax, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 387  :     nRefPitch[2] = pRefFrame->GetPlane(VPLANE)->GetPitch();

	mov	DWORD PTR [esi+188], eax
$LN3@Recalculat:

; 388  :   }
; 389  : 
; 390  :   searchType = st;

	mov	eax, DWORD PTR _st$[ebp]

; 391  :   nSearchParam = stp;//*nPel; // v1.8.2 - redesigned in v1.8.5
; 392  : 
; 393  :   _lambda_level = lambda / (nPel * nPel);

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+224], eax
	mov	eax, DWORD PTR _stp$[ebp]
	mov	DWORD PTR [esi+228], eax
	mov	eax, DWORD PTR _lambda$[ebp]
	imul	ecx, ecx
	cdq
	push	ebx

; 394  :   //	if (plevel==1)
; 395  :   //	{
; 396  :   //		_lambda_level *= nScale;// scale lambda - Fizick
; 397  :   //	}
; 398  :   //	else if (plevel==2)
; 399  :   //	{
; 400  :   //		_lambda_level *= nScale*nScale;
; 401  :   //	}
; 402  : 
; 403  :   planeSAD = 0;

	sub	esp, 8
	idiv	ecx
	lea	ecx, DWORD PTR [esi+264]
	mov	DWORD PTR [esi+292], eax
	call	??4?$AtomicInt@_J@conc@@QAEAAV01@_J@Z	; conc::AtomicInt<__int64>::operator=

; 404  :   sumLumaChange = 0;

	sub	esp, 8
	lea	ecx, DWORD PTR [esi+272]
	call	??4?$AtomicInt@_J@conc@@QAEAAV01@_J@Z	; conc::AtomicInt<__int64>::operator=

; 405  : 
; 406  :   _out = out;
; 407  :   _outfilebuf = outfilebuf;

	mov	eax, DWORD PTR _outfilebuf$[ebp]

; 417  :   Slicer			slicer(_mt_flag);

	mov	bl, BYTE PTR [esi+76]
	mov	DWORD PTR [esi+300], eax
	mov	al, BYTE PTR _meander$[ebp]
	mov	BYTE PTR [esi+308], al
	mov	eax, DWORD PTR _pnew$[ebp]
	mov	DWORD PTR [esi+312], eax
	mov	eax, DWORD PTR _lsad$[ebp]
	mov	DWORD PTR [esi+316], eax
	mov	eax, DWORD PTR _mvClip$[ebp]
	mov	DWORD PTR [esi+320], eax
	mov	eax, DWORD PTR _smooth$[ebp]
	mov	DWORD PTR [esi+324], eax
	mov	eax, DWORD PTR _thSAD$[ebp]
	mov	DWORD PTR [esi+296], edi
	mov	DWORD PTR [esi+328], eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 70   : {

	mov	DWORD PTR _slicer$[ebp], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR _slicer$[ebp+4], eax

; 66   : ,	_proc_ptr (0)
; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR _slicer$[ebp+16]
	push	1024					; 00000400H
	push	0
	mov	DWORD PTR _slicer$[ebp+8], 0
	push	eax
	mov	DWORD PTR _slicer$[ebp+12], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 69   : ,	_mt_flag (mt_flag)

	mov	BYTE PTR _slicer$[ebp+1040], bl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 417  :   Slicer			slicer(_mt_flag);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 418  :   if(pixelsize==8)
; 419  :     slicer.start(nBlkY, *this, &PlaneOfBlocks::recalculate_mv_slice<uint8_t>, 4);

	lea	ecx, DWORD PTR _slicer$[ebp]
	cmp	DWORD PTR [esi+64], 8
	pop	ebx
	push	4
	jne	SHORT $LN4@Recalculat
	push	OFFSET ??$recalculate_mv_slice@E@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::recalculate_mv_slice<unsigned char>

; 420  :   else

	jmp	SHORT $LN85@Recalculat
$LN4@Recalculat:

; 421  :     slicer.start(nBlkY, *this, &PlaneOfBlocks::recalculate_mv_slice<uint16_t>, 4);

	push	OFFSET ??$recalculate_mv_slice@G@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::recalculate_mv_slice<unsigned short>
$LN85@Recalculat:
	push	esi
	push	DWORD PTR [esi+4]
	call	?start@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXHAAVPlaneOfBlocks@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::start
; File c:\github\mvtools\sources\mtslicer.hpp

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer$[ebp+1040], 0
	pop	edi
	pop	esi
	je	SHORT $LN67@Recalculat

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer$[ebp+4]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer$[ebp+4]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN67@Recalculat:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR _slicer$[ebp+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer$[ebp+12], 0

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR _slicer$[ebp+12], 0
	mov	DWORD PTR _slicer$[ebp], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@
	je	SHORT $LN74@Recalculat

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer$[ebp+1040], 0
	je	SHORT $LN78@Recalculat

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer$[ebp+4]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer$[ebp+4]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN78@Recalculat:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR _slicer$[ebp+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer$[ebp+12], 0
$LN74@Recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 425  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z$0:
	lea	ecx, DWORD PTR _slicer$[ebp]
	jmp	??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::~MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>
__unwindfunclet$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z ENDP ; PlaneOfBlocks::RecalculateMVs
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ?satz@@YAHH@Z
_TEXT	SEGMENT
?satz@@YAHH@Z PROC					; satz, COMDAT
; _a$ = ecx

; 7    : 	return ~(a >> (sizeof(int)*8 - 1)) & a;

	mov	eax, ecx
	sar	eax, 31					; 0000001fH
	not	eax
	and	eax, ecx

; 8    : }

	ret	0
?satz@@YAHH@Z ENDP					; satz
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ?ilog2@@YAHH@Z
_TEXT	SEGMENT
?ilog2@@YAHH@Z PROC					; ilog2, COMDAT
; _i$ = ecx

; 24   : {

	mov	eax, ecx

; 25   : 	int result = 0;

	xor	ecx, ecx

; 26   : 	while ( i > 1 ) { i /= 2; result++; }

	cmp	eax, 1
	jle	SHORT $LN9@ilog2
	npad	7
$LL2@ilog2:
	cdq
	inc	ecx
	sub	eax, edx
	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL2@ilog2
$LN9@ilog2:

; 27   : 	return result;

	mov	eax, ecx

; 28   : }

	ret	0
?ilog2@@YAHH@Z ENDP					; ilog2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ?iexp2@@YAHH@Z
_TEXT	SEGMENT
?iexp2@@YAHH@Z PROC					; iexp2, COMDAT
; _i$ = ecx

; 7    : 	return ~(a >> (sizeof(int)*8 - 1)) & a;

	mov	edx, ecx

; 33   : 	return 1 << satz(i);

	mov	eax, 1

; 7    : 	return ~(a >> (sizeof(int)*8 - 1)) & a;

	sar	edx, 31					; 0000001fH
	not	edx
	and	ecx, edx

; 33   : 	return 1 << satz(i);

	shl	eax, cl

; 34   : // 	int result = 1;
; 35   : // 	while ( i > 0 ) { result *= 2; i--; }
; 36   : // 	return result;
; 37   : }

	ret	0
?iexp2@@YAHH@Z ENDP					; iexp2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\debugprintf.h
;	COMDAT ?DebugPrintf@@YAXPADZZ
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?DebugPrintf@@YAXPADZZ PROC				; DebugPrintf, COMDAT

; 52   :   __noop(fmt); 	// Nothing
; 53   : }

	ret	0
?DebugPrintf@@YAXPADZZ ENDP				; DebugPrintf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetReducedWidth@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetReducedWidth@FakePlaneOfBlocks@@QBEHXZ PROC		; FakePlaneOfBlocks::GetReducedWidth, COMDAT
; _this$ = ecx

; 64   : 	inline int GetReducedWidth() const { return nBlkX; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?GetReducedWidth@FakePlaneOfBlocks@@QBEHXZ ENDP		; FakePlaneOfBlocks::GetReducedWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetReducedHeight@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetReducedHeight@FakePlaneOfBlocks@@QBEHXZ PROC	; FakePlaneOfBlocks::GetReducedHeight, COMDAT
; _this$ = ecx

; 65   : 	inline int GetReducedHeight() const { return nBlkY; }

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?GetReducedHeight@FakePlaneOfBlocks@@QBEHXZ ENDP	; FakePlaneOfBlocks::GetReducedHeight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvframe.h
;	COMDAT ?GetMode@MVFrame@@QAEHXZ
_TEXT	SEGMENT
?GetMode@MVFrame@@QAEHXZ PROC				; MVFrame::GetMode, COMDAT
; _this$ = ecx

; 78   :    inline int GetMode() { return nMode; }

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?GetMode@MVFrame@@QAEHXZ ENDP				; MVFrame::GetMode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicmem.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicmem.hpp
;	COMDAT ?swap@?$AtomicMem@$02@conc@@SA_JAC_J_J@Z
_TEXT	SEGMENT
_excg$ = -24						; size = 8
_old$1 = -16						; size = 8
_dest$ = -4						; size = 4
_excg$dead$ = 8						; size = 8
?swap@?$AtomicMem@$02@conc@@SA_JAC_J_J@Z PROC		; conc::AtomicMem<3>::swap, COMDAT
; _dest$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	xorps	xmm0, xmm0
	mov	DWORD PTR _dest$[ebp], ecx
	push	esi
	movlpd	QWORD PTR _excg$[ebp], xmm0
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 83   : 		push				ebx

	push	ebx

; 84   : 		mov				esi, [dest]

	mov	esi, DWORD PTR _dest$[ebp]

; 85   : 		mov				ebx, [dword ptr excg    ]

	mov	ebx, DWORD PTR _excg$[ebp]

; 86   : 		mov				ecx, [dword ptr excg + 4]

	mov	ecx, DWORD PTR _excg$[ebp+4]
$cas_loop$6:

; 87   : 
; 88   : 	cas_loop:
; 89   : 		mov				eax, [esi    ]

	mov	eax, DWORD PTR [esi]

; 90   : 		mov				edx, [esi + 4]

	mov	edx, DWORD PTR [esi+4]

; 91   : 		lock cmpxchg8b	[esi]

	lock	 cmpxchg8b QWORD PTR [esi]

; 92   : 		jnz				cas_loop

	jne	SHORT $cas_loop$6

; 93   : 
; 94   : 		mov				[dword ptr old    ], eax

	mov	DWORD PTR _old$1[ebp], eax

; 95   : 		mov				[dword ptr old + 4], edx

	mov	DWORD PTR _old$1[ebp+4], edx

; 96   : 		pop				ebx

	pop	ebx
; File c:\github\mvtools\sources\conc\atomicmem.hpp

; 61   : 	return (Interlocked::swap (dest, excg));

	mov	eax, DWORD PTR _old$1[ebp]
	mov	edx, DWORD PTR _old$1[ebp+4]

; 62   : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?swap@?$AtomicMem@$02@conc@@SA_JAC_J_J@Z ENDP		; conc::AtomicMem<3>::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicmem.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicmem.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicmem.hpp
;	COMDAT ?cas@?$AtomicMem@$02@conc@@SA_JAC_J_J1@Z
_TEXT	SEGMENT
_excg$ = 8						; size = 8
_comp$ = 16						; size = 8
?cas@?$AtomicMem@$02@conc@@SA_JAC_J_J1@Z PROC		; conc::AtomicMem<3>::cas, COMDAT
; _dest$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, DWORD PTR _comp$[esp-4]
	mov	edx, DWORD PTR _comp$[esp]
; File c:\github\mvtools\sources\conc\atomicmem.hpp

; 67   : {

	push	ebx
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	ecx, DWORD PTR _excg$[esp+8]
	mov	ebx, DWORD PTR _excg$[esp+4]
	lock	 cmpxchg8b QWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicmem.hpp

; 69   : }

	pop	esi
	pop	ebx
	ret	0
?cas@?$AtomicMem@$02@conc@@SA_JAC_J_J1@Z ENDP		; conc::AtomicMem<3>::cas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ?GetAbsolutePelPointer@MVPlane@@QBEPBEHH@Z
_TEXT	SEGMENT
_nX$ = 8						; size = 4
_nY$ = 12						; size = 4
?GetAbsolutePelPointer@MVPlane@@QBEPBEHH@Z PROC		; MVPlane::GetAbsolutePelPointer, COMDAT
; _this$ = ecx

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR _nX$[esp-4]
	push	esi
	mov	esi, ecx
	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+52]
	imul	edx, DWORD PTR _nY$[esp]
	shl	eax, cl
	mov	ecx, DWORD PTR [esi]
	pop	esi
	add	eax, edx
	add	eax, DWORD PTR [ecx]

; 110  : 	}

	ret	8
?GetAbsolutePelPointer@MVPlane@@QBEPBEHH@Z ENDP		; MVPlane::GetAbsolutePelPointer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ?GetHPadding@MVPlane@@QBEHXZ
_TEXT	SEGMENT
?GetHPadding@MVPlane@@QBEHXZ PROC			; MVPlane::GetHPadding, COMDAT
; _this$ = ecx

; 117  :    inline int GetHPadding() const { return nHPadding; }

	mov	eax, DWORD PTR [ecx+16]
	ret	0
?GetHPadding@MVPlane@@QBEHXZ ENDP			; MVPlane::GetHPadding
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ?GetVPadding@MVPlane@@QBEHXZ
_TEXT	SEGMENT
?GetVPadding@MVPlane@@QBEHXZ PROC			; MVPlane::GetVPadding, COMDAT
; _this$ = ecx

; 118  :    inline int GetVPadding() const { return nVPadding; }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?GetVPadding@MVPlane@@QBEHXZ ENDP			; MVPlane::GetVPadding
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ PROC ; conc::Array<std::vector<int,std::allocator<int> >,2>::Array<std::vector<int,std::allocator<int> >,2>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	push	OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	push	2
	mov	esi, ecx
	push	12					; 0000000cH
	push	esi
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ ENDP ; conc::Array<std::vector<int,std::allocator<int> >,2>::Array<std::vector<int,std::allocator<int> >,2>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ PROC ; conc::Array<std::vector<int,std::allocator<int> >,2>::~Array<std::vector<int,std::allocator<int> >,2>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	push	2
	push	12					; 0000000cH
	push	ecx
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAE@XZ ENDP ; conc::Array<std::vector<int,std::allocator<int> >,2>::~Array<std::vector<int,std::allocator<int> >,2>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objfactoryinterface.h
;	COMDAT ??1WorkingAreaFactory@PlaneOfBlocks@@UAE@XZ
_TEXT	SEGMENT
??1WorkingAreaFactory@PlaneOfBlocks@@UAE@XZ PROC	; PlaneOfBlocks::WorkingAreaFactory::~WorkingAreaFactory, COMDAT
; _this$ = ecx

; 47   : 	virtual			~ObjFactoryInterface () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
	ret	0
??1WorkingAreaFactory@PlaneOfBlocks@@UAE@XZ ENDP	; PlaneOfBlocks::WorkingAreaFactory::~WorkingAreaFactory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?WriteHeaderToArray@PlaneOfBlocks@@QAEXPAH@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
?WriteHeaderToArray@PlaneOfBlocks@@QAEXPAH@Z PROC	; PlaneOfBlocks::WriteHeaderToArray, COMDAT
; _this$ = ecx

; 529  :   array[0] = nBlkCount * N_PER_BLOCK + 1;

	mov	eax, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [eax*2+1]
	add	ecx, eax
	mov	eax, DWORD PTR _array$[esp-4]
	mov	DWORD PTR [eax], ecx

; 530  : }

	ret	4
?WriteHeaderToArray@PlaneOfBlocks@@QAEXPAH@Z ENDP	; PlaneOfBlocks::WriteHeaderToArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z
_TEXT	SEGMENT
_mvy$1$ = -4						; size = 4
_mvx$1$ = -4						; size = 4
_mvx$1$ = 8						; size = 4
_mvy$1$ = 8						; size = 4
_mvy$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z PROC	; PlaneOfBlocks::Refine, COMDAT
; _this$ = ecx

; 674  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 675  :   // then, we refine, according to the search type
; 676  :   if (searchType & ONETIME)

	mov	edi, DWORD PTR _workarea$[esp+16]
	test	BYTE PTR [esi+224], 1
	je	SHORT $LN3@Refine

; 677  :   {
; 678  :     for (int i = nSearchParam; i > 0; i /= 2)

	mov	ebx, DWORD PTR [esi+228]
	test	ebx, ebx
	jle	SHORT $LN3@Refine
	npad	2
$LL4@Refine:

; 679  :     {
; 680  :       OneTimeSearch(workarea, i);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?OneTimeSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::OneTimeSearch
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	test	ebx, ebx
	jg	SHORT $LL4@Refine
$LN3@Refine:

; 681  :     }
; 682  :   }
; 683  : 
; 684  :   if (searchType & NSTEP)

	test	BYTE PTR [esi+224], 2
	je	SHORT $LN18@Refine

; 685  :   {
; 686  :     NStepSearch(workarea, nSearchParam);

	push	DWORD PTR [esi+228]
	mov	ecx, esi
	push	edi
	call	?NStepSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::NStepSearch
$LN18@Refine:

; 687  :   }
; 688  : 
; 689  :   if (searchType & LOGARITHMIC)

	test	BYTE PTR [esi+224], 4
	je	SHORT $LN6@Refine

; 690  :   {
; 691  :     for (int i = nSearchParam; i > 0; i /= 2)

	mov	ebx, DWORD PTR [esi+228]
	test	ebx, ebx
	jle	SHORT $LN6@Refine
$LL7@Refine:

; 692  :     {
; 693  :       DiamondSearch(workarea, i);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?DiamondSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::DiamondSearch
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	test	ebx, ebx
	jg	SHORT $LL7@Refine
$LN6@Refine:

; 694  :     }
; 695  :   }
; 696  : 
; 697  :   if (searchType & EXHAUSTIVE)

	test	BYTE PTR [esi+224], 8
	je	SHORT $LN9@Refine

; 698  :   {
; 699  :     //		ExhaustiveSearch(nSearchParam);
; 700  :     int mvx = workarea.bestMV.x;
; 701  :     int mvy = workarea.bestMV.y;

	mov	eax, DWORD PTR [edi+104]

; 702  :     for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	ebx, 1
	mov	ebp, DWORD PTR [edi+100]
	mov	DWORD PTR _mvy$1$[esp+16], eax
	cmp	DWORD PTR [esi+228], ebx
	jl	SHORT $LN9@Refine
$LL10@Refine:

; 703  :     {
; 704  :       ExpandingSearch(workarea, i, 1, mvx, mvy);

	push	eax
	push	ebp
	push	1
	push	ebx
	push	edi
	mov	ecx, esi
	call	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch
	mov	eax, DWORD PTR _mvy$1$[esp+16]
	inc	ebx
	cmp	ebx, DWORD PTR [esi+228]
	jle	SHORT $LL10@Refine
$LN9@Refine:

; 705  :     }
; 706  :   }
; 707  : 
; 708  :   //	if ( searchType & SQUARE )
; 709  :   //	{
; 710  :   //		SquareSearch();
; 711  :   //	}
; 712  : 
; 713  :   if (searchType & HEX2SEARCH)

	test	BYTE PTR [esi+224], 16			; 00000010H
	je	SHORT $LN21@Refine

; 714  :   {
; 715  :     Hex2Search(workarea, nSearchParam);

	push	DWORD PTR [esi+228]
	mov	ecx, esi
	push	edi
	call	?Hex2Search@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::Hex2Search
$LN21@Refine:

; 716  :   }
; 717  : 
; 718  :   if (searchType & UMHSEARCH)

	test	BYTE PTR [esi+224], 32			; 00000020H
	je	SHORT $LN22@Refine

; 719  :   {
; 720  :     UMHSearch(workarea, nSearchParam, workarea.bestMV.x, workarea.bestMV.y);

	push	DWORD PTR [edi+104]
	mov	ecx, esi
	push	DWORD PTR [edi+100]
	push	DWORD PTR [esi+228]
	push	edi
	call	?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z ; PlaneOfBlocks::UMHSearch
$LN22@Refine:

; 721  :   }
; 722  : 
; 723  :   if (searchType & HSEARCH)

	test	BYTE PTR [esi+224], 64			; 00000040H
	je	SHORT $LN12@Refine

; 724  :   {
; 725  :     int mvx = workarea.bestMV.x;

	mov	ecx, DWORD PTR [edi+100]

; 726  :     int mvy = workarea.bestMV.y;
; 727  :     for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	ebx, 1
	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR _mvx$1$[esp+20], ecx
	mov	DWORD PTR _mvy$1$[esp+16], eax
	cmp	DWORD PTR [esi+228], ebx
	jl	SHORT $LN12@Refine

; 724  :   {
; 725  :     int mvx = workarea.bestMV.x;

	lea	ebp, DWORD PTR [ecx-1]
	npad	5
$LL13@Refine:

; 728  :     {
; 729  :       CheckMV(workarea, mvx - i, mvy);

	push	eax
	push	ebp
	push	edi
	mov	ecx, esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 730  :       CheckMV(workarea, mvx + i, mvy);

	push	DWORD PTR _mvy$1$[esp+16]
	mov	eax, DWORD PTR _mvx$1$[esp+24]
	mov	ecx, esi
	add	eax, ebx
	push	eax
	push	edi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	mov	eax, DWORD PTR _mvy$1$[esp+16]
	inc	ebx
	dec	ebp
	cmp	ebx, DWORD PTR [esi+228]
	jle	SHORT $LL13@Refine
$LN12@Refine:

; 731  :     }
; 732  :   }
; 733  : 
; 734  :   if (searchType & VSEARCH)

	test	BYTE PTR [esi+224], 128			; 00000080H
	je	SHORT $LN15@Refine

; 735  :   {
; 736  :     int mvx = workarea.bestMV.x;

	mov	eax, DWORD PTR [edi+100]

; 737  :     int mvy = workarea.bestMV.y;
; 738  :     for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	ebx, 1
	mov	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR _mvx$1$[esp+16], eax
	mov	DWORD PTR _mvy$1$[esp+20], ecx
	cmp	DWORD PTR [esi+228], ebx
	jl	SHORT $LN15@Refine

; 735  :   {
; 736  :     int mvx = workarea.bestMV.x;

	lea	ebp, DWORD PTR [ecx-1]
$LL16@Refine:

; 739  :     {
; 740  :       CheckMV(workarea, mvx, mvy - i);

	push	ebp
	push	eax
	push	edi
	mov	ecx, esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 741  :       CheckMV(workarea, mvx, mvy + i);

	mov	eax, DWORD PTR _mvy$1$[esp+20]
	mov	ecx, esi
	add	eax, ebx
	push	eax
	push	DWORD PTR _mvx$1$[esp+20]
	push	edi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	mov	eax, DWORD PTR _mvx$1$[esp+16]
	inc	ebx
	dec	ebp
	cmp	ebx, DWORD PTR [esi+228]
	jle	SHORT $LL16@Refine
$LN15@Refine:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 742  :     }
; 743  :   }
; 744  : }

	pop	ecx
	ret	4
?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ENDP	; PlaneOfBlocks::Refine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?DiamondSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z
_TEXT	SEGMENT
_dx$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
_lastDirection$1$ = -4					; size = 4
_direction$ = 8						; size = 4
_workarea$ = 8						; size = 4
_dy$2$ = 12						; size = 4
_dy$1$ = 12						; size = 4
_length$ = 12						; size = 4
?DiamondSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z PROC ; PlaneOfBlocks::DiamondSearch, COMDAT
; _this$ = ecx

; 979  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _workarea$[esp+12]
	push	ebp

; 980  :   // The meaning of the directions are the following :
; 981  :   //		* 1 means right
; 982  :   //		* 2 means left
; 983  :   //		* 4 means down
; 984  :   //		* 8 means up
; 985  :   // So 1 + 4 means down right, and so on...
; 986  : 
; 987  :   int dx;
; 988  :   int dy;
; 989  : 
; 990  :   // We begin by making no assumption on which direction to search.
; 991  :   int direction = 15;

	mov	ebp, DWORD PTR _length$[esp+16]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, 15					; 0000000fH
	mov	DWORD PTR _this$1$[esp+28], edi
	mov	DWORD PTR _lastDirection$1$[esp+28], ecx
	npad	2
$LL2@DiamondSea:

; 992  : 
; 993  :   int lastDirection;
; 994  : 
; 995  :   while (direction > 0)
; 996  :   {
; 997  :     dx = workarea.bestMV.x;

	mov	esi, DWORD PTR [ebx+100]

; 998  :     dy = workarea.bestMV.y;

	mov	eax, DWORD PTR [ebx+104]
	mov	DWORD PTR _dx$2$[esp+28], esi
	mov	DWORD PTR _dy$2$[esp+24], eax

; 999  :     lastDirection = direction;
; 1000 :     direction = 0;

	mov	DWORD PTR _direction$[esp+24], 0

; 1001 : 
; 1002 :     // First, we look the directions that were hinted by the previous step
; 1003 :     // of the algorithm. If we find one, we add it to the set of directions
; 1004 :     // we'll test next
; 1005 :     if (lastDirection & 1) CheckMV2(workarea, dx + length, dy, &direction, 1);

	test	cl, 1
	je	SHORT $LN6@DiamondSea
	push	1
	lea	ecx, DWORD PTR _direction$[esp+28]
	push	ecx
	push	eax
	lea	eax, DWORD PTR [esi+ebp]
	mov	ecx, edi
	push	eax
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	mov	eax, DWORD PTR _dy$2$[esp+24]
	mov	ecx, DWORD PTR _lastDirection$1$[esp+28]
$LN6@DiamondSea:

; 1006 :     if (lastDirection & 2) CheckMV2(workarea, dx - length, dy, &direction, 2);

	test	cl, 2
	je	SHORT $LN7@DiamondSea
	push	2
	lea	ecx, DWORD PTR _direction$[esp+28]
	push	ecx
	push	eax
	mov	eax, esi
	mov	ecx, edi
	sub	eax, ebp
	push	eax
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	mov	ecx, DWORD PTR _lastDirection$1$[esp+28]
$LN7@DiamondSea:

; 1007 :     if (lastDirection & 4) CheckMV2(workarea, dx, dy + length, &direction, 4);

	test	cl, 4
	je	SHORT $LN8@DiamondSea
	push	4
	lea	eax, DWORD PTR _direction$[esp+28]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	add	eax, ebp
	push	eax
	push	esi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	mov	ecx, DWORD PTR _lastDirection$1$[esp+28]
$LN8@DiamondSea:

; 1008 :     if (lastDirection & 8) CheckMV2(workarea, dx, dy - length, &direction, 8);

	test	cl, 8
	je	SHORT $LN9@DiamondSea
	push	8
	lea	eax, DWORD PTR _direction$[esp+28]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	sub	eax, ebp
	push	eax
	push	esi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	mov	ecx, DWORD PTR _lastDirection$1$[esp+28]
$LN9@DiamondSea:

; 1009 : 
; 1010 :     // If one of the directions improves the SAD, we make further tests
; 1011 :     // on the diagonals
; 1012 :     if (direction)

	mov	edx, DWORD PTR _direction$[esp+24]
	test	edx, edx
	je	SHORT $LN10@DiamondSea

; 1013 :     {
; 1014 :       lastDirection = direction;
; 1015 :       dx = workarea.bestMV.x;
; 1016 :       dy = workarea.bestMV.y;

	mov	eax, DWORD PTR [ebx+104]

; 1017 : 
; 1018 :       if (lastDirection & 3)
; 1019 :       {
; 1020 :         CheckMV2(workarea, dx, dy + length, &direction, 4);

	lea	ecx, DWORD PTR _direction$[esp+24]
	mov	esi, DWORD PTR [ebx+100]
	mov	DWORD PTR _dy$1$[esp+24], eax
	test	dl, 3
	je	SHORT $LN12@DiamondSea
	push	4
	push	ecx
	add	eax, ebp
	mov	ecx, edi
	push	eax
	push	esi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1021 :         CheckMV2(workarea, dx, dy - length, &direction, 8);

	push	8
	lea	eax, DWORD PTR _direction$[esp+28]
	push	eax
	mov	eax, DWORD PTR _dy$1$[esp+32]
	sub	eax, ebp
	push	eax
	push	esi

; 1022 :       }
; 1023 :       else

	jmp	$LN27@DiamondSea
$LN12@DiamondSea:

; 1024 :       {
; 1025 :         CheckMV2(workarea, dx + length, dy, &direction, 1);

	push	1
	push	ecx
	push	eax
	lea	eax, DWORD PTR [esi+ebp]
	mov	ecx, edi
	push	eax
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1026 :         CheckMV2(workarea, dx - length, dy, &direction, 2);

	push	2
	lea	eax, DWORD PTR _direction$[esp+28]
	sub	esi, ebp
	push	eax
	mov	eax, DWORD PTR _dy$1$[esp+32]
	push	eax
	push	esi

; 1027 :       }
; 1028 :     }
; 1029 : 
; 1030 :     // If not, we do not stop here. We infer from the last direction the
; 1031 :     // diagonals to be checked, because we might be lucky.
; 1032 :     else

	jmp	$LN27@DiamondSea
$LN10@DiamondSea:

; 1033 :     {
; 1034 :       switch (lastDirection)

	dec	ecx
	cmp	ecx, 9
	ja	$LN22@DiamondSea
	jmp	DWORD PTR $LN31@DiamondSea[ecx*4]
$LN14@DiamondSea:

; 1035 :       {
; 1036 :       case 1:
; 1037 :         CheckMV2(workarea, dx + length, dy + length, &direction, 1 + 4);

	push	5
	lea	eax, DWORD PTR _direction$[esp+28]
	add	esi, ebp
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	mov	ecx, edi
	add	eax, ebp
	push	eax
	push	esi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1038 :         CheckMV2(workarea, dx + length, dy - length, &direction, 1 + 8);

	push	9
	lea	eax, DWORD PTR _direction$[esp+28]
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	sub	eax, ebp
	push	eax
	push	esi

; 1039 :         break;

	jmp	$LN27@DiamondSea
$LN15@DiamondSea:

; 1040 :       case 2:
; 1041 :         CheckMV2(workarea, dx - length, dy + length, &direction, 2 + 4);

	push	6
	lea	eax, DWORD PTR _direction$[esp+28]
	sub	esi, ebp
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	mov	ecx, edi
	add	eax, ebp
	push	eax
	push	esi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1042 :         CheckMV2(workarea, dx - length, dy - length, &direction, 2 + 8);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _direction$[esp+28]
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	sub	eax, ebp
	push	eax
	push	esi

; 1043 :         break;

	jmp	$LN27@DiamondSea
$LN16@DiamondSea:

; 1044 :       case 4:
; 1045 :         CheckMV2(workarea, dx + length, dy + length, &direction, 1 + 4);

	mov	esi, DWORD PTR _dy$2$[esp+24]
	lea	eax, DWORD PTR _direction$[esp+24]
	push	5
	push	eax
	mov	eax, DWORD PTR _dx$2$[esp+36]
	add	esi, ebp
	push	esi
	add	eax, ebp
	mov	ecx, edi
	push	eax
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1046 :         CheckMV2(workarea, dx - length, dy + length, &direction, 2 + 4);

	lea	eax, DWORD PTR _direction$[esp+24]
	push	6
	push	eax
	mov	eax, DWORD PTR _dx$2$[esp+36]
	sub	eax, ebp

; 1047 :         break;

	jmp	$LN28@DiamondSea
$LN17@DiamondSea:

; 1048 :       case 8:
; 1049 :         CheckMV2(workarea, dx + length, dy - length, &direction, 1 + 8);

	mov	eax, DWORD PTR _dy$2$[esp+24]
	lea	ecx, DWORD PTR _direction$[esp+24]
	push	9
	push	ecx
	sub	eax, ebp
	mov	ecx, edi
	push	eax
	mov	DWORD PTR _dy$2$[esp+36], eax
	lea	eax, DWORD PTR [esi+ebp]
	push	eax
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1050 :         CheckMV2(workarea, dx - length, dy - length, &direction, 2 + 8);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _direction$[esp+28]
	sub	esi, ebp
	push	eax
	push	DWORD PTR _dy$2$[esp+32]
	push	esi

; 1051 :         break;

	jmp	$LN27@DiamondSea
$LN18@DiamondSea:

; 1052 :       case 1 + 4:
; 1053 :         CheckMV2(workarea, dx + length, dy + length, &direction, 1 + 4);

	mov	esi, DWORD PTR _dy$2$[esp+24]
	lea	eax, DWORD PTR _direction$[esp+24]
	mov	edi, DWORD PTR _dx$2$[esp+28]
	add	esi, ebp
	mov	ecx, DWORD PTR _this$1$[esp+28]
	add	edi, ebp
	push	5
	push	eax
	push	esi
	push	edi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1054 :         CheckMV2(workarea, dx - length, dy + length, &direction, 2 + 4);

	mov	ecx, DWORD PTR _this$1$[esp+28]
	lea	eax, DWORD PTR _direction$[esp+24]
	push	6
	push	eax
	mov	eax, DWORD PTR _dx$2$[esp+36]
	push	esi
	sub	eax, ebp
	push	eax
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1055 :         CheckMV2(workarea, dx + length, dy - length, &direction, 1 + 8);

	push	9
	lea	eax, DWORD PTR _direction$[esp+28]
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	sub	eax, ebp
	push	eax
	push	edi
	mov	edi, DWORD PTR _this$1$[esp+44]

; 1056 :         break;

	jmp	$LN27@DiamondSea
$LN19@DiamondSea:

; 1057 :       case 2 + 4:
; 1058 :         CheckMV2(workarea, dx + length, dy + length, &direction, 1 + 4);

	mov	esi, DWORD PTR _dy$2$[esp+24]
	lea	eax, DWORD PTR _direction$[esp+24]
	push	5
	push	eax
	mov	eax, DWORD PTR _dx$2$[esp+36]
	add	esi, ebp
	push	esi
	add	eax, ebp
	mov	ecx, edi
	push	eax
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1059 :         CheckMV2(workarea, dx - length, dy + length, &direction, 2 + 4);

	mov	eax, DWORD PTR _dx$2$[esp+28]
	lea	ecx, DWORD PTR _direction$[esp+24]
	push	6
	push	ecx
	sub	eax, ebp
	mov	ecx, edi
	push	esi
	push	eax
	push	ebx
	mov	DWORD PTR _dx$2$[esp+48], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1060 :         CheckMV2(workarea, dx - length, dy - length, &direction, 2 + 8);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _direction$[esp+28]
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	sub	eax, ebp
	push	eax
	mov	eax, DWORD PTR _dx$2$[esp+40]

; 1061 :         break;

	jmp	$LN29@DiamondSea
$LN20@DiamondSea:

; 1062 :       case 1 + 8:
; 1063 :         CheckMV2(workarea, dx + length, dy + length, &direction, 1 + 4);

	push	5
	lea	eax, DWORD PTR _direction$[esp+28]
	add	esi, ebp
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	mov	ecx, edi
	add	eax, ebp
	push	eax
	push	esi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1064 :         CheckMV2(workarea, dx - length, dy - length, &direction, 2 + 8);

	mov	eax, DWORD PTR _dy$2$[esp+24]
	lea	ecx, DWORD PTR _direction$[esp+24]
	push	10					; 0000000aH
	sub	eax, ebp
	push	ecx
	push	eax
	mov	DWORD PTR _dy$2$[esp+36], eax
	mov	ecx, edi
	mov	eax, DWORD PTR _dx$2$[esp+40]
	sub	eax, ebp
	push	eax
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1065 :         CheckMV2(workarea, dx + length, dy - length, &direction, 1 + 8);

	push	9
	lea	eax, DWORD PTR _direction$[esp+28]
	push	eax
	push	DWORD PTR _dy$2$[esp+32]
	push	esi

; 1066 :         break;

	jmp	$LN27@DiamondSea
$LN21@DiamondSea:

; 1067 :       case 2 + 8:
; 1068 :         CheckMV2(workarea, dx - length, dy - length, &direction, 2 + 8);

	mov	edi, DWORD PTR _dy$2$[esp+24]
	lea	eax, DWORD PTR _direction$[esp+24]
	mov	ecx, DWORD PTR _this$1$[esp+28]
	sub	edi, ebp
	push	10					; 0000000aH
	push	eax
	push	edi
	sub	esi, ebp
	push	esi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1069 :         CheckMV2(workarea, dx - length, dy + length, &direction, 2 + 4);

	mov	ecx, DWORD PTR _this$1$[esp+28]
	lea	eax, DWORD PTR _direction$[esp+24]
	push	6
	push	eax
	mov	eax, DWORD PTR _dy$2$[esp+32]
	add	eax, ebp
	push	eax
	push	esi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1070 :         CheckMV2(workarea, dx + length, dy - length, &direction, 1 + 8);

	push	9
	lea	eax, DWORD PTR _direction$[esp+28]
	push	eax
	mov	eax, DWORD PTR _dx$2$[esp+36]
	push	edi
	mov	edi, DWORD PTR _this$1$[esp+40]
	add	eax, ebp

; 1071 :         break;

	jmp	SHORT $LN29@DiamondSea
$LN22@DiamondSea:

; 1072 :       default:
; 1073 :         // Even the default case may happen, in the first step of the
; 1074 :         // algorithm for example.
; 1075 :         CheckMV2(workarea, dx + length, dy + length, &direction, 1 + 4);

	mov	esi, DWORD PTR _dy$2$[esp+24]
	lea	eax, DWORD PTR _direction$[esp+24]
	mov	edi, DWORD PTR _dx$2$[esp+28]
	add	esi, ebp
	mov	ecx, DWORD PTR _this$1$[esp+28]
	add	edi, ebp
	push	5
	push	eax
	push	esi
	push	edi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1076 :         CheckMV2(workarea, dx - length, dy + length, &direction, 2 + 4);

	mov	eax, DWORD PTR _dx$2$[esp+28]
	lea	ecx, DWORD PTR _direction$[esp+24]
	push	6
	push	ecx
	mov	ecx, DWORD PTR _this$1$[esp+36]
	sub	eax, ebp
	push	esi
	push	eax
	push	ebx
	mov	DWORD PTR _dx$2$[esp+48], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1077 :         CheckMV2(workarea, dx + length, dy - length, &direction, 1 + 8);

	mov	esi, DWORD PTR _dy$2$[esp+24]
	lea	eax, DWORD PTR _direction$[esp+24]
	push	9
	push	eax
	sub	esi, ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$1$[esp+44]
	mov	ecx, edi
	push	ebx
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1078 :         CheckMV2(workarea, dx - length, dy - length, &direction, 2 + 8);

	lea	eax, DWORD PTR _direction$[esp+24]
	push	10					; 0000000aH
	push	eax
	mov	eax, DWORD PTR _dx$2$[esp+36]
$LN28@DiamondSea:
	push	esi
$LN29@DiamondSea:
	push	eax
$LN27@DiamondSea:
	push	ebx
	mov	ecx, edi
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	mov	ecx, DWORD PTR _direction$[esp+24]
	mov	DWORD PTR _lastDirection$1$[esp+28], ecx
	test	ecx, ecx
	jg	$LL2@DiamondSea
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1079 :         break;
; 1080 :       }
; 1081 :     }	// if ! direction
; 1082 :   }	// while direction > 0
; 1083 : }

	add	esp, 12					; 0000000cH
	ret	8
	npad	2
$LN31@DiamondSea:
	DD	$LN14@DiamondSea
	DD	$LN15@DiamondSea
	DD	$LN22@DiamondSea
	DD	$LN16@DiamondSea
	DD	$LN18@DiamondSea
	DD	$LN19@DiamondSea
	DD	$LN22@DiamondSea
	DD	$LN17@DiamondSea
	DD	$LN20@DiamondSea
	DD	$LN21@DiamondSea
?DiamondSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ENDP ; PlaneOfBlocks::DiamondSearch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?NStepSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z
_TEXT	SEGMENT
_vx$1$ = -32						; size = 4
_this$1$ = -28						; size = 4
tv1124 = -24						; size = 4
_dx$1$ = -20						; size = 4
_this$1$ = -16						; size = 4
$T1 = -12						; size = 4
tv1134 = -12						; size = 4
tv1125 = -12						; size = 4
tv1135 = -8						; size = 4
_sad$1$ = -8						; size = 4
_saduv$1$ = -8						; size = 4
_dy$1$ = -4						; size = 4
_vy$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
_stp$ = 12						; size = 4
?NStepSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z PROC ; PlaneOfBlocks::NStepSearch, COMDAT
; _this$ = ecx

; 1120 : {

	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx

; 1121 :   int dx, dy;
; 1122 :   int length = stp;
; 1123 :   while (length > 0)

	mov	ecx, DWORD PTR _stp$[esp+32]
	mov	DWORD PTR _this$1$[esp+36], ebx
	test	ecx, ecx
	jle	$LN3@NStepSearc
	push	ebp
	push	esi
	mov	esi, DWORD PTR _workarea$[esp+40]
	push	edi
	npad	3
$LL2@NStepSearc:

; 1124 :   {
; 1125 :     dx = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]

; 1126 :     dy = workarea.bestMV.y;

	mov	edi, DWORD PTR [esi+104]
	mov	DWORD PTR _dy$1$[esp+48], edi

; 1127 : 
; 1128 :     CheckMV(workarea, dx + length, dy + length);

	add	edi, ecx
	mov	DWORD PTR _dx$1$[esp+48], eax
	lea	ebp, DWORD PTR [eax+ecx]
	mov	DWORD PTR _vy$1$[esp+44], edi
	mov	DWORD PTR _vx$1$[esp+48], ebp

; 2482 :   return (

	cmp	ebp, DWORD PTR [esi+368]
	jl	$LN113@NStepSearc
	cmp	edi, DWORD PTR [esi+372]
	jl	$LN113@NStepSearc
	cmp	ebp, DWORD PTR [esi+376]
	jge	$LN113@NStepSearc
	cmp	edi, DWORD PTR [esi+380]
	jge	$LN113@NStepSearc

; 1676 :       !(chroma) ? 0 :

	cmp	BYTE PTR [ebx+122], 0
	jne	SHORT $LN9@NStepSearc
	mov	DWORD PTR _saduv$1$[esp+48], 0
	jmp	$LN10@NStepSearc
$LN9@NStepSearc:

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN19@NStepSearc
	mov	eax, DWORD PTR [ebx+164]
	mov	ecx, DWORD PTR [ebx+60]
	mov	edx, DWORD PTR _vx$1$[esp+48]
	sar	edi, cl
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR _this$1$[esp+48]
	mov	DWORD PTR _this$1$[esp+48], eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR tv1125[esp+48], edi
	mov	ecx, DWORD PTR [ecx+52]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	lea	ebx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR tv1124[esp+48], edx
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 1
	sar	edi, 1
	add	edx, edx
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	DWORD PTR tv1135[esp+48], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN114@NStepSearc
$LN19@NStepSearc:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR _this$1$[esp+48], eax
	jne	SHORT $LN17@NStepSearc
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, ebp
	mov	ecx, DWORD PTR [ebx+52]
	mov	ebp, DWORD PTR [esi+12]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+60]
	add	ebp, eax
	mov	DWORD PTR tv1124[esp+48], eax
	mov	eax, DWORD PTR [esi+24]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
	add	ebp, DWORD PTR [eax]
	mov	DWORD PTR tv1135[esp+48], ebp
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN18@NStepSearc
$LN17@NStepSearc:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebx+60]
	mov	eax, DWORD PTR [esi+24]
	mov	edx, DWORD PTR _vx$1$[esp+48]
	sar	edi, cl
	mov	ecx, DWORD PTR _this$1$[esp+48]
	mov	DWORD PTR tv1125[esp+48], edi
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [ecx+52]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1124[esp+48], edx
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	edi, 2
	mov	eax, DWORD PTR [ebp]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	add	eax, ebx
	mov	DWORD PTR tv1135[esp+48], eax
$LN114@NStepSearc:
	mov	edi, DWORD PTR tv1125[esp+48]
	mov	ebx, DWORD PTR _this$1$[esp+48]
$LN18@NStepSearc:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN46@NStepSearc
	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR tv1124[esp+48]
	lea	ebx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN115@NStepSearc
$LN46@NStepSearc:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+28]
	jne	SHORT $LN44@NStepSearc
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebp, DWORD PTR [esi+16]
	add	ebp, DWORD PTR tv1124[esp+48]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
	add	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN45@NStepSearc
$LN44@NStepSearc:
	mov	ecx, DWORD PTR tv1124[esp+48]
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN115@NStepSearc:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR _this$1$[esp+48]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ebp+52]
	imul	ebx, DWORD PTR [ebp+12]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	mov	ebp, eax
	mov	DWORD PTR tv1134[esp+48], eax
	add	ebp, ebx
	mov	ebx, DWORD PTR _this$1$[esp+48]
$LN45@NStepSearc:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1676 :       !(chroma) ? 0 :

	push	DWORD PTR [ebx+184]
	mov	eax, DWORD PTR [ebx+100]
	push	DWORD PTR tv1135[esp+52]
	push	DWORD PTR [ebx+172]
	push	DWORD PTR [esi+92]
	call	eax
	push	DWORD PTR [ebx+188]
	mov	ecx, DWORD PTR [ebx+100]
	mov	edi, eax
	push	ebp
	push	DWORD PTR [ebx+176]
	push	DWORD PTR [esi+96]
	call	ecx
	mov	ebp, DWORD PTR _vx$1$[esp+80]
	add	esp, 32					; 00000020H
	add	edi, eax
	mov	DWORD PTR _saduv$1$[esp+48], edi
	mov	edi, DWORD PTR _vy$1$[esp+44]
$LN10@NStepSearc:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN73@NStepSearc
	mov	eax, DWORD PTR [ebx+164]
	mov	ecx, DWORD PTR _vx$1$[esp+48]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN116@NStepSearc
$LN73@NStepSearc:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	jne	SHORT $LN71@NStepSearc
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	add	eax, ebp
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+48], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+48]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN72@NStepSearc
$LN71@NStepSearc:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR _vx$1$[esp+48]
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN116@NStepSearc:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	mov	ebp, DWORD PTR _vx$1$[esp+48]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	mov	edi, DWORD PTR _vy$1$[esp+44]
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+48]
$LN72@NStepSearc:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [ebx+216], 0
	jne	SHORT $LN98@NStepSearc
	push	DWORD PTR [ebx+180]
	mov	eax, DWORD PTR [ebx+80]
	push	ecx
	push	DWORD PTR [ebx+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN117@NStepSearc
$LN98@NStepSearc:
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN117@NStepSearc:
	mov	edx, eax

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	mov	ecx, 16					; 00000010H

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	eax, DWORD PTR [esi+120]

; 1680 :     sad += saduv;

	add	edx, DWORD PTR _saduv$1$[esp+48]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	eax, edi
	mov	edi, DWORD PTR [esi+116]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sub	ecx, DWORD PTR [esi+400]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	edi, ebp
	imul	edi, edi
	imul	eax, eax

; 1680 :     sad += saduv;

	mov	DWORD PTR _sad$1$[esp+48], edx

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	add	edi, eax

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	mov	eax, edx
	imul	DWORD PTR [ebx+236]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	imul	edi, DWORD PTR [esi+384]
	sar	edi, cl

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	mov	ecx, eax
	mov	eax, DWORD PTR _sad$1$[esp+48]
	add	edi, eax
	shrd	ecx, edx, 8
	add	ecx, edi
	sar	edx, 8

; 1682 : //		int cost = sad + sad*workarea.MotionDistorsion(vx, vy)/(nBlkSizeX*nBlkSizeY*4);
; 1683 : //		if (sad>bigSAD) { DebugPrintf("%d %d %d %d %d %d", workarea.blkIdx, vx, vy, workarea.nMinCost, cost, sad);}
; 1684 :     if (cost < workarea.nMinCost)

	cmp	ecx, DWORD PTR [esi+112]
	jge	SHORT $LN113@NStepSearc

; 1685 :     {
; 1686 :       workarea.bestMV.x = vx;

	mov	DWORD PTR [esi+100], ebp

; 1687 :       workarea.bestMV.y = vy;

	mov	ebp, DWORD PTR _vy$1$[esp+44]
	mov	DWORD PTR [esi+104], ebp

; 1688 :       workarea.nMinCost = cost;

	mov	DWORD PTR [esi+112], ecx

; 1689 :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], eax
	jmp	SHORT $LN7@NStepSearc
$LN113@NStepSearc:
	mov	ebp, DWORD PTR _vy$1$[esp+44]
$LN7@NStepSearc:

; 1129 :     CheckMV(workarea, dx + length, dy);

	mov	edi, DWORD PTR _dy$1$[esp+48]
	mov	ecx, DWORD PTR _vx$1$[esp+48]
	push	edi
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1130 :     CheckMV(workarea, dx + length, dy - length);

	sub	edi, DWORD PTR _stp$[esp+44]
	mov	ecx, ebx
	push	edi
	push	DWORD PTR _vx$1$[esp+52]
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1131 :     CheckMV(workarea, dx, dy - length);

	push	edi
	push	DWORD PTR _dx$1$[esp+52]
	mov	ecx, ebx
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1132 :     CheckMV(workarea, dx, dy + length);

	push	ebp
	push	DWORD PTR _dx$1$[esp+52]
	mov	ecx, ebx
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1133 :     CheckMV(workarea, dx - length, dy + length);

	mov	eax, DWORD PTR _dx$1$[esp+48]
	mov	ecx, ebx
	sub	eax, DWORD PTR _stp$[esp+44]
	push	ebp
	push	eax
	push	esi
	mov	DWORD PTR _dx$1$[esp+60], eax
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1134 :     CheckMV(workarea, dx - length, dy);

	push	DWORD PTR _dy$1$[esp+48]
	mov	ebp, DWORD PTR _dx$1$[esp+52]
	mov	ecx, ebx
	push	ebp
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1135 :     CheckMV(workarea, dx - length, dy - length);

	push	edi
	push	ebp
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1136 : 
; 1137 :     length--;

	mov	ecx, DWORD PTR _stp$[esp+44]
	dec	ecx
	mov	DWORD PTR _stp$[esp+44], ecx
	test	ecx, ecx
	jg	$LL2@NStepSearc
	pop	edi
	pop	esi
	pop	ebp
$LN3@NStepSearc:
	pop	ebx

; 1138 :   }
; 1139 : }

	add	esp, 32					; 00000020H
	ret	8
?NStepSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ENDP ; PlaneOfBlocks::NStepSearch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?OneTimeSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z
_TEXT	SEGMENT
_direction$ = -8					; size = 4
tv230 = -4						; size = 4
tv229 = 8						; size = 4
_dy$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
tv233 = 12						; size = 4
tv228 = 12						; size = 4
_length$ = 12						; size = 4
?OneTimeSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z PROC ; PlaneOfBlocks::OneTimeSearch, COMDAT
; _this$ = ecx

; 1144 : {

	sub	esp, 8
	push	ebx

; 1145 :   int direction = 0;
; 1146 :   int dx = workarea.bestMV.x;

	mov	ebx, DWORD PTR _workarea$[esp+8]

; 1147 :   int dy = workarea.bestMV.y;
; 1148 : 
; 1149 :   CheckMV2(workarea, dx - length, dy, &direction, 2);

	lea	edx, DWORD PTR _direction$[esp+12]
	push	ebp
	push	esi
	push	edi
	mov	esi, DWORD PTR [ebx+100]
	mov	ebp, ecx
	mov	ecx, DWORD PTR [ebx+104]
	mov	eax, esi
	mov	edi, DWORD PTR _length$[esp+20]
	sub	eax, edi
	push	2
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR _dy$1$[esp+36], ecx
	mov	ecx, ebp
	push	ebx
	mov	DWORD PTR _direction$[esp+44], 0
	mov	DWORD PTR tv230[esp+44], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1150 :   CheckMV2(workarea, dx + length, dy, &direction, 1);

	push	1
	lea	ecx, DWORD PTR _direction$[esp+28]
	push	ecx
	push	DWORD PTR _dy$1$[esp+28]
	lea	eax, DWORD PTR [esi+edi]
	mov	ecx, ebp
	push	eax
	push	ebx
	mov	DWORD PTR tv233[esp+40], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1151 : 
; 1152 :   if (direction == 1)

	mov	eax, DWORD PTR _direction$[esp+24]
	cmp	eax, 1
	jne	SHORT $LN10@OneTimeSea
$LL2@OneTimeSea:

; 1153 :   {
; 1154 :     while (direction)
; 1155 :     {
; 1156 :       direction = 0;
; 1157 :       dx += length;

	mov	esi, DWORD PTR tv233[esp+20]

; 1158 :       CheckMV2(workarea, dx + length, dy, &direction, 1);

	lea	ecx, DWORD PTR _direction$[esp+24]
	push	1
	push	ecx
	push	DWORD PTR _dy$1$[esp+28]
	lea	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR _direction$[esp+36], 0
	push	eax
	push	ebx
	mov	ecx, ebp
	mov	DWORD PTR tv233[esp+40], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	cmp	DWORD PTR _direction$[esp+24], 0
	jne	SHORT $LL2@OneTimeSea

; 1159 :     }
; 1160 :   }
; 1161 :   else if (direction == 2)

	jmp	SHORT $LN5@OneTimeSea
$LN10@OneTimeSea:
	cmp	eax, 2
	jne	SHORT $LN5@OneTimeSea
$LL4@OneTimeSea:

; 1162 :   {
; 1163 :     while (direction)
; 1164 :     {
; 1165 :       direction = 0;
; 1166 :       dx -= length;

	mov	eax, DWORD PTR tv230[esp+24]

; 1167 :       CheckMV2(workarea, dx - length, dy, &direction, 1);

	lea	ecx, DWORD PTR _direction$[esp+24]
	push	1
	push	ecx
	push	DWORD PTR _dy$1$[esp+28]
	sub	eax, edi
	mov	DWORD PTR _direction$[esp+36], 0
	push	eax
	push	ebx
	mov	ecx, ebp
	mov	DWORD PTR tv230[esp+44], eax
	sub	esi, edi
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	cmp	DWORD PTR _direction$[esp+24], 0
	jne	SHORT $LL4@OneTimeSea
$LN5@OneTimeSea:

; 1168 :     }
; 1169 :   }
; 1170 : 
; 1171 :   CheckMV2(workarea, dx, dy - length, &direction, 2);

	mov	eax, DWORD PTR _dy$1$[esp+20]
	lea	ecx, DWORD PTR _direction$[esp+24]
	push	2
	push	ecx
	sub	eax, edi
	mov	ecx, ebp
	push	eax
	push	esi
	push	ebx
	mov	DWORD PTR tv228[esp+40], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1172 :   CheckMV2(workarea, dx, dy + length, &direction, 1);

	mov	eax, DWORD PTR _dy$1$[esp+20]
	lea	ecx, DWORD PTR _direction$[esp+24]
	push	1
	push	ecx
	add	eax, edi
	mov	ecx, ebp
	push	eax
	push	esi
	push	ebx
	mov	DWORD PTR tv229[esp+40], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2

; 1173 : 
; 1174 :   if (direction == 1)

	mov	eax, DWORD PTR _direction$[esp+24]
	cmp	eax, 1
	jne	SHORT $LN13@OneTimeSea
$LL6@OneTimeSea:

; 1175 :   {
; 1176 :     while (direction)
; 1177 :     {
; 1178 :       direction = 0;
; 1179 :       dy += length;

	mov	eax, DWORD PTR tv229[esp+20]

; 1180 :       CheckMV2(workarea, dx, dy + length, &direction, 1);

	lea	ecx, DWORD PTR _direction$[esp+24]
	push	1
	push	ecx
	add	eax, edi
	mov	DWORD PTR _direction$[esp+32], 0
	push	eax
	push	esi
	push	ebx
	mov	ecx, ebp
	mov	DWORD PTR tv229[esp+40], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	cmp	DWORD PTR _direction$[esp+24], 0
	jne	SHORT $LL6@OneTimeSea
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1190 :     }
; 1191 :   }
; 1192 : }

	add	esp, 8
	ret	8
$LN13@OneTimeSea:

; 1181 :     }
; 1182 :   }
; 1183 :   else if (direction == 2)

	cmp	eax, 2
	jne	SHORT $LN9@OneTimeSea
	npad	4
$LL8@OneTimeSea:

; 1184 :   {
; 1185 :     while (direction)
; 1186 :     {
; 1187 :       direction = 0;
; 1188 :       dy -= length;

	mov	eax, DWORD PTR tv228[esp+20]

; 1189 :       CheckMV2(workarea, dx, dy - length, &direction, 1);

	lea	ecx, DWORD PTR _direction$[esp+24]
	push	1
	push	ecx
	sub	eax, edi
	mov	DWORD PTR _direction$[esp+32], 0
	push	eax
	push	esi
	push	ebx
	mov	ecx, ebp
	mov	DWORD PTR tv228[esp+40], eax
	call	?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMV2
	cmp	DWORD PTR _direction$[esp+24], 0
	jne	SHORT $LL8@OneTimeSea
$LN9@OneTimeSea:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1190 :     }
; 1191 :   }
; 1192 : }

	add	esp, 8
	ret	8
?OneTimeSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ENDP ; PlaneOfBlocks::OneTimeSearch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z
_TEXT	SEGMENT
_this$1$ = -36						; size = 4
_vy$1$ = -32						; size = 4
tv1185 = -28						; size = 4
_this$1$ = -24						; size = 4
tv1202 = -20						; size = 4
tv1195 = -20						; size = 4
$T1 = -16						; size = 4
tv1203 = -16						; size = 4
_i$1$ = -12						; size = 4
tv1191 = -8						; size = 4
tv1189 = -4						; size = 4
_j$1$ = -4						; size = 4
tv1187 = 8						; size = 4
tv1184 = 8						; size = 4
_sad$1$ = 8						; size = 4
_saduv$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
_r$ = 12						; size = 4
_s$ = 16						; size = 4
_mvx$ = 20						; size = 4
_mvy$ = 24						; size = 4
?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z PROC ; PlaneOfBlocks::ExpandingSearch, COMDAT
; _this$ = ecx

; 1197 : { // part of true enhaustive search (thin expanding square) around mvx, mvy

	sub	esp, 36					; 00000024H

; 1198 :   int i, j;
; 1199 :   //	VECTOR mv = workarea.bestMV; // bug: it was pointer assignent, not values, so iterative! - v2.1
; 1200 : 
; 1201 :     // sides of square without corners
; 1202 :   for (i = -r + s; i < r; i += s) // without corners! - v2.1

	mov	eax, DWORD PTR _r$[esp+32]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _s$[esp+40]
	mov	ebx, ecx
	sub	ebp, eax
	mov	DWORD PTR _this$1$[esp+44], ebx
	mov	edx, ebp
	mov	DWORD PTR _j$1$[esp+44], ebp
	mov	DWORD PTR _i$1$[esp+44], edx
	push	esi
	mov	esi, DWORD PTR _workarea$[esp+44]
	push	edi
	cmp	edx, eax
	jge	$LN3@ExpandingS
	mov	ecx, DWORD PTR _mvy$[esp+48]
	mov	edi, DWORD PTR _mvx$[esp+48]
	sub	ecx, eax
	add	eax, DWORD PTR _mvy$[esp+48]
	add	edi, edx
	mov	DWORD PTR _vy$1$[esp+52], ecx
	mov	DWORD PTR tv1191[esp+52], eax
	mov	DWORD PTR tv1185[esp+52], edi
	npad	7
$LL4@ExpandingS:

; 2482 :   return (

	cmp	edi, DWORD PTR [esi+368]
	jl	$LN11@ExpandingS
	cmp	ecx, DWORD PTR [esi+372]
	jl	$LN11@ExpandingS
	cmp	edi, DWORD PTR [esi+376]
	jge	$LN11@ExpandingS
	cmp	ecx, DWORD PTR [esi+380]
	jge	$LN11@ExpandingS

; 1676 :       !(chroma) ? 0 :

	cmp	BYTE PTR [ebx+122], 0
	jne	SHORT $LN13@ExpandingS
	mov	DWORD PTR _saduv$1$[esp+48], 0
	jmp	$LN14@ExpandingS
$LN13@ExpandingS:

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN23@ExpandingS
	mov	eax, DWORD PTR [ebx+164]
	mov	edx, ecx
	mov	ecx, DWORD PTR [ebx+60]
	sar	edx, cl
	mov	ecx, DWORD PTR _this$1$[esp+52]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR _this$1$[esp+52], eax
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+52]
	mov	DWORD PTR tv1195[esp+52], edx
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [esi+12]
	mov	edx, edi
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1184[esp+48], edx
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 1
	sar	edi, 1
	add	edx, edx
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	DWORD PTR tv1203[esp+52], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN118@ExpandingS
$LN23@ExpandingS:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR _this$1$[esp+52], eax
	jne	SHORT $LN21@ExpandingS
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, edi
	mov	ecx, DWORD PTR [ebx+52]
	mov	edi, DWORD PTR _vy$1$[esp+52]
	mov	ebp, DWORD PTR [esi+24]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+60]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	add	ebp, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebp, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1184[esp+48], eax
	mov	eax, DWORD PTR [esi+12]
	add	eax, DWORD PTR tv1184[esp+48]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	shl	eax, cl
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
	add	ebp, DWORD PTR [eax]
	mov	DWORD PTR tv1203[esp+52], ebp
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN22@ExpandingS
$LN21@ExpandingS:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, ecx
	mov	ecx, DWORD PTR [ebx+60]
	mov	eax, DWORD PTR [esi+24]
	sar	edx, cl
	mov	ecx, DWORD PTR _this$1$[esp+52]
	mov	DWORD PTR tv1195[esp+52], edx
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	edx, edi
	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [esi+12]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1184[esp+48], edx
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	edi, 2
	mov	eax, DWORD PTR [ebp]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	add	eax, ebx
	mov	DWORD PTR tv1203[esp+52], eax
$LN118@ExpandingS:
	mov	edi, DWORD PTR tv1195[esp+52]
	mov	ebx, DWORD PTR _this$1$[esp+52]
$LN22@ExpandingS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN50@ExpandingS
	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR tv1184[esp+48]
	lea	ebx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN119@ExpandingS
$LN50@ExpandingS:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+28]
	jne	SHORT $LN48@ExpandingS
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	mov	DWORD PTR tv1202[esp+52], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+16]
	add	eax, DWORD PTR tv1184[esp+48]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	shl	eax, cl
	mov	ecx, DWORD PTR tv1202[esp+52]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN49@ExpandingS
$LN48@ExpandingS:
	mov	ecx, DWORD PTR tv1184[esp+48]
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN119@ExpandingS:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR _this$1$[esp+52]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ebp+52]
	imul	ebx, DWORD PTR [ebp+12]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+52]
$LN49@ExpandingS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1676 :       !(chroma) ? 0 :

	push	DWORD PTR [ebx+188]
	mov	eax, DWORD PTR [ebx+100]
	push	ecx
	push	DWORD PTR [ebx+176]
	push	DWORD PTR [esi+96]
	call	eax
	push	DWORD PTR [ebx+184]
	mov	ecx, DWORD PTR [ebx+100]
	mov	ebp, eax
	push	DWORD PTR tv1203[esp+72]
	push	DWORD PTR [ebx+172]
	push	DWORD PTR [esi+92]
	call	ecx
	mov	edi, DWORD PTR tv1185[esp+84]
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR _vy$1$[esp+52]
	add	ebp, eax
	mov	DWORD PTR _saduv$1$[esp+48], ebp
$LN14@ExpandingS:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN77@ExpandingS
	mov	eax, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edi, DWORD PTR [edi+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN120@ExpandingS
$LN77@ExpandingS:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	jne	SHORT $LN75@ExpandingS
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	mov	ebp, DWORD PTR _vy$1$[esp+52]
	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+52], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, ebp
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN76@ExpandingS
$LN75@ExpandingS:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edi, DWORD PTR [edi+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN120@ExpandingS:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	mov	ebp, DWORD PTR _vy$1$[esp+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+52]
$LN76@ExpandingS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [ebx+216], 0
	jne	SHORT $LN102@ExpandingS
	push	DWORD PTR [ebx+180]
	mov	eax, DWORD PTR [ebx+80]
	push	ecx
	push	DWORD PTR [ebx+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN121@ExpandingS
$LN102@ExpandingS:
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN121@ExpandingS:

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	edi, DWORD PTR [esi+116]

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	mov	edx, eax

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	edi, DWORD PTR tv1185[esp+52]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	mov	ecx, 16					; 00000010H

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	eax, DWORD PTR [esi+120]

; 1680 :     sad += saduv;

	add	edx, DWORD PTR _saduv$1$[esp+48]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	eax, ebp

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sub	ecx, DWORD PTR [esi+400]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	imul	edi, edi
	imul	eax, eax

; 1680 :     sad += saduv;

	mov	DWORD PTR _sad$1$[esp+48], edx

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	add	edi, eax

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	mov	eax, edx
	imul	DWORD PTR [ebx+236]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	imul	edi, DWORD PTR [esi+384]
	sar	edi, cl

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	mov	ecx, eax
	mov	eax, DWORD PTR _sad$1$[esp+48]
	add	edi, eax
	shrd	ecx, edx, 8
	add	ecx, edi
	sar	edx, 8

; 1682 : //		int cost = sad + sad*workarea.MotionDistorsion(vx, vy)/(nBlkSizeX*nBlkSizeY*4);
; 1683 : //		if (sad>bigSAD) { DebugPrintf("%d %d %d %d %d %d", workarea.blkIdx, vx, vy, workarea.nMinCost, cost, sad);}
; 1684 :     if (cost < workarea.nMinCost)
; 1685 :     {
; 1686 :       workarea.bestMV.x = vx;

	mov	edi, DWORD PTR tv1185[esp+52]
	cmp	ecx, DWORD PTR [esi+112]
	jge	SHORT $LN11@ExpandingS
	mov	DWORD PTR [esi+100], edi

; 1687 :       workarea.bestMV.y = vy;

	mov	DWORD PTR [esi+104], ebp

; 1688 :       workarea.nMinCost = cost;

	mov	DWORD PTR [esi+112], ecx

; 1689 :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], eax
$LN11@ExpandingS:

; 1203 :   {
; 1204 :     CheckMV(workarea, mvx + i, mvy - r);
; 1205 :     CheckMV(workarea, mvx + i, mvy + r);

	push	DWORD PTR tv1191[esp+52]
	mov	ecx, ebx
	push	edi
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	mov	ecx, DWORD PTR _i$1$[esp+52]
	add	ecx, DWORD PTR _s$[esp+48]
	add	edi, DWORD PTR _s$[esp+48]
	mov	eax, DWORD PTR _r$[esp+48]
	cmp	ecx, eax
	mov	DWORD PTR _i$1$[esp+52], ecx
	mov	ecx, DWORD PTR _vy$1$[esp+52]
	mov	DWORD PTR tv1185[esp+52], edi
	jl	$LL4@ExpandingS
	mov	ebp, DWORD PTR _j$1$[esp+52]
$LN3@ExpandingS:

; 1206 :   }
; 1207 : 
; 1208 :   for (j = -r + s; j < r; j += s)

	cmp	ebp, eax
	jge	SHORT $LN6@ExpandingS
	mov	ecx, DWORD PTR _mvx$[esp+48]
	mov	edi, DWORD PTR _mvy$[esp+48]
	sub	ecx, eax
	add	eax, DWORD PTR _mvx$[esp+48]
	add	edi, ebp
	mov	DWORD PTR tv1189[esp+52], ecx
	mov	DWORD PTR tv1187[esp+48], eax
	npad	6
$LL7@ExpandingS:

; 1209 :   {
; 1210 :     CheckMV(workarea, mvx - r, mvy + j);

	push	edi
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1211 :     CheckMV(workarea, mvx + r, mvy + j);

	push	edi
	push	DWORD PTR tv1187[esp+52]
	mov	ecx, ebx
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	add	ebp, DWORD PTR _s$[esp+48]
	add	edi, DWORD PTR _s$[esp+48]
	mov	eax, DWORD PTR _r$[esp+48]
	mov	ecx, DWORD PTR tv1189[esp+52]
	cmp	ebp, eax
	jl	SHORT $LL7@ExpandingS
$LN6@ExpandingS:

; 1212 :   }
; 1213 : 
; 1214 :   // then corners - they are more far from cenrer
; 1215 :   CheckMV(workarea, mvx - r, mvy - r);

	mov	ebp, DWORD PTR _mvy$[esp+48]
	mov	ecx, ebx
	mov	edi, DWORD PTR _mvx$[esp+48]
	sub	ebp, eax
	push	ebp
	sub	edi, eax
	push	edi
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1216 :   CheckMV(workarea, mvx - r, mvy + r);

	mov	ebx, DWORD PTR _r$[esp+48]
	add	ebx, DWORD PTR _mvy$[esp+48]
	mov	ecx, DWORD PTR _this$1$[esp+52]
	push	ebx
	push	edi
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1217 :   CheckMV(workarea, mvx + r, mvy - r);

	mov	edi, DWORD PTR _r$[esp+48]
	add	edi, DWORD PTR _mvx$[esp+48]
	mov	ecx, DWORD PTR _this$1$[esp+52]
	push	ebp
	push	edi
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1218 :   CheckMV(workarea, mvx + r, mvy + r);

	mov	ecx, DWORD PTR _this$1$[esp+52]
	push	ebx
	push	edi
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1219 : }

	add	esp, 36					; 00000024H
	ret	20					; 00000014H
?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ENDP ; PlaneOfBlocks::ExpandingSearch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?Hex2Search@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z
_TEXT	SEGMENT
_dir$ = -12						; size = 4
_this$1$ = -8						; size = 4
_bmy$1$ = -4						; size = 4
_i$1$ = 8						; size = 4
_bmx$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
tv345 = 12						; size = 4
_i_me_range$ = 12					; size = 4
?Hex2Search@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z PROC ; PlaneOfBlocks::Hex2Search, COMDAT
; _this$ = ecx

; 1229 : {

	sub	esp, 12					; 0000000cH

; 1230 :   // adopted from x264
; 1231 :   int dir = -2;
; 1232 :   int bmx = workarea.bestMV.x;
; 1233 :   int bmy = workarea.bestMV.y;
; 1234 : 
; 1235 :   if (i_me_range > 1)

	cmp	DWORD PTR _i_me_range$[esp+8], 1
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _workarea$[esp+20]
	mov	DWORD PTR _this$1$[esp+24], ecx
	mov	DWORD PTR _dir$[esp+24], -2		; fffffffeH
	mov	ebx, DWORD PTR [esi+100]
	mov	ebp, DWORD PTR [esi+104]
	mov	DWORD PTR _bmx$1$[esp+20], ebx
	mov	DWORD PTR _bmy$1$[esp+24], ebp
	jle	$LN5@Hex2Search

; 1236 :   {
; 1237 :     /* hexagon */
; 1238 : //		COST_MV_X3_DIR( -2,0, -1, 2,  1, 2, costs   );
; 1239 : //		COST_MV_X3_DIR(  2,0,  1,-2, -1,-2, costs+3 );
; 1240 : //		COPY2_IF_LT( bcost, costs[0], dir, 0 );
; 1241 : //		COPY2_IF_LT( bcost, costs[1], dir, 1 );
; 1242 : //		COPY2_IF_LT( bcost, costs[2], dir, 2 );
; 1243 : //		COPY2_IF_LT( bcost, costs[3], dir, 3 );
; 1244 : //		COPY2_IF_LT( bcost, costs[4], dir, 4 );
; 1245 : //		COPY2_IF_LT( bcost, costs[5], dir, 5 );
; 1246 :     CheckMVdir(workarea, bmx - 2, bmy, &dir, 0);

	push	edi
	push	0
	lea	eax, DWORD PTR _dir$[esp+32]
	push	eax
	push	ebp
	lea	eax, DWORD PTR [ebx-2]
	push	eax
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1247 :     CheckMVdir(workarea, bmx - 1, bmy + 2, &dir, 1);

	mov	ecx, DWORD PTR _this$1$[esp+28]
	lea	eax, DWORD PTR _dir$[esp+28]
	push	1
	push	eax
	lea	edi, DWORD PTR [ebp+2]
	push	edi
	lea	ebp, DWORD PTR [ebx-1]
	push	ebp
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1248 :     CheckMVdir(workarea, bmx + 1, bmy + 2, &dir, 2);

	mov	ecx, DWORD PTR _this$1$[esp+28]
	lea	eax, DWORD PTR _dir$[esp+28]
	push	2
	push	eax
	push	edi
	inc	ebx
	push	ebx
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1249 :     CheckMVdir(workarea, bmx + 2, bmy, &dir, 3);

	mov	edi, DWORD PTR _bmy$1$[esp+28]
	lea	eax, DWORD PTR _dir$[esp+28]
	mov	ecx, DWORD PTR _this$1$[esp+28]
	push	3
	push	eax
	mov	eax, DWORD PTR _bmx$1$[esp+32]
	push	edi
	add	eax, 2
	push	eax
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1250 :     CheckMVdir(workarea, bmx + 1, bmy - 2, &dir, 4);

	mov	ecx, DWORD PTR _this$1$[esp+28]
	lea	eax, DWORD PTR _dir$[esp+28]
	push	4
	push	eax
	add	edi, -2					; fffffffeH
	push	edi
	push	ebx
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1251 :     CheckMVdir(workarea, bmx - 1, bmy - 2, &dir, 5);

	mov	ecx, DWORD PTR _this$1$[esp+28]
	lea	eax, DWORD PTR _dir$[esp+28]
	push	5
	push	eax
	push	edi
	push	ebp
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1252 : 
; 1253 : 
; 1254 :     if (dir != -2)

	mov	edi, DWORD PTR _dir$[esp+28]

; 1255 :     {
; 1256 :       bmx += hex2[dir + 1][0];

	mov	ebx, DWORD PTR _bmx$1$[esp+24]

; 1257 :       bmy += hex2[dir + 1][1];

	mov	ebp, DWORD PTR _bmy$1$[esp+28]
	cmp	edi, -2					; fffffffeH
	je	$LN11@Hex2Search

; 1258 :       /* half hexagon, not overlapping the previous iteration */
; 1259 :       for (int i = 1; i < i_me_range / 2 && workarea.IsVectorOK(bmx, bmy); i++)

	mov	eax, DWORD PTR _i_me_range$[esp+24]
	add	ebx, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+8]
	add	ebp, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+12]
	cdq
	sub	eax, edx
	mov	DWORD PTR _i$1$[esp+24], 1
	sar	eax, 1
	mov	DWORD PTR tv345[esp+24], eax
	cmp	eax, 1
	jle	$LN11@Hex2Search
	npad	9
$LL4@Hex2Search:

; 2482 :   return (

	cmp	ebx, DWORD PTR [esi+368]
	jl	$LN11@Hex2Search
	cmp	ebp, DWORD PTR [esi+372]
	jl	$LN11@Hex2Search
	cmp	ebx, DWORD PTR [esi+376]
	jge	$LN11@Hex2Search
	cmp	ebp, DWORD PTR [esi+380]
	jge	$LN11@Hex2Search

; 1260 :       {
; 1261 :         const int odir = mod6m1[dir + 1];
; 1262 :         //				COST_MV_X3_DIR (hex2[odir+0][0], hex2[odir+0][1],
; 1263 :         //				                hex2[odir+1][0], hex2[odir+1][1],
; 1264 :         //				                hex2[odir+2][0], hex2[odir+2][1],
; 1265 :         //				                costs);
; 1266 : 
; 1267 :         dir = -2;
; 1268 :         //				COPY2_IF_LT( bcost, costs[0], dir, odir-1 );
; 1269 :         //				COPY2_IF_LT( bcost, costs[1], dir, odir   );
; 1270 :         //				COPY2_IF_LT( bcost, costs[2], dir, odir+1 );
; 1271 : 
; 1272 :         CheckMVdir(workarea, bmx + hex2[odir + 0][0], bmy + hex2[odir + 0][1], &dir, odir - 1);

	mov	edi, DWORD PTR ?mod6m1@@3QBHB[edi*4+4]
	mov	ecx, DWORD PTR _this$1$[esp+28]
	mov	DWORD PTR _dir$[esp+28], -2		; fffffffeH
	lea	eax, DWORD PTR [edi-1]
	push	eax
	lea	eax, DWORD PTR _dir$[esp+32]
	push	eax
	mov	eax, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+4]
	add	eax, ebp
	push	eax
	mov	eax, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8]
	add	eax, ebx
	push	eax
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1273 :         CheckMVdir(workarea, bmx + hex2[odir + 1][0], bmy + hex2[odir + 1][1], &dir, odir);

	mov	ecx, DWORD PTR _this$1$[esp+28]
	lea	eax, DWORD PTR _dir$[esp+28]
	push	edi
	push	eax
	mov	eax, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+12]
	add	eax, ebp
	push	eax
	mov	eax, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+8]
	add	eax, ebx
	push	eax
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1274 :         CheckMVdir(workarea, bmx + hex2[odir + 2][0], bmy + hex2[odir + 2][1], &dir, odir + 1);

	mov	ecx, DWORD PTR _this$1$[esp+28]
	lea	eax, DWORD PTR [edi+1]
	push	eax
	lea	eax, DWORD PTR _dir$[esp+32]
	push	eax
	mov	eax, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+20]
	add	eax, ebp
	push	eax
	mov	eax, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+16]
	add	eax, ebx
	push	eax
	push	esi
	call	?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ; PlaneOfBlocks::CheckMVdir

; 1275 :         if (dir == -2)

	mov	edi, DWORD PTR _dir$[esp+28]
	cmp	edi, -2					; fffffffeH
	je	SHORT $LN11@Hex2Search

; 1276 :         {
; 1277 :           break;
; 1278 :         }
; 1279 :         bmx += hex2[dir + 1][0];

	mov	ecx, DWORD PTR _i$1$[esp+24]
	add	ebx, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+8]
	inc	ecx

; 1280 :         bmy += hex2[dir + 1][1];

	add	ebp, DWORD PTR ?hex2@@3QAY01$$CBHA[edi*8+12]
	mov	DWORD PTR _i$1$[esp+24], ecx
	cmp	ecx, DWORD PTR tv345[esp+24]
	jl	$LL4@Hex2Search
$LN11@Hex2Search:
	mov	ecx, DWORD PTR _this$1$[esp+28]

; 1281 :       }
; 1282 :     }
; 1283 : 
; 1284 :     workarea.bestMV.x = bmx;

	mov	DWORD PTR [esi+100], ebx

; 1285 :     workarea.bestMV.y = bmy;

	mov	DWORD PTR [esi+104], ebp
	pop	edi
$LN5@Hex2Search:

; 1286 :   }
; 1287 : 
; 1288 :   // square refine
; 1289 : //	omx = bmx; omy = bmy;
; 1290 : //	COST_MV_X4(  0,-1,  0,1, -1,0, 1,0 );
; 1291 : //	COST_MV_X4( -1,-1, -1,1, 1,-1, 1,1 );
; 1292 :   ExpandingSearch(workarea, 1, 1, bmx, bmy);

	push	ebp
	push	ebx
	push	1
	push	1
	push	esi
	call	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch
	pop	esi
	pop	ebp
	pop	ebx

; 1293 : }

	add	esp, 12					; 0000000cH
	ret	8
?Hex2Search@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ENDP ; PlaneOfBlocks::Hex2Search
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?CrossSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHHH@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
_i$1$ = -20						; size = 4
_this$1$ = -16						; size = 4
tv1193 = -12						; size = 4
tv1198 = -8						; size = 4
$T1 = -4						; size = 4
tv1205 = -4						; size = 4
tv1204 = 8						; size = 4
tv1192 = 8						; size = 4
_cost$1$ = 8						; size = 4
_sad$1$ = 8						; size = 4
_saduv$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
_start$dead$ = 12					; size = 4
_x_max$ = 16						; size = 4
_y_max$ = 20						; size = 4
_mvx$ = 24						; size = 4
tv1203 = 28						; size = 4
_mvy$ = 28						; size = 4
?CrossSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHHH@Z PROC ; PlaneOfBlocks::CrossSearch, COMDAT
; _this$ = ecx

; 1298 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 1299 :   // part of umh  search
; 1300 :   for (int i = start; i < x_max; i += 2)

	mov	esi, DWORD PTR _workarea$[esp+32]
	mov	ebp, 1
	mov	ebx, ecx
	mov	DWORD PTR _i$1$[esp+36], ebp
	push	edi
	mov	edi, DWORD PTR _mvy$[esp+36]
	mov	DWORD PTR _this$1$[esp+40], ebx
	cmp	DWORD PTR _x_max$[esp+36], ebp
	jle	$LN3@CrossSearc
	mov	ecx, DWORD PTR _mvx$[esp+36]
	lea	edx, DWORD PTR [ecx-1]
	mov	DWORD PTR tv1193[esp+40], edx
$LL4@CrossSearc:

; 2482 :   return (

	cmp	edx, DWORD PTR [esi+368]
	jl	$LN11@CrossSearc
	cmp	edi, DWORD PTR [esi+372]
	jl	$LN11@CrossSearc
	cmp	edx, DWORD PTR [esi+376]
	jge	$LN11@CrossSearc
	cmp	edi, DWORD PTR [esi+380]
	jge	$LN11@CrossSearc

; 1676 :       !(chroma) ? 0 :

	cmp	BYTE PTR [ebx+122], 0
	jne	SHORT $LN13@CrossSearc
	mov	DWORD PTR _saduv$1$[esp+36], 0
	jmp	$LN14@CrossSearc
$LN13@CrossSearc:

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN23@CrossSearc
	mov	eax, DWORD PTR [ebx+164]
	mov	ecx, DWORD PTR [ebx+60]
	sar	edi, cl
	mov	ecx, DWORD PTR _this$1$[esp+40]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR _this$1$[esp+40], eax
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ecx+52]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	lea	ebx, DWORD PTR [edi+eax*2]
	mov	DWORD PTR tv1198[esp+40], edi
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR tv1192[esp+36], edx
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 1
	sar	edi, 1
	add	edx, edx
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	DWORD PTR tv1205[esp+40], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN119@CrossSearc
$LN23@CrossSearc:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR _this$1$[esp+40], eax
	jne	SHORT $LN21@CrossSearc
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR tv1193[esp+40]
	mov	ecx, DWORD PTR [ebx+52]
	mov	ebp, DWORD PTR [esi+12]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+60]
	add	ebp, eax
	mov	DWORD PTR tv1192[esp+36], eax
	mov	eax, DWORD PTR [esi+24]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
	add	ebp, DWORD PTR [eax]
	mov	DWORD PTR tv1205[esp+40], ebp
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN22@CrossSearc
$LN21@CrossSearc:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebx+60]
	mov	eax, DWORD PTR [esi+24]
	sar	edi, cl
	mov	ecx, DWORD PTR _this$1$[esp+40]
	mov	DWORD PTR tv1198[esp+40], edi
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [ecx+52]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1192[esp+36], edx
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	edi, 2
	mov	eax, DWORD PTR [ebp]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	add	eax, ebx
	mov	DWORD PTR tv1205[esp+40], eax
$LN119@CrossSearc:
	mov	edi, DWORD PTR tv1198[esp+40]
	mov	ebx, DWORD PTR _this$1$[esp+40]
$LN22@CrossSearc:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN50@CrossSearc
	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR tv1192[esp+36]
	lea	ebx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN120@CrossSearc
$LN50@CrossSearc:
	cmp	eax, 1
	jne	SHORT $LN48@CrossSearc
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+16]
	add	eax, DWORD PTR tv1192[esp+36]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR tv1204[esp+36], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR tv1204[esp+36]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN49@CrossSearc
$LN48@CrossSearc:
	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR tv1192[esp+36]
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN120@CrossSearc:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR _this$1$[esp+40]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ebp+52]
	imul	ebx, DWORD PTR [ebp+12]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+40]
$LN49@CrossSearc:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1676 :       !(chroma) ? 0 :

	push	DWORD PTR [ebx+188]
	mov	eax, DWORD PTR [ebx+100]
	push	ecx
	push	DWORD PTR [ebx+176]
	push	DWORD PTR [esi+96]
	call	eax
	push	DWORD PTR [ebx+184]
	mov	ecx, DWORD PTR [ebx+100]
	mov	ebp, eax
	push	DWORD PTR tv1205[esp+60]
	push	DWORD PTR [ebx+172]
	push	DWORD PTR [esi+92]
	call	ecx
	mov	edi, DWORD PTR _mvy$[esp+68]
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR _mvx$[esp+36]
	add	ebp, eax
	mov	DWORD PTR _saduv$1$[esp+36], ebp
	mov	ebp, DWORD PTR _i$1$[esp+40]
$LN14@CrossSearc:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 2
	jne	SHORT $LN77@CrossSearc
	mov	eax, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [edi+eax*2]
	mov	edi, DWORD PTR [esi+8]
	add	edi, edi
	mov	edx, ebx
	sub	edi, DWORD PTR _i$1$[esp+40]
	and	edx, 1
	add	edi, ecx
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN121@CrossSearc
$LN77@CrossSearc:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	jne	SHORT $LN75@CrossSearc
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ebp
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+40], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN76@CrossSearc
$LN75@CrossSearc:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR [esi+8]
	shl	edi, 2
	mov	edx, ebx
	sub	edi, DWORD PTR _i$1$[esp+40]
	and	edx, 3
	add	edi, ecx
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
	mov	eax, edi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN121@CrossSearc:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	mov	ebp, DWORD PTR _i$1$[esp+40]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+40]
$LN76@CrossSearc:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [ebx+216], 0
	jne	SHORT $LN102@CrossSearc
	push	DWORD PTR [ebx+180]
	mov	eax, DWORD PTR [ebx+80]
	push	ecx
	push	DWORD PTR [ebx+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN122@CrossSearc
$LN102@CrossSearc:
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN122@CrossSearc:

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	edi, DWORD PTR [esi+120]

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	mov	edx, eax

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	edi, DWORD PTR _mvy$[esp+36]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	mov	ecx, 16					; 00000010H

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	eax, DWORD PTR [esi+116]
	sub	eax, DWORD PTR _mvx$[esp+36]

; 1680 :     sad += saduv;

	add	edx, DWORD PTR _saduv$1$[esp+36]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	add	eax, ebp

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sub	ecx, DWORD PTR [esi+400]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	imul	edi, edi
	imul	eax, eax

; 1680 :     sad += saduv;

	mov	DWORD PTR _sad$1$[esp+36], edx

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	add	edi, eax

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	mov	eax, edx

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	imul	edi, DWORD PTR [esi+384]

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	imul	DWORD PTR [ebx+236]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sar	edi, cl

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	mov	ecx, DWORD PTR _sad$1$[esp+36]
	add	edi, ecx
	shrd	eax, edx, 8
	add	eax, edi
	sar	edx, 8

; 1687 :       workarea.bestMV.y = vy;

	mov	edi, DWORD PTR _mvy$[esp+36]
	mov	DWORD PTR _cost$1$[esp+36], eax
	cmp	eax, DWORD PTR [esi+112]
	jge	SHORT $LN118@CrossSearc

; 1682 : //		int cost = sad + sad*workarea.MotionDistorsion(vx, vy)/(nBlkSizeX*nBlkSizeY*4);
; 1683 : //		if (sad>bigSAD) { DebugPrintf("%d %d %d %d %d %d", workarea.blkIdx, vx, vy, workarea.nMinCost, cost, sad);}
; 1684 :     if (cost < workarea.nMinCost)
; 1685 :     {
; 1686 :       workarea.bestMV.x = vx;

	mov	eax, DWORD PTR tv1193[esp+40]
	mov	DWORD PTR [esi+100], eax

; 1688 :       workarea.nMinCost = cost;

	mov	eax, DWORD PTR _cost$1$[esp+36]
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi+112], eax

; 1689 :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], ecx
$LN118@CrossSearc:
	mov	ecx, DWORD PTR _mvx$[esp+36]
$LN11@CrossSearc:

; 1301 :   {
; 1302 :     CheckMV(workarea, mvx - i, mvy);
; 1303 :     CheckMV(workarea, mvx + i, mvy);

	push	edi
	lea	eax, DWORD PTR [ecx+ebp]
	mov	ecx, ebx
	push	eax
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	mov	edx, DWORD PTR tv1193[esp+40]
	add	ebp, 2
	mov	ecx, DWORD PTR _mvx$[esp+36]
	sub	edx, 2
	mov	DWORD PTR _i$1$[esp+40], ebp
	mov	DWORD PTR tv1193[esp+40], edx
	cmp	ebp, DWORD PTR _x_max$[esp+36]
	jl	$LL4@CrossSearc
$LN3@CrossSearc:

; 1304 :   }
; 1305 : 
; 1306 :   for (int j = start; j < y_max; j += 2)

	mov	eax, DWORD PTR _y_max$[esp+36]
	cmp	eax, 1
	jle	SHORT $LN6@CrossSearc
	mov	ebp, DWORD PTR _mvx$[esp+36]
	add	eax, -2					; fffffffeH
	shr	eax, 1
	inc	edi
	inc	eax
	mov	DWORD PTR tv1203[esp+36], eax
$LL7@CrossSearc:

; 1307 :   {
; 1308 :     CheckMV(workarea, mvx, mvy + j);

	push	edi
	push	ebp
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 1309 :     CheckMV(workarea, mvx, mvy + j);

	push	edi
	push	ebp
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	add	edi, 2
	sub	DWORD PTR tv1203[esp+36], 1
	jne	SHORT $LL7@CrossSearc
$LN6@CrossSearc:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1310 :   }
; 1311 : }

	add	esp, 24					; 00000018H
	ret	24					; 00000018H
?CrossSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHHH@Z ENDP ; PlaneOfBlocks::CrossSearch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z
_TEXT	SEGMENT
tv236 = 8						; size = 4
_workarea$ = 8						; size = 4
_i_me_range$ = 12					; size = 4
_omx$ = 16						; size = 4
_omy$ = 20						; size = 4
?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z PROC ; PlaneOfBlocks::UMHSearch, COMDAT
; _this$ = ecx

; 1315 : {

	push	ebx
	push	ebp

; 1316 :   // Uneven-cross Multi-Hexagon-grid Search (see x264)
; 1317 :   /* hexagon grid */
; 1318 : 
; 1319 : //	int omx = workarea.bestMV.x;
; 1320 : //	int omy = workarea.bestMV.y;
; 1321 :   // my mod: do not shift the center after Cross
; 1322 :   CrossSearch(workarea, 1, i_me_range, i_me_range, omx, omy);

	mov	ebp, DWORD PTR _workarea$[esp+4]
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR _i_me_range$[esp+8]
	push	edi
	push	DWORD PTR _omy$[esp+12]
	push	DWORD PTR _omx$[esp+16]
	push	esi
	push	esi
	push	ecx
	push	ebp
	call	?CrossSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHHH@Z ; PlaneOfBlocks::CrossSearch
	mov	eax, esi

; 1323 : 
; 1324 :   int i = 1;

	mov	edi, 1
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv236[esp+12], eax
$LL4@UMHSearch:

; 1325 :   do
; 1326 :   {
; 1327 :     static const int hex4[16][2] =
; 1328 :     {
; 1329 :       {-4, 2}, {-4, 1}, {-4, 0}, {-4,-1}, {-4,-2},
; 1330 :       { 4,-2}, { 4,-1}, { 4, 0}, { 4, 1}, { 4, 2},
; 1331 :       { 2, 3}, { 0, 4}, {-2, 3},
; 1332 :       {-2,-3}, { 0,-4}, { 2,-3},
; 1333 :     };
; 1334 : 
; 1335 :     for (int j = 0; j < 16; j++)

	mov	esi, OFFSET ?hex4@?3??UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@2@HHH@Z@4QAY01$$CBHA
$LL7@UMHSearch:

; 1336 :     {
; 1337 :       int mx = omx + hex4[j][0] * i;
; 1338 :       int my = omy + hex4[j][1] * i;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	imul	ecx, edi
	imul	eax, edi
	add	ecx, DWORD PTR _omy$[esp+12]
	add	eax, DWORD PTR _omx$[esp+12]

; 1339 :       CheckMV(workarea, mx, my);

	push	ecx
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	add	esi, 8
	cmp	esi, OFFSET ?hex4@?3??UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@2@HHH@Z@4QAY01$$CBHA+128
	jl	SHORT $LL7@UMHSearch

; 1340 :     }
; 1341 :   } while (++i <= i_me_range / 4);

	inc	edi
	cmp	edi, DWORD PTR tv236[esp+12]
	jle	SHORT $LL4@UMHSearch

; 1342 : 
; 1343 :   //	if( bmy <= mv_y_max )
; 1344 :   // {
; 1345 :   //		goto me_hex2;
; 1346 :   //	}
; 1347 : 
; 1348 :   Hex2Search(workarea, i_me_range);

	push	DWORD PTR _i_me_range$[esp+12]
	mov	ecx, ebx
	push	ebp
	call	?Hex2Search@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::Hex2Search
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1349 : }

	ret	16					; 00000010H
?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z ENDP ; PlaneOfBlocks::UMHSearch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?estimate_global_mv_doubled_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z
_TEXT	SEGMENT
tv830 = -24						; size = 4
_freqSize$1$ = -24					; size = 4
_medianx$1$ = -20					; size = 4
_y$1$ = -20						; size = 4
_meanvy$1$ = -16					; size = 4
_freq_arr$1$ = -16					; size = 4
tv827 = -12						; size = 4
tv826 = -12						; size = 4
_meanvx$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
$T1 = -4						; size = 4
tv836 = -4						; size = 4
tv835 = -4						; size = 4
_mediany$1$ = -4					; size = 4
_td$ = 8						; size = 4
?estimate_global_mv_doubled_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z PROC ; PlaneOfBlocks::estimate_global_mv_doubled_slice, COMDAT
; _this$ = ecx

; 1377 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH

; 1378 :   bool				both_done_flag = false;
; 1379 :   for (int y = td._y_beg; y < td._y_end; ++y)

	mov	eax, DWORD PTR _td$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _this$1$[esp+40], edi
	mov	DWORD PTR _y$1$[esp+40], ecx
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN29@estimate_g
$LL4@estimate_g:
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	ecx, DWORD PTR [ecx+11]
	lea	eax, DWORD PTR [ecx+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi+eax*4]
	mov	ebx, DWORD PTR [edi+eax*4+4]
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	eax, DWORD PTR [edi+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	ebx, ecx
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	mov	DWORD PTR _freq_arr$1$[esp+40], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	ebx, 2
	mov	DWORD PTR _freqSize$1$[esp+40], ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1384 :     memset(&freq_arr[0], 0, freqSize * sizeof(freq_arr[0])); // reset

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	push	0
	push	ecx
	call	_memset

; 1385 : 
; 1386 :     int            indmin = freqSize - 1;

	lea	esi, DWORD PTR [ebx-1]

; 1387 :     int            indmax = 0;

	xor	edx, edx
	add	esp, 12					; 0000000cH

; 1388 : 
; 1389 :     // find most frequent x
; 1390 :     if (y == 0)
; 1391 :     {
; 1392 :       for (int i = 0; i < nBlkCount; i++)

	xor	ebx, ebx
	cmp	DWORD PTR _y$1$[esp+40], edx
	jne	SHORT $LN17@estimate_g
	cmp	DWORD PTR [edi+16], edx
	jle	$LN9@estimate_g
	mov	eax, DWORD PTR _freqSize$1$[esp+40]
	sar	eax, 1
	xor	ecx, ecx
	mov	DWORD PTR tv836[esp+40], eax
	mov	DWORD PTR tv827[esp+40], ecx
	npad	5
$LL7@estimate_g:

; 1393 :       {
; 1394 :         int ind = (freqSize >> 1) + vectors[i].x;

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [ecx+eax]
	add	ecx, DWORD PTR tv836[esp+40]

; 1395 :         if (ind >= 0 && ind < freqSize)

	js	SHORT $LN5@estimate_g
	cmp	ecx, DWORD PTR _freqSize$1$[esp+40]
	jge	SHORT $LN5@estimate_g
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _freq_arr$1$[esp+40]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1397 :           ++freq_arr[ind];

	inc	DWORD PTR [eax+ecx*4]
	cmp	ecx, edx
	mov	eax, ecx
	cmovle	eax, edx
	mov	edx, eax

; 1398 :           if (ind > indmax)
; 1399 :           {
; 1400 :             indmax = ind;
; 1401 :           }
; 1402 :           if (ind < indmin)

	cmp	ecx, esi
	jge	SHORT $LN5@estimate_g

; 1403 :           {
; 1404 :             indmin = ind;

	mov	esi, ecx
$LN5@estimate_g:

; 1388 : 
; 1389 :     // find most frequent x
; 1390 :     if (y == 0)
; 1391 :     {
; 1392 :       for (int i = 0; i < nBlkCount; i++)

	mov	ecx, DWORD PTR tv827[esp+40]
	inc	ebx
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR tv827[esp+40], ecx
	cmp	ebx, DWORD PTR [edi+16]
	jl	SHORT $LL7@estimate_g

; 1405 :           }
; 1406 :         }
; 1407 :       }
; 1408 :     }
; 1409 : 
; 1410 :     // find most frequent y
; 1411 :     else

	jmp	SHORT $LN9@estimate_g
$LN17@estimate_g:

; 1412 :     {
; 1413 :       for (int i = 0; i < nBlkCount; i++)

	cmp	DWORD PTR [edi+16], edx
	jle	SHORT $LN9@estimate_g
	mov	eax, DWORD PTR _freqSize$1$[esp+40]
	sar	eax, 1
	xor	ecx, ecx
	mov	DWORD PTR tv835[esp+40], eax
	mov	DWORD PTR tv826[esp+40], ecx
$LL10@estimate_g:

; 1414 :       {
; 1415 :         int ind = (freqSize >> 1) + vectors[i].y;

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [ecx+eax+4]
	add	ecx, DWORD PTR tv835[esp+40]

; 1416 :         if (ind >= 0 && ind < freqSize)

	js	SHORT $LN8@estimate_g
	cmp	ecx, DWORD PTR _freqSize$1$[esp+40]
	jge	SHORT $LN8@estimate_g
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _freq_arr$1$[esp+40]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1418 :           ++freq_arr[ind];

	inc	DWORD PTR [eax+ecx*4]
	cmp	ecx, edx
	mov	eax, ecx
	cmovle	eax, edx
	mov	edx, eax

; 1419 :           if (ind > indmax)
; 1420 :           {
; 1421 :             indmax = ind;
; 1422 :           }
; 1423 :           if (ind < indmin)

	cmp	ecx, esi
	jge	SHORT $LN8@estimate_g

; 1424 :           {
; 1425 :             indmin = ind;

	mov	esi, ecx
$LN8@estimate_g:

; 1412 :     {
; 1413 :       for (int i = 0; i < nBlkCount; i++)

	mov	ecx, DWORD PTR tv826[esp+40]
	inc	ebx
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR tv826[esp+40], ecx
	cmp	ebx, DWORD PTR [edi+16]
	jl	SHORT $LL10@estimate_g
$LN9@estimate_g:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _freq_arr$1$[esp+40]
	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1433 :     for (int i = indmin + 1; i <= indmax; i++)

	lea	eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	DWORD PTR $T1[esp+40], ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1431 :     int count = freq_arr[indmin];

	mov	ebx, DWORD PTR [ebx+esi*4]

; 1433 :     for (int i = indmin + 1; i <= indmax; i++)

	cmp	eax, edx
	jg	SHORT $LN12@estimate_g
	mov	edi, DWORD PTR $T1[esp+40]
$LL219@estimate_g:

; 1434 :     {
; 1435 :       if (freq_arr[i] > count)

	mov	ecx, DWORD PTR [edi+eax*4]
	cmp	ecx, ebx
	jle	SHORT $LN220@estimate_g

; 1436 :       {
; 1437 :         count = freq_arr[i];

	mov	ebx, ecx

; 1438 :         index = i;

	mov	esi, eax
$LN220@estimate_g:

; 1433 :     for (int i = indmin + 1; i <= indmax; i++)

	inc	eax
	cmp	eax, edx
	jle	SHORT $LL219@estimate_g
	mov	edi, DWORD PTR _this$1$[esp+40]
$LN12@estimate_g:

; 1439 :       }
; 1440 :     }
; 1441 : 
; 1442 :     // most frequent value
; 1443 :     _gvect_estim_ptr->coord[y] = index - (freqSize >> 1);

	mov	eax, DWORD PTR _freqSize$1$[esp+40]
	lea	ebx, DWORD PTR [edi+764]
	mov	ecx, DWORD PTR _y$1$[esp+40]
	sar	eax, 1
	sub	esi, eax
	mov	eax, DWORD PTR [edi+760]
	mov	DWORD PTR [eax+ecx*4], esi
$LL149@estimate_g:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [ebx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	lea	esi, DWORD PTR [edx-1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, esi
	lock	 cmpxchg DWORD PTR [ebx], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL149@estimate_g
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1448 :     both_done_flag = (new_count <= 0);

	mov	ecx, DWORD PTR _y$1$[esp+40]
	test	esi, esi
	mov	edx, DWORD PTR _td$[ebp]
	setle	al
	inc	ecx
	mov	DWORD PTR _y$1$[esp+40], ecx
	cmp	ecx, DWORD PTR [edx+12]
	jl	$LL4@estimate_g

; 1449 :   }
; 1450 : 
; 1451 :   // iteration to increase precision
; 1452 :   if (both_done_flag)

	test	al, al
	je	$LN29@estimate_g

; 1453 :   {
; 1454 :     int medianx = _gvect_estim_ptr->x;

	mov	eax, DWORD PTR [edi+760]

; 1455 :     int mediany = _gvect_estim_ptr->y;
; 1456 :     int meanvx = 0;
; 1457 :     int meanvy = 0;
; 1458 :     int num = 0;

	xor	esi, esi
	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR tv830[esp+40], eax
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _mediany$1$[esp+40], eax
	xor	eax, eax
	mov	DWORD PTR _medianx$1$[esp+40], edx
	mov	DWORD PTR _meanvy$1$[esp+40], eax

; 1459 :     for (int i = 0; i < nBlkCount; i++)

	test	ebx, ebx
	jle	SHORT $LN28@estimate_g
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [edi+108]
	xor	edi, edi
$LL222@estimate_g:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1462 :         && abs(vectors[i].y - mediany) < 6)

	mov	eax, DWORD PTR [ecx]
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 6
	jge	SHORT $LN223@estimate_g
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR _mediany$1$[esp+40]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 6
	jge	SHORT $LN223@estimate_g

; 1463 :       {
; 1464 :         meanvx += vectors[i].x;
; 1465 :         meanvy += vectors[i].y;

	mov	eax, DWORD PTR _meanvy$1$[esp+40]
	add	eax, DWORD PTR [ecx+4]
	add	edi, DWORD PTR [ecx]

; 1466 :         num += 1;

	inc	esi
	mov	DWORD PTR _meanvy$1$[esp+40], eax
$LN223@estimate_g:

; 1459 :     for (int i = 0; i < nBlkCount; i++)

	mov	edx, DWORD PTR _medianx$1$[esp+40]
	add	ecx, 12					; 0000000cH
	sub	ebx, 1
	jne	SHORT $LL222@estimate_g

; 1467 :       }
; 1468 :     }
; 1469 : 
; 1470 :     // output vectors must be doubled for next (finer) scale level
; 1471 :     if (num > 0)

	mov	DWORD PTR _meanvx$1$[esp+40], edi
	mov	edi, DWORD PTR _this$1$[esp+40]
	test	esi, esi
	jle	SHORT $LN237@estimate_g

; 1472 :     {
; 1473 :       _gvect_estim_ptr->x = 2 * meanvx / num;

	mov	eax, DWORD PTR _meanvx$1$[esp+40]
	add	eax, eax
	mov	ecx, DWORD PTR tv830[esp+40]
	cdq
	idiv	esi
	mov	DWORD PTR [ecx], eax

; 1474 :       _gvect_estim_ptr->y = 2 * meanvy / num;

	mov	eax, DWORD PTR _meanvy$1$[esp+40]
	add	eax, eax
	mov	ecx, DWORD PTR [edi+760]
	cdq
	idiv	esi
	mov	DWORD PTR [ecx+4], eax

; 1480 :     }
; 1481 :   }
; 1482 : 
; 1483 :   //	char debugbuf[100];
; 1484 :   //	sprintf(debugbuf,"MVAnalyse: nx=%d ny=%d next global vx=%d vy=%d", nBlkX, nBlkY, globalMVec->x, globalMVec->y);
; 1485 :   //	OutputDebugString(debugbuf);
; 1486 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN237@estimate_g:
	mov	edx, DWORD PTR _medianx$1$[esp+40]
$LN28@estimate_g:

; 1475 :     }
; 1476 :     else
; 1477 :     {
; 1478 :       _gvect_estim_ptr->x = 2 * medianx;

	mov	ecx, DWORD PTR tv830[esp+40]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR [ecx], eax

; 1479 :       _gvect_estim_ptr->y = 2 * mediany;

	mov	eax, DWORD PTR _mediany$1$[esp+40]
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [edi+760]
	mov	DWORD PTR [eax+4], ecx
$LN29@estimate_g:

; 1480 :     }
; 1481 :   }
; 1482 : 
; 1483 :   //	char debugbuf[100];
; 1484 :   //	sprintf(debugbuf,"MVAnalyse: nx=%d ny=%d next global vx=%d vy=%d", nBlkX, nBlkY, globalMVec->x, globalMVec->y);
; 1485 :   //	OutputDebugString(debugbuf);
; 1486 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?estimate_global_mv_doubled_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ENDP ; PlaneOfBlocks::estimate_global_mv_doubled_slice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?GetRefBlock@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z
_TEXT	SEGMENT
_workarea$ = 8						; size = 4
_nVx$ = 12						; size = 4
_nVy$ = 16						; size = 4
?GetRefBlock@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z PROC ; PlaneOfBlocks::GetRefBlock, COMDAT
; _this$ = ecx

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _workarea$[esp-4]
	push	ebx
	push	esi
	push	edi
	cmp	eax, 2
	jne	SHORT $LN5@GetRefBloc
	mov	eax, DWORD PTR [ecx+164]
	mov	ecx, DWORD PTR [edx+20]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR _nVy$[esp+8]
	lea	edi, DWORD PTR [eax+ecx*2]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _nVx$[esp+8]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [eax+ecx*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN28@GetRefBloc
$LN5@GetRefBloc:
	cmp	eax, 1
	mov	eax, DWORD PTR [ecx+164]
	jne	SHORT $LN3@GetRefBloc
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	esi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _nVx$[esp+8]
	pop	edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+52]
	shl	eax, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	ecx, DWORD PTR [edx+20]
	add	ecx, DWORD PTR _nVy$[esp+4]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ecx, DWORD PTR [esi+12]
	add	eax, ecx
	mov	ecx, DWORD PTR [esi]
	pop	esi
	pop	ebx
	add	eax, DWORD PTR [ecx]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1501 : }

	ret	12					; 0000000cH
$LN3@GetRefBloc:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _nVy$[esp+8]
	lea	edi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _nVx$[esp+8]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN28@GetRefBloc:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1501 : }

	ret	12					; 0000000cH
?GetRefBlock@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z ENDP ; PlaneOfBlocks::GetRefBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?GetRefBlockU@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z
_TEXT	SEGMENT
_workarea$ = 8						; size = 4
_nVx$ = 12						; size = 4
_nVy$ = 16						; size = 4
?GetRefBlockU@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z PROC ; PlaneOfBlocks::GetRefBlockU, COMDAT
; _this$ = ecx

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, DWORD PTR _nVy$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	mov	esi, DWORD PTR _workarea$[esp+8]
	push	edi
	mov	eax, DWORD PTR [ebp+20]
	cmp	eax, 2
	jne	SHORT $LN5@GetRefBloc
	mov	eax, DWORD PTR [ebp+164]
	mov	ecx, DWORD PTR [ebp+60]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+24]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _nVx$[esp+12]
	mov	eax, DWORD PTR [esi+12]
	sar	edx, cl
	lea	esi, DWORD PTR [edx+eax*2]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi
	add	edx, edx

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN28@GetRefBloc
$LN5@GetRefBloc:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebp+164]
	jne	SHORT $LN3@GetRefBloc
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edi, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebp+52]
	mov	eax, DWORD PTR _nVx$[esp+12]
	sar	eax, cl
	add	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edi+52]
	shl	eax, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebp+60]
	sar	edx, cl
	add	edx, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	add	eax, edx
	add	eax, DWORD PTR [ecx]
	pop	ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1511 : }

	ret	12					; 0000000cH
$LN3@GetRefBloc:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ebp+60]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebp+52]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _nVx$[esp+12]
	mov	eax, DWORD PTR [esi+12]
	sar	edx, cl
	lea	esi, DWORD PTR [edx+eax*4]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi
	shl	edx, 2
	and	eax, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN28@GetRefBloc:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1511 : }

	ret	12					; 0000000cH
?GetRefBlockU@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z ENDP ; PlaneOfBlocks::GetRefBlockU
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?GetRefBlockV@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z
_TEXT	SEGMENT
_workarea$ = 8						; size = 4
_nVx$ = 12						; size = 4
_nVy$ = 16						; size = 4
?GetRefBlockV@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z PROC ; PlaneOfBlocks::GetRefBlockV, COMDAT
; _this$ = ecx

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, DWORD PTR _nVy$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	mov	esi, DWORD PTR _workarea$[esp+8]
	push	edi
	mov	eax, DWORD PTR [ebp+20]
	cmp	eax, 2
	jne	SHORT $LN5@GetRefBloc
	mov	eax, DWORD PTR [ebp+164]
	mov	ecx, DWORD PTR [ebp+60]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _nVx$[esp+12]
	mov	eax, DWORD PTR [esi+16]
	sar	edx, cl
	lea	esi, DWORD PTR [edx+eax*2]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi
	add	edx, edx

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN28@GetRefBloc
$LN5@GetRefBloc:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebp+164]
	jne	SHORT $LN3@GetRefBloc
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edi, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebp+52]
	mov	eax, DWORD PTR _nVx$[esp+12]
	sar	eax, cl
	add	eax, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edi+52]
	shl	eax, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebp+60]
	sar	edx, cl
	add	edx, DWORD PTR [esi+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	add	eax, edx
	add	eax, DWORD PTR [ecx]
	pop	ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1520 : }

	ret	12					; 0000000cH
$LN3@GetRefBloc:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [ebp+60]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebp+52]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _nVx$[esp+12]
	mov	eax, DWORD PTR [esi+16]
	sar	edx, cl
	lea	esi, DWORD PTR [edx+eax*4]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi
	shl	edx, 2
	and	eax, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN28@GetRefBloc:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1520 : }

	ret	12					; 0000000cH
?GetRefBlockV@PlaneOfBlocks@@AAEPBEAAVWorkingArea@1@HH@Z ENDP ; PlaneOfBlocks::GetRefBlockV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z
_TEXT	SEGMENT
_sad$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
_pRef0$ = 12						; size = 4
?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z PROC ; PlaneOfBlocks::LumaSADx, COMDAT
; _this$ = ecx

; 1528 : {

	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi

; 1529 :   sad_t sad;
; 1530 :   sad_t refLuma;
; 1531 :   switch (dctmode)

	mov	eax, DWORD PTR [ebp+216]
	dec	eax
	cmp	eax, 9
	ja	$LN22@LumaSADx
	jmp	DWORD PTR $LN203@LumaSADx[eax*4]
$LN4@LumaSADx:

; 1532 :   {
; 1533 :   case 1: // dct SAD
; 1534 :     workarea.DCT->DCTBytes2D(pRef0, nRefPitch[0], &workarea.dctRef[0], dctpitch);

	mov	edi, DWORD PTR _workarea$[esp+12]
	push	DWORD PTR [ebp+124]
	mov	ecx, DWORD PTR [edi+48]
	push	DWORD PTR [edi+416]
	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _pRef0$[esp+24]
	call	DWORD PTR [eax]

; 1536 :     sad = (SAD(&workarea.dctSrc[0], dctpitch, &workarea.dctRef[0], dctpitch) + abs((workarea.dctSrc[0] - workarea.dctRef[0]) >> pixelsize_shift) * 3)*nBlkSizeX / 2; //correct reduced DC component

	mov	eax, DWORD PTR [ebp+124]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ebx, DWORD PTR [edi+416]
	mov	edi, DWORD PTR [edi+404]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1536 :     sad = (SAD(&workarea.dctSrc[0], dctpitch, &workarea.dctRef[0], dctpitch) + abs((workarea.dctSrc[0] - workarea.dctRef[0]) >> pixelsize_shift) * 3)*nBlkSizeX / 2; //correct reduced DC component

	push	eax
	push	ebx
	push	eax
	mov	eax, DWORD PTR [ebp+80]
	push	edi
	call	eax
	movzx	ecx, BYTE PTR [ebx]
	mov	esi, eax
	movzx	eax, BYTE PTR [edi]
	add	esp, 16					; 00000010H
	mov	ebx, DWORD PTR [ebp+8]
	sub	eax, ecx
	mov	ecx, DWORD PTR [ebp+68]
	sar	eax, cl
	cdq
	xor	eax, edx
	sub	eax, edx
	pop	edi
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, esi
	imul	ebx, eax
	pop	esi
	pop	ebp
	shr	ebx, 1

; 1618 :   }
; 1619 :   return sad;

	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
$LN5@LumaSADx:

; 1537 :     break;
; 1538 :   case 2: //  globally (lumaChange) weighted spatial and DCT
; 1539 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	edi, DWORD PTR _pRef0$[esp+16]
	mov	esi, DWORD PTR _workarea$[esp+16]
	mov	eax, DWORD PTR [ebp+80]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 1540 :     if (dctweight16 > 0)

	cmp	DWORD PTR [ebp+220], 0
	mov	DWORD PTR _sad$1$[esp+12], ebx
	jle	$LN2@LumaSADx

; 1541 :     {
; 1542 :       workarea.DCT->DCTBytes2D(pRef0, nRefPitch[0], &workarea.dctRef[0], dctpitch);

	push	DWORD PTR [ebp+124]
	mov	ecx, DWORD PTR [esi+48]
	push	DWORD PTR [esi+416]
	push	DWORD PTR [ebp+180]
	mov	edx, DWORD PTR [ecx]
	push	edi
	call	DWORD PTR [edx]

; 1544 :       sad_t dctsad = (SAD(&workarea.dctSrc[0], dctpitch, &workarea.dctRef[0], dctpitch) + abs((workarea.dctSrc[0] - workarea.dctRef[0]) >> pixelsize_shift) * 3)*nBlkSizeX / 2;

	mov	eax, DWORD PTR [ebp+124]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ebx, DWORD PTR [esi+416]
	mov	esi, DWORD PTR [esi+404]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1544 :       sad_t dctsad = (SAD(&workarea.dctSrc[0], dctpitch, &workarea.dctRef[0], dctpitch) + abs((workarea.dctSrc[0] - workarea.dctRef[0]) >> pixelsize_shift) * 3)*nBlkSizeX / 2;

	push	eax
	push	ebx
	push	eax
	mov	eax, DWORD PTR [ebp+80]
	push	esi
	call	eax
	movzx	ecx, BYTE PTR [ebx]
	mov	edi, eax
	movzx	eax, BYTE PTR [esi]
	add	esp, 16					; 00000010H
	sub	eax, ecx
	mov	ecx, DWORD PTR [ebp+68]
	sar	eax, cl

; 1545 :       sad = (sad*(16 - dctweight16) + dctsad*dctweight16) / 16;

	mov	ecx, DWORD PTR [ebp+220]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR [ebp+8]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, edi
	imul	edx, eax
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	imul	eax, DWORD PTR _sad$1$[esp+12]
	pop	edi
	pop	esi
	shr	edx, 1
	imul	ecx, edx
	pop	ebp
	add	eax, ecx
	cdq
	and	edx, 15					; 0000000fH
	lea	ebx, DWORD PTR [edx+eax]
	sar	ebx, 4

; 1618 :   }
; 1619 :   return sad;

	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
$LN7@LumaSADx:

; 1546 :     }
; 1547 :     break;
; 1548 :   case 3: // per block adaptive switched from spatial to equal mixed SAD (faster)
; 1549 :     refLuma = LUMA(pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	ebx, DWORD PTR _pRef0$[esp+16]
	mov	eax, DWORD PTR [ebp+84]
	push	ebx
	call	eax

; 1550 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	edi, DWORD PTR _workarea$[esp+24]
	mov	esi, eax
	mov	eax, DWORD PTR [ebp+80]
	push	ebx
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [edi+88]
	call	eax

; 1551 :     if (abs((int)workarea.srcLuma - (int)refLuma) > ((int)workarea.srcLuma + (int)refLuma) >> 5)

	mov	ecx, DWORD PTR [edi+392]
	mov	ebx, eax
	mov	eax, ecx
	add	esp, 24					; 00000018H
	sub	eax, esi
	add	ecx, esi
	cdq
	xor	eax, edx
	sar	ecx, 5
	sub	eax, edx
	cmp	eax, ecx
	jle	$LN2@LumaSADx

; 1552 :     {
; 1553 :       workarea.DCT->DCTBytes2D(pRef0, nRefPitch[0], &workarea.dctRef[0], dctpitch);

	push	DWORD PTR [ebp+124]
	mov	ecx, DWORD PTR [edi+48]
	push	DWORD PTR [edi+416]
	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _pRef0$[esp+24]
	call	DWORD PTR [eax]

; 1554 :       sad_t dctsad = SAD(&workarea.dctSrc[0], dctpitch, &workarea.dctRef[0], dctpitch)*nBlkSizeX / 2;

	mov	eax, DWORD PTR [ebp+124]
	push	eax
	push	DWORD PTR [edi+416]
	push	eax
	push	DWORD PTR [edi+404]
	mov	eax, DWORD PTR [ebp+80]
	call	eax
	mov	ecx, eax
	add	esp, 16					; 00000010H
	imul	ecx, DWORD PTR [ebp+8]

; 1555 :       sad = sad / 2 + dctsad / 2;

	mov	eax, ebx
	cdq
	sub	eax, edx
	pop	edi
	pop	esi
	shr	ecx, 1
	sar	ecx, 1
	sar	eax, 1
	pop	ebp
	lea	ebx, DWORD PTR [eax+ecx]

; 1618 :   }
; 1619 :   return sad;

	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
$LN9@LumaSADx:

; 1556 :     }
; 1557 :     break;
; 1558 :   case 4: //  per block adaptive switched from spatial to mixed SAD with more weight of DCT (best?)
; 1559 :     refLuma = LUMA(pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	ebx, DWORD PTR _pRef0$[esp+16]
	mov	eax, DWORD PTR [ebp+84]
	push	ebx
	call	eax

; 1560 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	edi, DWORD PTR _workarea$[esp+24]
	mov	esi, eax
	mov	eax, DWORD PTR [ebp+80]
	push	ebx
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [edi+88]
	call	eax

; 1561 :     if (abs((int)workarea.srcLuma - (int)refLuma) > ((int)workarea.srcLuma + (int)refLuma) >> 5)

	mov	ecx, DWORD PTR [edi+392]
	mov	ebx, eax
	mov	eax, ecx
	add	esp, 24					; 00000018H
	sub	eax, esi
	add	ecx, esi
	cdq
	xor	eax, edx
	sar	ecx, 5
	sub	eax, edx
	cmp	eax, ecx
	jle	$LN2@LumaSADx

; 1562 :     {
; 1563 :       workarea.DCT->DCTBytes2D(pRef0, nRefPitch[0], &workarea.dctRef[0], dctpitch);

	push	DWORD PTR [ebp+124]
	mov	ecx, DWORD PTR [edi+48]
	push	DWORD PTR [edi+416]
	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _pRef0$[esp+24]
	call	DWORD PTR [eax]

; 1564 :       sad_t dctsad = SAD(&workarea.dctSrc[0], dctpitch, &workarea.dctRef[0], dctpitch)*nBlkSizeX / 2;

	mov	eax, DWORD PTR [ebp+124]
	push	eax
	push	DWORD PTR [edi+416]
	push	eax
	push	DWORD PTR [edi+404]
	mov	eax, DWORD PTR [ebp+80]
	call	eax
	mov	ecx, eax
	add	esp, 16					; 00000010H
	imul	ecx, DWORD PTR [ebp+8]
	shr	ecx, 1

; 1565 :       sad = sad / 4 + dctsad / 2 + dctsad / 4;

	mov	eax, ecx
$LN201@LumaSADx:
	cdq
	and	edx, 3
	pop	edi
	lea	esi, DWORD PTR [edx+eax]
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	esi, 2
	sar	eax, 1
	add	esi, eax
	mov	eax, ebx
	cdq
	and	edx, 3
	lea	ebx, DWORD PTR [edx+eax]
	sar	ebx, 2
	add	ebx, esi
	pop	esi
	pop	ebp

; 1618 :   }
; 1619 :   return sad;

	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
$LN11@LumaSADx:

; 1566 :     }
; 1567 :     break;
; 1568 :   case 5: // dct SAD (SATD)
; 1569 :     sad = SATD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR _workarea$[esp+16]
	push	DWORD PTR _pRef0$[esp+16]
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ebp+104]

; 1614 :     }
; 1615 :     break;
; 1616 :   default:
; 1617 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	call	eax
	add	esp, 16					; 00000010H
	mov	ebx, eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1620 : }

	ret	8
$LN12@LumaSADx:

; 1570 :     // buggy? PF QTGMC(dct=5). 20160816 No! SATD function was linked to Dummy, did nothing. Made live again from 2.7.0.22d
; 1571 :     break;
; 1572 :   case 6: //  globally (lumaChange) weighted spatial and DCT (better estimate)
; 1573 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	edi, DWORD PTR _pRef0$[esp+16]
	mov	esi, DWORD PTR _workarea$[esp+16]
	mov	eax, DWORD PTR [ebp+80]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 1574 :     if (dctweight16 > 0)

	cmp	DWORD PTR [ebp+220], 0
	jle	$LN2@LumaSADx

; 1575 :     {
; 1576 :       sad_t dctsad = SATD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR [ebp+104]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [esi+88]
	call	eax

; 1577 :       sad = (sad*(16 - dctweight16) + dctsad*dctweight16) / 16; // todo check overflow if blocksizes reach 64 or more for uint16_t

	mov	edx, DWORD PTR [ebp+220]
	mov	ecx, 16					; 00000010H
	sub	ecx, edx
	imul	eax, edx
	imul	ecx, ebx
	add	esp, 16					; 00000010H
	pop	edi
	add	eax, ecx
	cdq
	and	edx, 15					; 0000000fH
	pop	esi
	pop	ebp
	lea	ebx, DWORD PTR [edx+eax]
	sar	ebx, 4

; 1618 :   }
; 1619 :   return sad;

	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
$LN14@LumaSADx:

; 1578 :     }
; 1579 :     break;
; 1580 :   case 7: // per block adaptive switched from spatial to equal mixed SAD (faster?)
; 1581 :     refLuma = LUMA(pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	edi, DWORD PTR _pRef0$[esp+16]
	mov	eax, DWORD PTR [ebp+84]
	push	edi
	call	eax

; 1582 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	esi, eax
	mov	eax, DWORD PTR _workarea$[esp+24]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ebp+80]
	call	eax
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 1583 :     if (abs((int)workarea.srcLuma - (int)refLuma) > (workarea.srcLuma + refLuma) >> 5)

	mov	eax, DWORD PTR _workarea$[esp+12]
	mov	ecx, DWORD PTR [eax+392]
	mov	eax, ecx
	sub	eax, esi
	add	ecx, esi
	cdq
	xor	eax, edx
	sar	ecx, 5
	sub	eax, edx
	cmp	eax, ecx
	jle	$LN2@LumaSADx

; 1584 :     {
; 1585 :       sad_t dctsad = SATD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR _workarea$[esp+16]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ebp+104]
	call	eax

; 1586 :       sad = sad / 2 + dctsad / 2;

	cdq
	add	esp, 16					; 00000010H
	sub	eax, edx
	mov	ecx, eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	ecx, 1
	sar	eax, 1
	pop	edi
	pop	esi
	pop	ebp
	lea	ebx, DWORD PTR [eax+ecx]

; 1618 :   }
; 1619 :   return sad;

	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
$LN16@LumaSADx:

; 1587 :     }
; 1588 :     break;
; 1589 :   case 8: //  per block adaptive switched from spatial to mixed SAD with more weight of DCT (faster?)
; 1590 :     refLuma = LUMA(pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	edi, DWORD PTR _pRef0$[esp+16]
	mov	eax, DWORD PTR [ebp+84]
	push	edi
	call	eax

; 1591 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	esi, eax
	mov	eax, DWORD PTR _workarea$[esp+24]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ebp+80]
	call	eax
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 1592 :     if (abs((int)workarea.srcLuma - (int)refLuma) > (workarea.srcLuma + refLuma) >> 5)

	mov	eax, DWORD PTR _workarea$[esp+12]
	mov	ecx, DWORD PTR [eax+392]
	mov	eax, ecx
	sub	eax, esi
	add	ecx, esi
	cdq
	xor	eax, edx
	sar	ecx, 5
	sub	eax, edx
	cmp	eax, ecx
	jle	$LN2@LumaSADx

; 1593 :     {
; 1594 :       sad_t dctsad = SATD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR _workarea$[esp+16]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ebp+104]
	call	eax
	add	esp, 16					; 00000010H
	mov	ecx, eax

; 1595 :       sad = sad / 4 + dctsad / 2 + dctsad / 4;
; 1596 :     }
; 1597 :     break;

	jmp	$LN201@LumaSADx
$LN18@LumaSADx:

; 1598 :   case 9: //  globally (lumaChange) weighted spatial and DCT (better estimate, only half weight on SATD)
; 1599 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	edi, DWORD PTR _workarea$[esp+16]
	push	DWORD PTR _pRef0$[esp+16]
	mov	eax, DWORD PTR [ebp+80]
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [edi+88]
	call	eax
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 1600 :     if (dctweight16 > 1)

	mov	eax, DWORD PTR [ebp+220]
	cmp	eax, 1
	jle	$LN2@LumaSADx

; 1601 :     {
; 1602 :       int dctweighthalf = dctweight16 / 2;
; 1603 :       sad_t dctsad = SATD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	cdq
	push	DWORD PTR _pRef0$[esp+16]
	sub	eax, edx
	push	DWORD PTR [ebp+168]
	mov	esi, eax
	mov	eax, DWORD PTR [ebp+104]
	push	DWORD PTR [edi+88]
	sar	esi, 1
	call	eax

; 1604 :       sad = (sad*(16 - dctweighthalf) + dctsad*dctweighthalf) / 16;

	imul	eax, esi
	mov	ecx, 16					; 00000010H
	sub	ecx, esi
	add	esp, 16					; 00000010H
	imul	ecx, ebx
	pop	edi
	pop	esi
	add	eax, ecx
	cdq
	and	edx, 15					; 0000000fH
	pop	ebp
	lea	ebx, DWORD PTR [edx+eax]
	sar	ebx, 4

; 1618 :   }
; 1619 :   return sad;

	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
$LN20@LumaSADx:

; 1605 :     }
; 1606 :     break;
; 1607 :   case 10: // per block adaptive switched from spatial to mixed SAD, weighted to SAD (faster)
; 1608 :     refLuma = LUMA(pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	edi, DWORD PTR _pRef0$[esp+16]
	mov	eax, DWORD PTR [ebp+84]
	push	edi
	call	eax

; 1609 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	esi, eax
	mov	eax, DWORD PTR _workarea$[esp+24]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ebp+80]
	call	eax
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 1610 :     if (abs((int)workarea.srcLuma - (int)refLuma) > ((int)workarea.srcLuma + (int)refLuma) >> 4)

	mov	eax, DWORD PTR _workarea$[esp+12]
	mov	ecx, DWORD PTR [eax+392]
	mov	eax, ecx
	sub	eax, esi
	add	ecx, esi
	cdq
	xor	eax, edx
	sar	ecx, 4
	sub	eax, edx
	cmp	eax, ecx
	jle	SHORT $LN2@LumaSADx

; 1611 :     {
; 1612 :       sad_t dctsad = SATD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR _workarea$[esp+16]
	push	edi
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ebp+104]
	call	eax

; 1613 :       sad = sad / 2 + dctsad / 4 + sad / 4;

	cdq
	add	esp, 16					; 00000010H
	and	edx, 3
	pop	edi
	lea	ecx, DWORD PTR [edx+eax]
	mov	eax, ebx
	cdq
	and	edx, 3
	sar	ecx, 2
	add	eax, edx
	sar	eax, 2
	add	ecx, eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	pop	esi
	pop	ebp
	lea	ebx, DWORD PTR [eax+ecx]

; 1618 :   }
; 1619 :   return sad;

	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
$LN22@LumaSADx:

; 1614 :     }
; 1615 :     break;
; 1616 :   default:
; 1617 :     sad = SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);

	push	DWORD PTR [ebp+180]
	mov	eax, DWORD PTR _workarea$[esp+16]
	push	DWORD PTR _pRef0$[esp+16]
	push	DWORD PTR [ebp+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ebp+80]
	call	eax
	mov	ebx, eax
	add	esp, 16					; 00000010H
$LN2@LumaSADx:

; 1618 :   }
; 1619 :   return sad;

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx

; 1620 : }

	ret	8
	npad	1
$LN203@LumaSADx:
	DD	$LN4@LumaSADx
	DD	$LN5@LumaSADx
	DD	$LN7@LumaSADx
	DD	$LN9@LumaSADx
	DD	$LN11@LumaSADx
	DD	$LN12@LumaSADx
	DD	$LN14@LumaSADx
	DD	$LN16@LumaSADx
	DD	$LN18@LumaSADx
	DD	$LN20@LumaSADx
?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ENDP ; PlaneOfBlocks::LumaSADx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?LumaSAD@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z
_TEXT	SEGMENT
_workarea$ = 8						; size = 4
_pRef0$ = 12						; size = 4
?LumaSAD@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z PROC	; PlaneOfBlocks::LumaSAD, COMDAT
; _this$ = ecx

; 1624 : #ifdef MOTION_DEBUG
; 1625 :   workarea.iter++;
; 1626 : #endif
; 1627 : #ifdef ALLOW_DCT
; 1628 :   // made simple SAD more prominent (~1% faster) while keeping DCT support (TSchniede)
; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [ecx+216], 0
	jne	SHORT $LN3@LumaSAD
	push	DWORD PTR [ecx+180]
	mov	eax, DWORD PTR _workarea$[esp]
	push	DWORD PTR _pRef0$[esp]
	push	DWORD PTR [ecx+168]
	push	DWORD PTR [eax+88]
	mov	eax, DWORD PTR [ecx+80]
	call	eax
	add	esp, 16					; 00000010H

; 1630 : #else
; 1631 :   return SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]);
; 1632 : #endif
; 1633 : }

	ret	8
$LN3@LumaSAD:

; 1624 : #ifdef MOTION_DEBUG
; 1625 :   workarea.iter++;
; 1626 : #endif
; 1627 : #ifdef ALLOW_DCT
; 1628 :   // made simple SAD more prominent (~1% faster) while keeping DCT support (TSchniede)
; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	jmp	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
?LumaSAD@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ENDP	; PlaneOfBlocks::LumaSAD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?CheckMV0@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
tv1043 = -8						; size = 4
tv1048 = -4						; size = 4
tv1047 = 8						; size = 4
tv1042 = 8						; size = 4
_saduv$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
_vx$ = 12						; size = 4
$T1 = 16						; size = 4
_vy$ = 16						; size = 4
?CheckMV0@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z PROC	; PlaneOfBlocks::CheckMV0, COMDAT
; _this$ = ecx

; 1638 : {		//here the chance for default values are high especially for zeroMVfieldShifted (on left/top border)

	sub	esp, 16					; 00000010H
	push	ebp

; 2482 :   return (

	mov	ebp, DWORD PTR _workarea$[esp+16]
	push	esi

; 1638 : {		//here the chance for default values are high especially for zeroMVfieldShifted (on left/top border)

	mov	esi, ecx

; 2482 :   return (

	mov	ecx, DWORD PTR _vx$[esp+20]

; 1638 : {		//here the chance for default values are high especially for zeroMVfieldShifted (on left/top border)

	mov	DWORD PTR _this$1$[esp+24], esi

; 2482 :   return (

	cmp	ecx, DWORD PTR [ebp+368]
	jl	$LN3@CheckMV0
	push	edi
	mov	edi, DWORD PTR _vy$[esp+24]
	cmp	edi, DWORD PTR [ebp+372]
	jl	$LN101@CheckMV0
	cmp	ecx, DWORD PTR [ebp+376]
	jge	$LN101@CheckMV0
	cmp	edi, DWORD PTR [ebp+380]
	jge	$LN101@CheckMV0

; 1647 :     sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, vx, vy), nRefPitch[1])

	cmp	BYTE PTR [esi+122], 0
	push	ebx
	je	$LN5@CheckMV0

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN15@CheckMV0
	mov	eax, DWORD PTR [esi+164]
	mov	ecx, DWORD PTR [esi+60]
	mov	edx, DWORD PTR _vx$[esp+28]
	sar	edi, cl
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR _this$1$[esp+32], eax
	mov	eax, DWORD PTR [ebp+24]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1043[esp+32], edi
	lea	edi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR tv1042[esp+28], edx
	mov	eax, DWORD PTR [ebp+12]
	lea	esi, DWORD PTR [edx+eax*2]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	edi, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	mov	eax, esi
	and	eax, 1
	sar	esi, 1
	add	edx, edx
	shl	esi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, esi
	add	ecx, edi
	mov	DWORD PTR tv1048[esp+32], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN103@CheckMV0
$LN15@CheckMV0:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+164]
	mov	DWORD PTR _this$1$[esp+32], eax
	jne	SHORT $LN13@CheckMV0
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [ebp+12]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+60]
	add	ebx, eax
	mov	DWORD PTR tv1042[esp+28], eax
	mov	eax, DWORD PTR [ebp+24]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
	mov	DWORD PTR tv1048[esp+32], ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN14@CheckMV0
$LN13@CheckMV0:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [ebp+24]
	mov	edx, DWORD PTR _vx$[esp+28]
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+52]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1043[esp+32], edi
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR tv1042[esp+28], edx
	lea	esi, DWORD PTR [edx+eax*4]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	edi, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	mov	eax, esi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	esi, 2
	mov	eax, DWORD PTR [ebx]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	add	eax, edi
	mov	DWORD PTR tv1048[esp+32], eax
$LN103@CheckMV0:
	mov	edi, DWORD PTR tv1043[esp+32]
	mov	esi, DWORD PTR _this$1$[esp+32]
$LN14@CheckMV0:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN42@CheckMV0
	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR tv1042[esp+28]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [ebp+16]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	esi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN104@CheckMV0
$LN42@CheckMV0:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebp+28]
	jne	SHORT $LN40@CheckMV0
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebx, DWORD PTR [ebp+16]
	add	ebx, DWORD PTR tv1042[esp+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN41@CheckMV0
$LN40@CheckMV0:
	mov	ecx, DWORD PTR tv1042[esp+28]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+16]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	esi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN104@CheckMV0:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR _this$1$[esp+32]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	imul	edi, DWORD PTR [ebx+12]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	mov	ebx, eax
	mov	DWORD PTR tv1047[esp+28], eax
	add	ebx, edi
$LN41@CheckMV0:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1647 :     sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, vx, vy), nRefPitch[1])

	push	DWORD PTR [esi+184]
	mov	eax, DWORD PTR [esi+100]
	push	DWORD PTR tv1048[esp+36]
	push	DWORD PTR [esi+172]
	push	DWORD PTR [ebp+92]
	call	eax
	push	DWORD PTR [esi+188]
	mov	ecx, DWORD PTR [esi+100]
	mov	edi, eax
	push	ebx
	push	DWORD PTR [esi+176]
	push	DWORD PTR [ebp+96]
	call	ecx
	mov	ecx, DWORD PTR _vx$[esp+60]
	add	esp, 32					; 00000020H
	add	edi, eax
	mov	DWORD PTR _saduv$1$[esp+28], edi
	mov	edi, DWORD PTR _vy$[esp+28]
	jmp	SHORT $LN6@CheckMV0
$LN5@CheckMV0:
	mov	DWORD PTR _saduv$1$[esp+28], 0
$LN6@CheckMV0:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN69@CheckMV0
	mov	eax, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [ebp+8]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN105@CheckMV0
$LN69@CheckMV0:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+164]
	jne	SHORT $LN67@CheckMV0
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+8]
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+28], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+28]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN68@CheckMV0
$LN67@CheckMV0:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+8]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN105@CheckMV0:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	imul	edi, DWORD PTR [ebx+12]
	shl	esi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	add	ecx, edi
	mov	edi, DWORD PTR _vy$[esp+28]
$LN68@CheckMV0:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [esi+216], 0
	jne	SHORT $LN94@CheckMV0
	push	DWORD PTR [esi+180]
	mov	eax, DWORD PTR [esi+80]
	push	ecx
	push	DWORD PTR [esi+168]
	push	DWORD PTR [ebp+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN106@CheckMV0
$LN94@CheckMV0:
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN106@CheckMV0:

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	edx, DWORD PTR [ebp+116]

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	mov	esi, eax

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	eax, DWORD PTR [ebp+120]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	mov	ecx, 16					; 00000010H

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	ebx, DWORD PTR _vx$[esp+28]
	sub	eax, edi

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sub	ecx, DWORD PTR [ebp+400]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	edx, ebx

; 1648 :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, vx, vy), nRefPitch[2]) : 0;
; 1649 :     sad_t sad = LumaSAD(workarea, GetRefBlock(workarea, vx, vy));
; 1650 :     sad += saduv;

	add	esi, DWORD PTR _saduv$1$[esp+28]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	imul	edx, edx
	imul	eax, eax
	add	edx, eax

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	imul	edx, DWORD PTR [ebp+384]
	sar	edx, cl

; 1651 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy);

	add	edx, esi

; 1652 :     //		int cost = sad + sad*workarea.MotionDistorsion(vx, vy)/(nBlkSizeX*nBlkSizeY*4);
; 1653 :     //		if (sad>bigSAD) { DebugPrintf("%d %d %d %d %d %d", workarea.blkIdx, vx, vy, workarea.nMinCost, cost, sad);}
; 1654 :     if (cost < workarea.nMinCost)

	cmp	edx, DWORD PTR [ebp+112]
	jge	SHORT $LN102@CheckMV0

; 1655 :     {
; 1656 :       workarea.bestMV.x = vx;

	mov	DWORD PTR [ebp+100], ebx

; 1657 :       workarea.bestMV.y = vy;

	mov	DWORD PTR [ebp+104], edi

; 1658 :       workarea.nMinCost = cost;

	mov	DWORD PTR [ebp+112], edx

; 1659 :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [ebp+108], esi
$LN102@CheckMV0:
	pop	ebx
$LN101@CheckMV0:
	pop	edi
$LN3@CheckMV0:
	pop	esi
	pop	ebp

; 1660 :     }
; 1661 :   }
; 1662 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?CheckMV0@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ENDP	; PlaneOfBlocks::CheckMV0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
tv1035 = -8						; size = 4
tv1040 = -4						; size = 4
tv1039 = 8						; size = 4
tv1034 = 8						; size = 4
_saduv$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
_vx$ = 12						; size = 4
$T1 = 16						; size = 4
_sad$1$ = 16						; size = 4
_vy$ = 16						; size = 4
?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z PROC	; PlaneOfBlocks::CheckMV, COMDAT
; _this$ = ecx

; 1666 : {		//here the chance for default values are high especially for zeroMVfieldShifted (on left/top border)

	sub	esp, 16					; 00000010H
	push	ebp

; 2482 :   return (

	mov	ebp, DWORD PTR _workarea$[esp+16]
	push	esi

; 1666 : {		//here the chance for default values are high especially for zeroMVfieldShifted (on left/top border)

	mov	esi, ecx

; 2482 :   return (

	mov	ecx, DWORD PTR _vx$[esp+20]

; 1666 : {		//here the chance for default values are high especially for zeroMVfieldShifted (on left/top border)

	mov	DWORD PTR _this$1$[esp+24], esi

; 2482 :   return (

	cmp	ecx, DWORD PTR [ebp+368]
	jl	$LN3@CheckMV
	push	edi
	mov	edi, DWORD PTR _vy$[esp+24]
	cmp	edi, DWORD PTR [ebp+372]
	jl	$LN101@CheckMV
	cmp	ecx, DWORD PTR [ebp+376]
	jge	$LN101@CheckMV
	cmp	edi, DWORD PTR [ebp+380]
	jge	$LN101@CheckMV

; 1676 :       !(chroma) ? 0 :

	cmp	BYTE PTR [esi+122], 0
	push	ebx
	jne	SHORT $LN5@CheckMV
	mov	DWORD PTR _saduv$1$[esp+28], 0
	jmp	$LN6@CheckMV
$LN5@CheckMV:

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN15@CheckMV
	mov	eax, DWORD PTR [esi+164]
	mov	ecx, DWORD PTR [esi+60]
	mov	edx, DWORD PTR _vx$[esp+28]
	sar	edi, cl
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR _this$1$[esp+32], eax
	mov	eax, DWORD PTR [ebp+24]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1035[esp+32], edi
	lea	edi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR tv1034[esp+28], edx
	mov	eax, DWORD PTR [ebp+12]
	lea	esi, DWORD PTR [edx+eax*2]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	edi, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	mov	eax, esi
	and	eax, 1
	sar	esi, 1
	add	edx, edx
	shl	esi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, esi
	add	ecx, edi
	mov	DWORD PTR tv1040[esp+32], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN103@CheckMV
$LN15@CheckMV:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+164]
	mov	DWORD PTR _this$1$[esp+32], eax
	jne	SHORT $LN13@CheckMV
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [ebp+12]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+60]
	add	ebx, eax
	mov	DWORD PTR tv1034[esp+28], eax
	mov	eax, DWORD PTR [ebp+24]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
	mov	DWORD PTR tv1040[esp+32], ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN14@CheckMV
$LN13@CheckMV:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [ebp+24]
	mov	edx, DWORD PTR _vx$[esp+28]
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+52]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1035[esp+32], edi
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR tv1034[esp+28], edx
	lea	esi, DWORD PTR [edx+eax*4]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	edi, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	mov	eax, esi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	esi, 2
	mov	eax, DWORD PTR [ebx]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	add	eax, edi
	mov	DWORD PTR tv1040[esp+32], eax
$LN103@CheckMV:
	mov	edi, DWORD PTR tv1035[esp+32]
	mov	esi, DWORD PTR _this$1$[esp+32]
$LN14@CheckMV:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN42@CheckMV
	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR tv1034[esp+28]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [ebp+16]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	esi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN104@CheckMV
$LN42@CheckMV:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebp+28]
	jne	SHORT $LN40@CheckMV
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebx, DWORD PTR [ebp+16]
	add	ebx, DWORD PTR tv1034[esp+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN41@CheckMV
$LN40@CheckMV:
	mov	ecx, DWORD PTR tv1034[esp+28]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+16]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	esi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN104@CheckMV:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR _this$1$[esp+32]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	imul	edi, DWORD PTR [ebx+12]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	mov	ebx, eax
	mov	DWORD PTR tv1039[esp+28], eax
	add	ebx, edi
$LN41@CheckMV:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1676 :       !(chroma) ? 0 :

	push	DWORD PTR [esi+184]
	mov	eax, DWORD PTR [esi+100]
	push	DWORD PTR tv1040[esp+36]
	push	DWORD PTR [esi+172]
	push	DWORD PTR [ebp+92]
	call	eax
	push	DWORD PTR [esi+188]
	mov	ecx, DWORD PTR [esi+100]
	mov	edi, eax
	push	ebx
	push	DWORD PTR [esi+176]
	push	DWORD PTR [ebp+96]
	call	ecx
	mov	ecx, DWORD PTR _vx$[esp+60]
	add	esp, 32					; 00000020H
	add	edi, eax
	mov	DWORD PTR _saduv$1$[esp+28], edi
	mov	edi, DWORD PTR _vy$[esp+28]
$LN6@CheckMV:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN69@CheckMV
	mov	eax, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [ebp+8]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN105@CheckMV
$LN69@CheckMV:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+164]
	jne	SHORT $LN67@CheckMV
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+8]
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+28], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+28]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN68@CheckMV
$LN67@CheckMV:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+8]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN105@CheckMV:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	imul	edi, DWORD PTR [ebx+12]
	shl	esi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	add	ecx, edi
	mov	edi, DWORD PTR _vy$[esp+28]
$LN68@CheckMV:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [esi+216], 0
	jne	SHORT $LN94@CheckMV
	push	DWORD PTR [esi+180]
	mov	eax, DWORD PTR [esi+80]
	push	ecx
	push	DWORD PTR [esi+168]
	push	DWORD PTR [ebp+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN106@CheckMV
$LN94@CheckMV:
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN106@CheckMV:

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	esi, DWORD PTR [ebp+116]

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	mov	edx, eax

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	eax, DWORD PTR [ebp+120]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	mov	ecx, 16					; 00000010H

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	ebx, DWORD PTR _vx$[esp+28]
	sub	eax, edi

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sub	ecx, DWORD PTR [ebp+400]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	esi, ebx

; 1677 :       SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, vx, vy), nRefPitch[1])
; 1678 :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, vx, vy), nRefPitch[2]);
; 1679 :     sad_t sad = LumaSAD(workarea, GetRefBlock(workarea, vx, vy));
; 1680 :     sad += saduv;

	add	edx, DWORD PTR _saduv$1$[esp+28]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	imul	esi, esi
	imul	eax, eax

; 1677 :       SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, vx, vy), nRefPitch[1])
; 1678 :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, vx, vy), nRefPitch[2]);
; 1679 :     sad_t sad = LumaSAD(workarea, GetRefBlock(workarea, vx, vy));
; 1680 :     sad += saduv;

	mov	DWORD PTR _sad$1$[esp+28], edx

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	add	esi, eax

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	mov	eax, edx

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	imul	esi, DWORD PTR [ebp+384]
	sar	esi, cl

; 1681 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(bigsad_t)sad) >> 8); //v2

	mov	ecx, DWORD PTR _this$1$[esp+32]
	imul	DWORD PTR [ecx+236]
	mov	ecx, eax
	mov	eax, DWORD PTR _sad$1$[esp+28]
	shrd	ecx, edx, 8
	add	esi, eax
	add	ecx, esi
	sar	edx, 8

; 1682 : //		int cost = sad + sad*workarea.MotionDistorsion(vx, vy)/(nBlkSizeX*nBlkSizeY*4);
; 1683 : //		if (sad>bigSAD) { DebugPrintf("%d %d %d %d %d %d", workarea.blkIdx, vx, vy, workarea.nMinCost, cost, sad);}
; 1684 :     if (cost < workarea.nMinCost)

	cmp	ecx, DWORD PTR [ebp+112]
	jge	SHORT $LN102@CheckMV

; 1685 :     {
; 1686 :       workarea.bestMV.x = vx;

	mov	DWORD PTR [ebp+100], ebx

; 1687 :       workarea.bestMV.y = vy;

	mov	DWORD PTR [ebp+104], edi

; 1688 :       workarea.nMinCost = cost;

	mov	DWORD PTR [ebp+112], ecx

; 1689 :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [ebp+108], eax
$LN102@CheckMV:
	pop	ebx
$LN101@CheckMV:
	pop	edi
$LN3@CheckMV:
	pop	esi
	pop	ebp

; 1690 :     }
; 1691 :   }
; 1692 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ENDP	; PlaneOfBlocks::CheckMV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
tv1036 = -8						; size = 4
tv1041 = -4						; size = 4
tv1040 = 8						; size = 4
tv1035 = 8						; size = 4
_saduv$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
_vx$ = 12						; size = 4
$T1 = 16						; size = 4
_sad$1$ = 16						; size = 4
_vy$ = 16						; size = 4
_dir$ = 20						; size = 4
_val$ = 24						; size = 4
?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z PROC ; PlaneOfBlocks::CheckMV2, COMDAT
; _this$ = ecx

; 1696 : {

	sub	esp, 16					; 00000010H
	push	ebp

; 2482 :   return (

	mov	ebp, DWORD PTR _workarea$[esp+16]
	push	esi

; 1696 : {

	mov	esi, ecx

; 2482 :   return (

	mov	ecx, DWORD PTR _vx$[esp+20]

; 1696 : {

	mov	DWORD PTR _this$1$[esp+24], esi

; 2482 :   return (

	cmp	ecx, DWORD PTR [ebp+368]
	jl	$LN3@CheckMV2
	push	edi
	mov	edi, DWORD PTR _vy$[esp+24]
	cmp	edi, DWORD PTR [ebp+372]
	jl	$LN101@CheckMV2
	cmp	ecx, DWORD PTR [ebp+376]
	jge	$LN101@CheckMV2
	cmp	edi, DWORD PTR [ebp+380]
	jge	$LN101@CheckMV2

; 1706 :       !(chroma) ? 0 :

	cmp	BYTE PTR [esi+122], 0
	push	ebx
	jne	SHORT $LN5@CheckMV2
	mov	DWORD PTR _saduv$1$[esp+28], 0
	jmp	$LN6@CheckMV2
$LN5@CheckMV2:

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN15@CheckMV2
	mov	eax, DWORD PTR [esi+164]
	mov	ecx, DWORD PTR [esi+60]
	mov	edx, DWORD PTR _vx$[esp+28]
	sar	edi, cl
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR _this$1$[esp+32], eax
	mov	eax, DWORD PTR [ebp+24]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1036[esp+32], edi
	lea	edi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR tv1035[esp+28], edx
	mov	eax, DWORD PTR [ebp+12]
	lea	esi, DWORD PTR [edx+eax*2]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	edi, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	mov	eax, esi
	and	eax, 1
	sar	esi, 1
	add	edx, edx
	shl	esi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, esi
	add	ecx, edi
	mov	DWORD PTR tv1041[esp+32], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN103@CheckMV2
$LN15@CheckMV2:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+164]
	mov	DWORD PTR _this$1$[esp+32], eax
	jne	SHORT $LN13@CheckMV2
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [ebp+12]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+60]
	add	ebx, eax
	mov	DWORD PTR tv1035[esp+28], eax
	mov	eax, DWORD PTR [ebp+24]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
	mov	DWORD PTR tv1041[esp+32], ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN14@CheckMV2
$LN13@CheckMV2:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [ebp+24]
	mov	edx, DWORD PTR _vx$[esp+28]
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+52]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1036[esp+32], edi
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR tv1035[esp+28], edx
	lea	esi, DWORD PTR [edx+eax*4]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	edi, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	mov	eax, esi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	esi, 2
	mov	eax, DWORD PTR [ebx]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	add	eax, edi
	mov	DWORD PTR tv1041[esp+32], eax
$LN103@CheckMV2:
	mov	edi, DWORD PTR tv1036[esp+32]
	mov	esi, DWORD PTR _this$1$[esp+32]
$LN14@CheckMV2:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN42@CheckMV2
	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR tv1035[esp+28]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [ebp+16]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	esi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN104@CheckMV2
$LN42@CheckMV2:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebp+28]
	jne	SHORT $LN40@CheckMV2
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebx, DWORD PTR [ebp+16]
	add	ebx, DWORD PTR tv1035[esp+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN41@CheckMV2
$LN40@CheckMV2:
	mov	ecx, DWORD PTR tv1035[esp+28]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+16]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	esi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN104@CheckMV2:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR _this$1$[esp+32]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	imul	edi, DWORD PTR [ebx+12]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	mov	ebx, eax
	mov	DWORD PTR tv1040[esp+28], eax
	add	ebx, edi
$LN41@CheckMV2:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1706 :       !(chroma) ? 0 :

	push	DWORD PTR [esi+184]
	mov	eax, DWORD PTR [esi+100]
	push	DWORD PTR tv1041[esp+36]
	push	DWORD PTR [esi+172]
	push	DWORD PTR [ebp+92]
	call	eax
	push	DWORD PTR [esi+188]
	mov	ecx, DWORD PTR [esi+100]
	mov	edi, eax
	push	ebx
	push	DWORD PTR [esi+176]
	push	DWORD PTR [ebp+96]
	call	ecx
	mov	ecx, DWORD PTR _vx$[esp+60]
	add	esp, 32					; 00000020H
	add	edi, eax
	mov	DWORD PTR _saduv$1$[esp+28], edi
	mov	edi, DWORD PTR _vy$[esp+28]
$LN6@CheckMV2:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN69@CheckMV2
	mov	eax, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [ebp+8]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN105@CheckMV2
$LN69@CheckMV2:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+164]
	jne	SHORT $LN67@CheckMV2
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+8]
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+28], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+28]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN68@CheckMV2
$LN67@CheckMV2:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+8]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN105@CheckMV2:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	imul	edi, DWORD PTR [ebx+12]
	shl	esi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	add	ecx, edi
	mov	edi, DWORD PTR _vy$[esp+28]
$LN68@CheckMV2:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [esi+216], 0
	jne	SHORT $LN94@CheckMV2
	push	DWORD PTR [esi+180]
	mov	eax, DWORD PTR [esi+80]
	push	ecx
	push	DWORD PTR [esi+168]
	push	DWORD PTR [ebp+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN106@CheckMV2
$LN94@CheckMV2:
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN106@CheckMV2:

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	esi, DWORD PTR [ebp+116]

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	mov	edx, eax

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	eax, DWORD PTR [ebp+120]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	mov	ecx, 16					; 00000010H

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	ebx, DWORD PTR _vx$[esp+28]
	sub	eax, edi

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sub	ecx, DWORD PTR [ebp+400]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	esi, ebx

; 1707 :       SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, vx, vy), nRefPitch[1])
; 1708 :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, vx, vy), nRefPitch[2]);
; 1709 :     sad_t sad = LumaSAD(workarea, GetRefBlock(workarea, vx, vy));
; 1710 :     sad += saduv;

	add	edx, DWORD PTR _saduv$1$[esp+28]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	imul	esi, esi
	imul	eax, eax

; 1707 :       SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, vx, vy), nRefPitch[1])
; 1708 :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, vx, vy), nRefPitch[2]);
; 1709 :     sad_t sad = LumaSAD(workarea, GetRefBlock(workarea, vx, vy));
; 1710 :     sad += saduv;

	mov	DWORD PTR _sad$1$[esp+28], edx

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	add	esi, eax

; 1711 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(int64_t)sad) >> 8); // v1.5.8

	mov	eax, edx

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	imul	esi, DWORD PTR [ebp+384]
	sar	esi, cl

; 1711 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(int64_t)sad) >> 8); // v1.5.8

	mov	ecx, DWORD PTR _this$1$[esp+32]
	imul	DWORD PTR [ecx+236]
	mov	ecx, eax
	mov	eax, DWORD PTR _sad$1$[esp+28]
	shrd	ecx, edx, 8
	add	esi, eax
	add	ecx, esi
	sar	edx, 8

; 1712 : //		if (sad > LSAD/4) DebugPrintf("%d %d %d %d %d %d %d", workarea.blkIdx, vx, vy, val, workarea.nMinCost, cost, sad);
; 1713 : //		int cost = sad + sad*workarea.MotionDistorsion(vx, vy)/(nBlkSizeX*nBlkSizeY*4) + ((penaltyNew*sad)>>8); // v1.5.8
; 1714 :     if (cost < workarea.nMinCost)

	cmp	ecx, DWORD PTR [ebp+112]
	jge	SHORT $LN102@CheckMV2

; 1715 :     {
; 1716 :       workarea.bestMV.x = vx;
; 1717 :       workarea.bestMV.y = vy;
; 1718 :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [ebp+108], eax

; 1719 :       workarea.nMinCost = cost;
; 1720 :       *dir = val;

	mov	eax, DWORD PTR _dir$[esp+28]
	mov	DWORD PTR [ebp+112], ecx
	mov	ecx, DWORD PTR _val$[esp+28]
	mov	DWORD PTR [ebp+100], ebx
	mov	DWORD PTR [ebp+104], edi
	mov	DWORD PTR [eax], ecx
$LN102@CheckMV2:
	pop	ebx
$LN101@CheckMV2:
	pop	edi
$LN3@CheckMV2:
	pop	esi
	pop	ebp

; 1721 :     }
; 1722 :   }
; 1723 : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?CheckMV2@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ENDP ; PlaneOfBlocks::CheckMV2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
tv1030 = -8						; size = 4
tv1035 = -4						; size = 4
tv1034 = 8						; size = 4
tv1029 = 8						; size = 4
_saduv$1$ = 8						; size = 4
_workarea$ = 8						; size = 4
_vx$ = 12						; size = 4
$T1 = 16						; size = 4
_vy$ = 16						; size = 4
_dir$ = 20						; size = 4
_val$ = 24						; size = 4
?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z PROC ; PlaneOfBlocks::CheckMVdir, COMDAT
; _this$ = ecx

; 1727 : {

	sub	esp, 16					; 00000010H
	push	ebp

; 2482 :   return (

	mov	ebp, DWORD PTR _workarea$[esp+16]
	push	esi

; 1727 : {

	mov	esi, ecx

; 2482 :   return (

	mov	ecx, DWORD PTR _vx$[esp+20]

; 1727 : {

	mov	DWORD PTR _this$1$[esp+24], esi

; 2482 :   return (

	cmp	ecx, DWORD PTR [ebp+368]
	jl	$LN3@CheckMVdir
	push	edi
	mov	edi, DWORD PTR _vy$[esp+24]
	cmp	edi, DWORD PTR [ebp+372]
	jl	$LN101@CheckMVdir
	cmp	ecx, DWORD PTR [ebp+376]
	jge	$LN101@CheckMVdir
	cmp	edi, DWORD PTR [ebp+380]
	jge	$LN101@CheckMVdir

; 1736 :     sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, vx, vy), nRefPitch[1])

	cmp	BYTE PTR [esi+122], 0
	push	ebx
	je	$LN5@CheckMVdir

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN15@CheckMVdir
	mov	eax, DWORD PTR [esi+164]
	mov	ecx, DWORD PTR [esi+60]
	mov	edx, DWORD PTR _vx$[esp+28]
	sar	edi, cl
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR _this$1$[esp+32], eax
	mov	eax, DWORD PTR [ebp+24]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1030[esp+32], edi
	lea	edi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR tv1029[esp+28], edx
	mov	eax, DWORD PTR [ebp+12]
	lea	esi, DWORD PTR [edx+eax*2]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	edi, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	mov	eax, esi
	and	eax, 1
	sar	esi, 1
	add	edx, edx
	shl	esi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, esi
	add	ecx, edi
	mov	DWORD PTR tv1035[esp+32], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN103@CheckMVdir
$LN15@CheckMVdir:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+164]
	mov	DWORD PTR _this$1$[esp+32], eax
	jne	SHORT $LN13@CheckMVdir
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, ecx
	mov	ecx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [ebp+12]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+60]
	add	ebx, eax
	mov	DWORD PTR tv1029[esp+28], eax
	mov	eax, DWORD PTR [ebp+24]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
	mov	DWORD PTR tv1035[esp+32], ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN14@CheckMVdir
$LN13@CheckMVdir:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [ebp+24]
	mov	edx, DWORD PTR _vx$[esp+28]
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+52]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv1030[esp+32], edi
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR tv1029[esp+28], edx
	lea	esi, DWORD PTR [edx+eax*4]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	edi, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	mov	eax, esi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	esi, 2
	mov	eax, DWORD PTR [ebx]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	add	eax, edi
	mov	DWORD PTR tv1035[esp+32], eax
$LN103@CheckMVdir:
	mov	edi, DWORD PTR tv1030[esp+32]
	mov	esi, DWORD PTR _this$1$[esp+32]
$LN14@CheckMVdir:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN42@CheckMVdir
	mov	eax, DWORD PTR [ebp+28]
	mov	ecx, DWORD PTR tv1029[esp+28]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [ebp+16]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	esi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN104@CheckMVdir
$LN42@CheckMVdir:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebp+28]
	jne	SHORT $LN40@CheckMVdir
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	add	eax, edi
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebx, DWORD PTR [ebp+16]
	add	ebx, DWORD PTR tv1029[esp+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN41@CheckMVdir
$LN40@CheckMVdir:
	mov	ecx, DWORD PTR tv1029[esp+28]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+16]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	esi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN104@CheckMVdir:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR _this$1$[esp+32]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	imul	edi, DWORD PTR [ebx+12]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	mov	ebx, eax
	mov	DWORD PTR tv1034[esp+28], eax
	add	ebx, edi
$LN41@CheckMVdir:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1736 :     sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, vx, vy), nRefPitch[1])

	push	DWORD PTR [esi+184]
	mov	eax, DWORD PTR [esi+100]
	push	DWORD PTR tv1035[esp+36]
	push	DWORD PTR [esi+172]
	push	DWORD PTR [ebp+92]
	call	eax
	push	DWORD PTR [esi+188]
	mov	ecx, DWORD PTR [esi+100]
	mov	edi, eax
	push	ebx
	push	DWORD PTR [esi+176]
	push	DWORD PTR [ebp+96]
	call	ecx
	mov	ecx, DWORD PTR _vx$[esp+60]
	add	esp, 32					; 00000020H
	add	edi, eax
	mov	DWORD PTR _saduv$1$[esp+28], edi
	mov	edi, DWORD PTR _vy$[esp+28]
	jmp	SHORT $LN6@CheckMVdir
$LN5@CheckMVdir:
	mov	DWORD PTR _saduv$1$[esp+28], 0
$LN6@CheckMVdir:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 2
	jne	SHORT $LN69@CheckMVdir
	mov	eax, DWORD PTR [esi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [ebp+8]
	mov	edx, edi
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN105@CheckMVdir
$LN69@CheckMVdir:
	cmp	eax, 1
	mov	eax, DWORD PTR [esi+164]
	jne	SHORT $LN67@CheckMVdir
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+8]
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+28], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+28]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN68@CheckMVdir
$LN67@CheckMVdir:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebp+20]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [ebp+8]
	mov	edx, edi
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	esi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN105@CheckMVdir:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	imul	edi, DWORD PTR [ebx+12]
	shl	esi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, esi
	mov	esi, DWORD PTR _this$1$[esp+32]
	add	ecx, edi
	mov	edi, DWORD PTR _vy$[esp+28]
$LN68@CheckMVdir:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [esi+216], 0
	jne	SHORT $LN94@CheckMVdir
	push	DWORD PTR [esi+180]
	mov	eax, DWORD PTR [esi+80]
	push	ecx
	push	DWORD PTR [esi+168]
	push	DWORD PTR [ebp+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN106@CheckMVdir
$LN94@CheckMVdir:
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN106@CheckMVdir:

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	esi, DWORD PTR [ebp+116]

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	mov	ebx, eax

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	esi, DWORD PTR _vx$[esp+28]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	mov	ecx, 16					; 00000010H

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	eax, DWORD PTR [ebp+120]

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sub	ecx, DWORD PTR [ebp+400]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	sub	eax, edi

; 1737 :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, vx, vy), nRefPitch[2]) : 0;
; 1738 :     sad_t sad = LumaSAD(workarea, GetRefBlock(workarea, vx, vy));
; 1739 :     sad += saduv;

	add	ebx, DWORD PTR _saduv$1$[esp+28]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	imul	eax, eax
	imul	esi, esi
	add	esi, eax

; 1740 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(int64_t)sad) >> 8); // v1.5.8

	mov	eax, ebx

; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	imul	esi, DWORD PTR [ebp+384]
	sar	esi, cl

; 1740 :     sad_t cost = sad + workarea.MotionDistorsion(vx, vy) + ((penaltyNew*(int64_t)sad) >> 8); // v1.5.8

	mov	ecx, DWORD PTR _this$1$[esp+32]
	add	esi, ebx
	imul	DWORD PTR [ecx+236]
	shrd	eax, edx, 8
	add	eax, esi
	sar	edx, 8

; 1741 : //		if (sad > LSAD/4) DebugPrintf("%d %d %d %d %d %d %d", workarea.blkIdx, vx, vy, val, workarea.nMinCost, cost, sad);
; 1742 : //		int cost = sad + sad*workarea.MotionDistorsion(vx, vy)/(nBlkSizeX*nBlkSizeY*4) + ((penaltyNew*sad)>>8); // v1.5.8
; 1743 :     if (cost < workarea.nMinCost)

	cmp	eax, DWORD PTR [ebp+112]
	jge	SHORT $LN102@CheckMVdir

; 1744 :     {
; 1745 :       workarea.bestMV.sad = sad;
; 1746 :       workarea.nMinCost = cost;
; 1747 :       *dir = val;

	mov	ecx, DWORD PTR _val$[esp+28]
	mov	DWORD PTR [ebp+112], eax
	mov	eax, DWORD PTR _dir$[esp+28]
	mov	DWORD PTR [ebp+108], ebx
	mov	DWORD PTR [eax], ecx
$LN102@CheckMVdir:
	pop	ebx
$LN101@CheckMVdir:
	pop	edi
$LN3@CheckMVdir:
	pop	esi
	pop	ebp

; 1748 :     }
; 1749 :   }
; 1750 : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?CheckMVdir@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHPAHH@Z ENDP ; PlaneOfBlocks::CheckMVdir
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?ClipMVx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@H@Z
_TEXT	SEGMENT
_vx$ = 8						; size = 4
?ClipMVx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@H@Z PROC	; PlaneOfBlocks::ClipMVx, COMDAT
; _workarea$ = ecx

; 1755 :   //	return imin(workarea.nDxMax - 1, imax(workarea.nDxMin, vx));
; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;
; 1757 :   else if (vx >= workarea.nDxMax) return workarea.nDxMax - 1;

	mov	ecx, DWORD PTR [ecx+376]
	mov	eax, DWORD PTR _vx$[esp-4]
	cmp	eax, ecx
	jl	SHORT $LN8@ClipMVx
	lea	eax, DWORD PTR [ecx-1]
$LN8@ClipMVx:

; 1758 :   else return vx;
; 1759 : }

	ret	4
?ClipMVx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@H@Z ENDP	; PlaneOfBlocks::ClipMVx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?ClipMVy@PlaneOfBlocks@@AAEHAAVWorkingArea@1@H@Z
_TEXT	SEGMENT
_vy$ = 8						; size = 4
?ClipMVy@PlaneOfBlocks@@AAEHAAVWorkingArea@1@H@Z PROC	; PlaneOfBlocks::ClipMVy, COMDAT
; _workarea$ = ecx

; 1764 :   //	return imin(workarea.nDyMax - 1, imax(workarea.nDyMin, vy));
; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;
; 1766 :   else if (vy >= workarea.nDyMax) return workarea.nDyMax - 1;

	mov	ecx, DWORD PTR [ecx+380]
	mov	eax, DWORD PTR _vy$[esp-4]
	cmp	eax, ecx
	jl	SHORT $LN8@ClipMVy
	lea	eax, DWORD PTR [ecx-1]
$LN8@ClipMVy:

; 1767 :   else return vy;
; 1768 : }

	ret	4
?ClipMVy@PlaneOfBlocks@@AAEHAAVWorkingArea@1@H@Z ENDP	; PlaneOfBlocks::ClipMVy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_workarea$ = 12						; size = 4
_v$ = 16						; size = 12
?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z PROC ; PlaneOfBlocks::ClipMV, COMDAT
; _this$dead$ = ecx

; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;

	mov	ecx, DWORD PTR _workarea$[esp-4]
	mov	edx, DWORD PTR _v$[esp-4]
	mov	eax, DWORD PTR [ecx+368]
	cmp	edx, eax
	jl	SHORT $LN7@ClipMV

; 1757 :   else if (vx >= workarea.nDxMax) return workarea.nDxMax - 1;

	mov	eax, DWORD PTR [ecx+376]
	cmp	edx, eax
	jl	SHORT $LN6@ClipMV
	dec	eax
	jmp	SHORT $LN7@ClipMV
$LN6@ClipMV:

; 1758 :   else return vx;

	mov	eax, edx
$LN7@ClipMV:

; 1773 :   VECTOR v2;
; 1774 :   v2.x = ClipMVx(workarea, v.x);

	mov	edx, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	mov	esi, DWORD PTR _v$[esp+4]

; 1773 :   VECTOR v2;
; 1774 :   v2.x = ClipMVx(workarea, v.x);

	mov	DWORD PTR [edx], eax

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	mov	eax, DWORD PTR [ecx+372]
	cmp	esi, eax
	jl	SHORT $LN13@ClipMV

; 1766 :   else if (vy >= workarea.nDyMax) return workarea.nDyMax - 1;

	mov	eax, DWORD PTR [ecx+380]
	cmp	esi, eax
	jl	SHORT $LN12@ClipMV

; 1776 :   v2.sad = v.sad;

	mov	ecx, DWORD PTR _v$[esp+8]

; 1766 :   else if (vy >= workarea.nDyMax) return workarea.nDyMax - 1;

	dec	eax

; 1775 :   v2.y = ClipMVy(workarea, v.y);

	mov	DWORD PTR [edx+4], eax

; 1777 :   return v2;

	mov	eax, edx
	mov	DWORD PTR [edx+8], ecx
	pop	esi

; 1778 : }

	ret	20					; 00000014H
$LN12@ClipMV:

; 1767 :   else return vy;

	mov	eax, esi
$LN13@ClipMV:

; 1776 :   v2.sad = v.sad;

	mov	ecx, DWORD PTR _v$[esp+8]
	mov	DWORD PTR [edx+4], eax

; 1777 :   return v2;

	mov	eax, edx
	mov	DWORD PTR [edx+8], ecx
	pop	esi

; 1778 : }

	ret	20					; 00000014H
?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ENDP ; PlaneOfBlocks::ClipMV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?Median@PlaneOfBlocks@@CAHHHH@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?Median@PlaneOfBlocks@@CAHHHH@Z PROC			; PlaneOfBlocks::Median, COMDAT
; _a$ = ecx
; _b$ = edx

; 1784 :   //	return a + b + c - imax(a, imax(b, c)) - imin(c, imin(a, b));
; 1785 :   if (a < b)
; 1786 :   {
; 1787 :     if (b < c) return b;

	mov	eax, DWORD PTR _c$[esp-4]
	cmp	ecx, edx
	jge	SHORT $LN2@Median
	cmp	edx, eax
	jl	SHORT $LN13@Median

; 1788 :     else if (a < c) return c;

	cmp	ecx, eax
	cmovl	ecx, eax
$LN14@Median:
	mov	eax, ecx

; 1794 :     else return b;
; 1795 :   }
; 1796 : }

	ret	0
$LN2@Median:

; 1789 :     else return a;
; 1790 :   }
; 1791 :   else {
; 1792 :     if (a < c) return a;

	cmp	ecx, eax
	jl	SHORT $LN14@Median

; 1793 :     else if (b < c) return c;

	cmp	edx, eax
	cmovl	edx, eax
$LN13@Median:
	mov	eax, edx

; 1794 :     else return b;
; 1795 :   }
; 1796 : }

	ret	0
?Median@PlaneOfBlocks@@CAHHHH@Z ENDP			; PlaneOfBlocks::Median
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?SquareDifferenceNorm@PlaneOfBlocks@@CAIABUVECTOR@@HH@Z
_TEXT	SEGMENT
_v2y$ = 8						; size = 4
?SquareDifferenceNorm@PlaneOfBlocks@@CAIABUVECTOR@@HH@Z PROC ; PlaneOfBlocks::SquareDifferenceNorm, COMDAT
; _v1$ = ecx
; _v2x$ = edx

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	sub	eax, edx
	sub	esi, DWORD PTR _v2y$[esp]
	imul	esi, esi
	imul	eax, eax
	add	eax, esi
	pop	esi

; 1808 : }

	ret	0
?SquareDifferenceNorm@PlaneOfBlocks@@CAIABUVECTOR@@HH@Z ENDP ; PlaneOfBlocks::SquareDifferenceNorm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.h
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?search_mv_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_this$1$ = -120						; size = 4
_pBlkData$1$ = -116					; size = 4
_outfilebuf$1$ = -112					; size = 4
tv2507 = -108						; size = 4
tv2432 = -108						; size = 4
_nBlkSizeX_Ovr$3$ = -104				; size = 4
_blkxStart$1$ = -100					; size = 4
_nBlkSizeX_Ovr$1$ = -96					; size = 4
_iblkx$1$ = -92						; size = 4
$T1 = -88						; size = 4
tv2506 = -84						; size = 4
_nBlkSizeY_Ovr$1$ = -80					; size = 4
_val_old$2 = -80					; size = 8
_val_old$3 = -80					; size = 8
_nBlkSizeY_Ovr$3$ = -72					; size = 4
_val_new$4 = -72					; size = 8
_val_new$5 = -72					; size = 8
_v$ = -64						; size = 12
$T6 = -52						; size = 12
_v$ = -40						; size = 12
$T7 = -28						; size = 12
_ftor$8 = -16						; size = 16
_ftor$9 = -16						; size = 16
$T10 = -16						; size = 12
_td$ = 8						; size = 4
?search_mv_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z PROC ; PlaneOfBlocks::search_mv_slice, COMDAT
; _this$ = ecx

; 1819 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 124				; 0000007cH
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[esp+136], ebx

; 1820 :   assert(&td != 0);
; 1821 : 
; 1822 :   short *			outfilebuf = _outfilebuf;

	mov	edi, DWORD PTR [ebx+300]

; 1823 : 
; 1824 :   WorkingArea &	workarea = *(_workarea_pool.take_obj());

	lea	ecx, DWORD PTR [ebx+376]
	mov	DWORD PTR _outfilebuf$1$[esp+136], edi
	call	?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::take_obj

; 1825 :   assert(&workarea != 0);
; 1826 : 
; 1827 :   workarea.blky_beg = td._y_beg;

	mov	edx, DWORD PTR _td$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+80], eax

; 1828 :   workarea.blky_end = td._y_end;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+84], eax

; 1829 : 
; 1830 :   workarea.DCT = 0;

	mov	DWORD PTR [esi+48], 0

; 1831 : #ifdef ALLOW_DCT
; 1832 :   if (_dct_pool_ptr != 0)

	mov	ecx, DWORD PTR [ebx+128]
	test	ecx, ecx
	je	SHORT $LN8@search_mv_

; 1833 :   {
; 1834 :     workarea.DCT = _dct_pool_ptr->take_obj();

	call	?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ ; conc::ObjPool<DCTClass>::take_obj
	mov	DWORD PTR [esi+48], eax
$LN8@search_mv_:

; 1835 :   }
; 1836 : #endif	// ALLOW_DCT
; 1837 : 
; 1838 :   int *pBlkData = _out + 1 + workarea.blky_beg * nBlkX*N_PER_BLOCK;

	mov	edx, DWORD PTR [esi+80]
	imul	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+296]
	lea	ecx, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, 4
	mov	DWORD PTR _pBlkData$1$[esp+136], eax

; 1839 :   if (outfilebuf != NULL)

	test	edi, edi
	je	SHORT $LN9@search_mv_

; 1840 :   {
; 1841 :     outfilebuf += workarea.blky_beg * nBlkX * 4;// 4 short word per block

	lea	edi, DWORD PTR [edi+edx*8]
	mov	DWORD PTR _outfilebuf$1$[esp+136], edi
$LN9@search_mv_:

; 1844 :   workarea.y[0] = pSrcFrame->GetPlane(YPLANE)->GetVPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1844 :   workarea.y[0] = pSrcFrame->GetPlane(YPLANE)->GetVPadding();

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], ecx

; 1845 :   workarea.y[0] += workarea.blky_beg * (nBlkSizeY - nOverlapY);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	imul	eax, DWORD PTR [esi+80]
	add	eax, ecx
	mov	DWORD PTR [esi+20], eax
; File c:\github\mvtools\sources\mvframe.h

; 78   :    inline int GetMode() { return nMode; }

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1847 :   if (pSrcFrame->GetMode() & UPLANE)

	test	BYTE PTR [eax+12], 2
	je	SHORT $LN10@search_mv_
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1849 :     workarea.y[1] = pSrcFrame->GetPlane(UPLANE)->GetVPadding();

	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+24], edx

; 1850 :     workarea.y[1] += workarea.blky_beg * ((nBlkSizeY - nOverlapY) >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR [ebx+60]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+80]
	add	eax, edx
	mov	DWORD PTR [esi+24], eax
$LN10@search_mv_:
; File c:\github\mvtools\sources\mvframe.h

; 78   :    inline int GetMode() { return nMode; }

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1852 :   if (pSrcFrame->GetMode() & VPLANE)

	test	BYTE PTR [eax+12], 4
	je	SHORT $LN11@search_mv_
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1854 :     workarea.y[2] = pSrcFrame->GetPlane(VPLANE)->GetVPadding();

	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+28], edx

; 1855 :     workarea.y[2] += workarea.blky_beg * ((nBlkSizeY - nOverlapY) >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR [ebx+60]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+80]
	add	eax, edx
	mov	DWORD PTR [esi+28], eax
$LN11@search_mv_:

; 1856 :   }
; 1857 : 
; 1858 :   workarea.planeSAD = 0;

	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0

; 1859 :   workarea.sumLumaChange = 0;

	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+76], 0

; 1860 : 
; 1861 :   // Functions using float must not be used here
; 1862 : 
; 1863 :   int nBlkSizeX_Ovr[3] = { (nBlkSizeX - nOverlapX), (nBlkSizeX - nOverlapX) >> nLogxRatioUV, (nBlkSizeX - nOverlapX) >> nLogxRatioUV };

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR _nBlkSizeX_Ovr$1$[esp+136], eax
	sar	eax, cl

; 1864 :   int nBlkSizeY_Ovr[3] = { (nBlkSizeY - nOverlapY), (nBlkSizeY - nOverlapY) >> nLogyRatioUV, (nBlkSizeY - nOverlapY) >> nLogyRatioUV };

	mov	ecx, DWORD PTR [ebx+60]
	mov	DWORD PTR _nBlkSizeX_Ovr$3$[esp+136], eax
	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR _nBlkSizeY_Ovr$1$[esp+136], eax
	sar	eax, cl
	mov	DWORD PTR _nBlkSizeY_Ovr$3$[esp+136], eax

; 1865 : 
; 1866 :   for (workarea.blky = workarea.blky_beg; workarea.blky < workarea.blky_end; workarea.blky++)

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [esi+36], eax
	cmp	eax, DWORD PTR [esi+84]
	jge	$LN3@search_mv_
	mov	edx, DWORD PTR _pBlkData$1$[esp+136]
	npad	7
$LL4@search_mv_:

; 1867 :   {
; 1868 :     workarea.blkScanDir = (workarea.blky % 2 == 0 || !_meander_flag) ? 1 : -1;

	mov	eax, DWORD PTR [esi+36]
	and	eax, 1
	je	SHORT $LN30@search_mv_
	cmp	BYTE PTR [ebx+308], 0
	je	SHORT $LN30@search_mv_
	or	ecx, -1
	jmp	SHORT $LN31@search_mv_
$LN30@search_mv_:
	mov	ecx, 1
$LN31@search_mv_:
	mov	DWORD PTR [esi+44], ecx
	test	eax, eax

; 1869 :     // meander (alternate) scan blocks (even row left to right, odd row right to left)
; 1870 :     int blkxStart = (workarea.blky % 2 == 0 || !_meander_flag) ? 0 : nBlkX - 1;

	je	SHORT $LN32@search_mv_
	cmp	BYTE PTR [ebx+308], 0
	je	SHORT $LN32@search_mv_
	mov	eax, DWORD PTR [ebx]
	dec	eax
	mov	DWORD PTR _blkxStart$1$[esp+136], eax
	jmp	SHORT $LN33@search_mv_
$LN32@search_mv_:
	mov	DWORD PTR _blkxStart$1$[esp+136], 0
$LN33@search_mv_:

; 1872 :     {
; 1873 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1871 :     if (workarea.blkScanDir == 1) // start with leftmost block

	cmp	ecx, 1
	jne	SHORT $LN12@search_mv_

; 1872 :     {
; 1873 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+8], eax

; 1874 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	SHORT $LN15@search_mv_

; 1876 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1876 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], eax

; 1877 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1877 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], eax

; 1878 :       }
; 1879 :     }
; 1880 :     else // start with rightmost block, but it is already set at prev row

	jmp	SHORT $LN15@search_mv_
$LN12@search_mv_:

; 1881 :     {
; 1882 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding() + nBlkSizeX_Ovr[0]*(nBlkX - 1);

	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$1$[esp+136]
	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+8], ecx

; 1883 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	SHORT $LN15@search_mv_

; 1885 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding() + nBlkSizeX_Ovr[1]*(nBlkX - 1);

	mov	eax, DWORD PTR [ebx+160]
	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$3$[esp+136]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1885 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding() + nBlkSizeX_Ovr[1]*(nBlkX - 1);

	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], ecx

; 1886 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding() + nBlkSizeX_Ovr[2]*(nBlkX - 1);

	mov	eax, DWORD PTR [ebx+160]
	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$3$[esp+136]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1886 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding() + nBlkSizeX_Ovr[2]*(nBlkX - 1);

	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], ecx
$LN15@search_mv_:

; 1887 :       }
; 1888 :     }
; 1889 : 
; 1890 :     const bool bit8 = (pixelsize == 1);

	mov	eax, DWORD PTR [ebx+64]

; 1891 : 
; 1892 :     for (int iblkx = 0; iblkx < nBlkX; iblkx++)

	xor	ecx, ecx
	mov	DWORD PTR tv2506[esp+136], eax
	mov	DWORD PTR _iblkx$1$[esp+136], ecx
	cmp	DWORD PTR [ebx], ecx
	jle	$LN6@search_mv_
	npad	4
$LL7@search_mv_:

; 1893 :     {
; 1894 :       workarea.blkx = blkxStart + iblkx*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, ecx
	mov	ecx, DWORD PTR _blkxStart$1$[esp+136]
	add	ecx, eax

; 1895 :       workarea.blkIdx = workarea.blky*nBlkX + workarea.blkx;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+32], ecx
	imul	eax, DWORD PTR [ebx]

; 1896 :       workarea.iter = 0;

	mov	DWORD PTR [esi+388], 0
	add	eax, ecx
	mov	DWORD PTR [esi+40], eax

; 1897 :       //			DebugPrintf("BlkIdx = %d \n", workarea.blkIdx);
; 1898 :       PROFILE_START(MOTION_PROFILE_ME);
; 1899 : 
; 1900 :       // Resets the global predictor (it may have been clipped during the
; 1901 :       // previous block scan)
; 1902 :       workarea.globalMVPredictor = _glob_mv_pred_def;

	movq	xmm0, QWORD PTR [ebx+280]
	movq	QWORD PTR [esi+52], xmm0
	mov	eax, DWORD PTR [ebx+288]
	mov	DWORD PTR [esi+60], eax

; 1906 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	add	eax, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1906 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);

	mov	DWORD PTR [esi+88], eax

; 1907 :       //create aligned copy
; 1908 :       BLITLUMA(workarea.pSrc_temp[0], nSrcPitch[0], workarea.pSrc[0], nSrcPitch_plane[0]);

	push	DWORD PTR [ebx+192]
	push	eax
	push	DWORD PTR [ebx+168]
	mov	eax, DWORD PTR [ebx+92]
	push	DWORD PTR [esi+440]
	call	eax

; 1909 :       //set the to the aligned copy
; 1910 :       workarea.pSrc[0] = workarea.pSrc_temp[0];

	mov	eax, DWORD PTR [esi+440]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+88], eax

; 1911 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	$LN16@search_mv_

; 1913 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	add	eax, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1913 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);

	mov	DWORD PTR [esi+92], eax

; 1914 :         BLITCHROMA(workarea.pSrc_temp[1], nSrcPitch[1], workarea.pSrc[1], nSrcPitch_plane[1]);

	push	DWORD PTR [ebx+196]
	push	eax
	push	DWORD PTR [ebx+172]
	mov	eax, DWORD PTR [ebx+96]
	push	DWORD PTR [esi+444]
	call	eax

; 1915 :         workarea.pSrc[1] = workarea.pSrc_temp[1];

	mov	eax, DWORD PTR [esi+444]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1915 :         workarea.pSrc[1] = workarea.pSrc_temp[1];

	mov	DWORD PTR [esi+92], eax

; 1916 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	add	eax, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1916 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);

	mov	DWORD PTR [esi+96], eax

; 1917 :         BLITCHROMA(workarea.pSrc_temp[2], nSrcPitch[2], workarea.pSrc[2], nSrcPitch_plane[2]);

	push	DWORD PTR [ebx+200]
	push	eax
	push	DWORD PTR [ebx+176]
	mov	eax, DWORD PTR [ebx+96]
	push	DWORD PTR [esi+448]
	call	eax

; 1918 :         workarea.pSrc[2] = workarea.pSrc_temp[2];

	mov	eax, DWORD PTR [esi+448]
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+96], eax
$LN16@search_mv_:

; 1919 :       }
; 1920 : #else	// ALIGN_SOURCEBLOCK
; 1921 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);
; 1922 :       if (chroma)
; 1923 :       {
; 1924 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);
; 1925 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);
; 1926 :       }
; 1927 : #endif	// ALIGN_SOURCEBLOCK
; 1928 : 
; 1929 :       if (workarea.blky == workarea.blky_beg)

	mov	eax, DWORD PTR [esi+36]
	cmp	eax, DWORD PTR [esi+80]
	jne	SHORT $LN17@search_mv_

; 1930 :       {
; 1931 :         workarea.nLambda = 0;

	mov	DWORD PTR [esi+384], 0

; 1932 :       }
; 1933 :       else

	jmp	SHORT $LN18@search_mv_
$LN17@search_mv_:

; 1934 :       {
; 1935 :         workarea.nLambda = _lambda_level;

	mov	eax, DWORD PTR [ebx+292]
	mov	DWORD PTR [esi+384], eax
$LN18@search_mv_:

; 1943 :       int nHPaddingScaled = pSrcFrame->GetPlane(YPLANE)->GetHPadding() >> nLogScale;

	mov	edx, DWORD PTR [ebx+160]
	mov	eax, DWORD PTR [ebx+312]
	mov	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR [ebx+236], eax
	mov	eax, DWORD PTR [ebx+316]
	mov	DWORD PTR [ebx+232], eax
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [edx]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1943 :       int nHPaddingScaled = pSrcFrame->GetPlane(YPLANE)->GetHPadding() >> nLogScale;

	mov	edi, DWORD PTR [eax+16]

; 1944 :       int nVPaddingScaled = pSrcFrame->GetPlane(YPLANE)->GetVPadding() >> nLogScale;

	mov	ebx, DWORD PTR [eax+20]
	sar	ebx, cl
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 115  :    inline int GetExtendedWidth() const { return nExtendedWidth; }

	mov	ecx, DWORD PTR [eax+36]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1946 :       workarea.nDxMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedWidth() - workarea.x[0] - nBlkSizeX - pSrcFrame->GetPlane(YPLANE)->GetHPadding() + nHPaddingScaled);

	sub	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _this$1$[esp+136]
	sub	ecx, DWORD PTR [eax+8]
	add	ecx, edi
	imul	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+376], ecx

; 1947 :       workarea.nDyMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedHeight() - workarea.y[0] - nBlkSizeY - pSrcFrame->GetPlane(YPLANE)->GetVPadding() + nVPaddingScaled);

	mov	ecx, DWORD PTR [eax+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [ecx]
; File c:\github\mvtools\sources\mvplane.h

; 116  :    inline int GetExtendedHeight() const { return nExtendedHeight; }

	mov	edx, DWORD PTR [eax+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1947 :       workarea.nDyMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedHeight() - workarea.y[0] - nBlkSizeY - pSrcFrame->GetPlane(YPLANE)->GetVPadding() + nVPaddingScaled);

	sub	edx, DWORD PTR [eax+20]
	sub	edx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _this$1$[esp+136]
	sub	edx, DWORD PTR [eax+12]
	add	edx, ebx
	imul	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+380], edx

; 1948 :       workarea.nDxMin = -nPel * (workarea.x[0] - pSrcFrame->GetPlane(YPLANE)->GetHPadding() + nHPaddingScaled);

	mov	eax, DWORD PTR [eax+160]
	mov	ecx, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1948 :       workarea.nDxMin = -nPel * (workarea.x[0] - pSrcFrame->GetPlane(YPLANE)->GetHPadding() + nHPaddingScaled);

	sub	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _this$1$[esp+136]
	add	ecx, edi
	imul	ecx, DWORD PTR [eax+20]
	neg	ecx
	mov	DWORD PTR [esi+368], ecx

; 1949 :       workarea.nDyMin = -nPel * (workarea.y[0] - pSrcFrame->GetPlane(YPLANE)->GetVPadding() + nVPaddingScaled);

	mov	eax, DWORD PTR [eax+160]
	mov	edx, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1949 :       workarea.nDyMin = -nPel * (workarea.y[0] - pSrcFrame->GetPlane(YPLANE)->GetVPadding() + nVPaddingScaled);

	sub	edx, DWORD PTR [eax+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1949 :       workarea.nDyMin = -nPel * (workarea.y[0] - pSrcFrame->GetPlane(YPLANE)->GetVPadding() + nVPaddingScaled);

	add	edx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+136]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edi, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1949 :       workarea.nDyMin = -nPel * (workarea.y[0] - pSrcFrame->GetPlane(YPLANE)->GetVPadding() + nVPaddingScaled);

	imul	edx, DWORD PTR [ebx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	edi, 2
	mov	DWORD PTR tv2432[esp+136], edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1949 :       workarea.nDyMin = -nPel * (workarea.y[0] - pSrcFrame->GetPlane(YPLANE)->GetVPadding() + nVPaddingScaled);

	neg	edx
	mov	DWORD PTR [esi+372], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [ebx+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1952 :       workarea.predictor = ClipMV(workarea, vectors[workarea.blkIdx]);

	movq	xmm0, QWORD PTR [eax+edi]
	mov	eax, DWORD PTR [eax+edi+8]
	movq	QWORD PTR _v$[esp+136], xmm0
	mov	DWORD PTR $T1[esp+136], eax

; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;

	mov	eax, DWORD PTR _v$[esp+136]
	cmp	eax, ecx
	jge	SHORT $LN192@search_mv_
	mov	eax, ecx
	jmp	SHORT $LN195@search_mv_
$LN192@search_mv_:

; 1757 :   else if (vx >= workarea.nDxMax) return workarea.nDxMax - 1;

	mov	edi, DWORD PTR [esi+376]
	cmp	eax, edi
	jl	SHORT $LN194@search_mv_
	lea	eax, DWORD PTR [edi-1]
$LN194@search_mv_:
	mov	edi, DWORD PTR tv2432[esp+136]
$LN195@search_mv_:

; 1774 :   v2.x = ClipMVx(workarea, v.x);

	mov	DWORD PTR $T6[esp+136], eax

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	mov	eax, DWORD PTR _v$[esp+140]
	cmp	eax, edx
	jl	SHORT $LN201@search_mv_

; 1766 :   else if (vy >= workarea.nDyMax) return workarea.nDyMax - 1;

	mov	edx, DWORD PTR [esi+380]
	cmp	eax, edx
	jl	SHORT $LN200@search_mv_
	dec	edx
	jmp	SHORT $LN201@search_mv_
$LN200@search_mv_:

; 1767 :   else return vy;

	mov	edx, eax
$LN201@search_mv_:

; 1952 :       workarea.predictor = ClipMV(workarea, vectors[workarea.blkIdx]);

	mov	eax, DWORD PTR $T1[esp+136]

; 1775 :   v2.y = ClipMVy(workarea, v.y);

	mov	DWORD PTR $T6[esp+140], edx

; 1952 :       workarea.predictor = ClipMV(workarea, vectors[workarea.blkIdx]);

	movq	xmm0, QWORD PTR $T6[esp+136]
	movq	QWORD PTR [esi+116], xmm0
	mov	DWORD PTR [esi+124], eax

; 1953 :       if (temporal)

	cmp	BYTE PTR [ebx+260], 0
	je	SHORT $LN19@search_mv_

; 1954 :       {
; 1955 :         workarea.predictors[4] = ClipMV(workarea, *reinterpret_cast<VECTOR*>(&_vecPrev[workarea.blkIdx*N_PER_BLOCK])); // temporal predictor

	mov	eax, DWORD PTR [ebx+304]
	movq	xmm0, QWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax+edi+8]
	movq	QWORD PTR _v$[esp+136], xmm0

; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;

	mov	eax, DWORD PTR _v$[esp+136]
	cmp	eax, ecx
	jl	SHORT $LN209@search_mv_

; 1757 :   else if (vx >= workarea.nDxMax) return workarea.nDxMax - 1;

	mov	ecx, DWORD PTR [esi+376]
	cmp	eax, ecx
	jl	SHORT $LN208@search_mv_
	dec	ecx
	jmp	SHORT $LN209@search_mv_
$LN208@search_mv_:

; 1758 :   else return vx;

	mov	ecx, eax
$LN209@search_mv_:

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	mov	eax, DWORD PTR [esi+372]

; 1774 :   v2.x = ClipMVx(workarea, v.x);

	mov	DWORD PTR $T7[esp+136], ecx

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	mov	ecx, DWORD PTR _v$[esp+140]
	cmp	ecx, eax
	jl	SHORT $LN215@search_mv_

; 1766 :   else if (vy >= workarea.nDyMax) return workarea.nDyMax - 1;

	mov	eax, DWORD PTR [esi+380]
	cmp	ecx, eax
	jl	SHORT $LN214@search_mv_
	dec	eax
	jmp	SHORT $LN215@search_mv_
$LN214@search_mv_:

; 1767 :   else return vy;

	mov	eax, ecx
$LN215@search_mv_:

; 1775 :   v2.y = ClipMVy(workarea, v.y);

	mov	DWORD PTR $T7[esp+140], eax

; 1954 :       {
; 1955 :         workarea.predictors[4] = ClipMV(workarea, *reinterpret_cast<VECTOR*>(&_vecPrev[workarea.blkIdx*N_PER_BLOCK])); // temporal predictor

	movq	xmm0, QWORD PTR $T7[esp+136]
	movq	QWORD PTR [esi+176], xmm0
	mov	DWORD PTR [esi+184], edx

; 1956 :       }
; 1957 :       else

	jmp	SHORT $LN20@search_mv_
$LN19@search_mv_:

; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;

	test	ecx, ecx
	jg	SHORT $LN223@search_mv_

; 1757 :   else if (vx >= workarea.nDxMax) return workarea.nDxMax - 1;

	mov	ecx, DWORD PTR [esi+376]
	test	ecx, ecx
	jg	SHORT $LN222@search_mv_
	dec	ecx
	jmp	SHORT $LN223@search_mv_
$LN222@search_mv_:

; 1758 :   else return vx;

	xor	ecx, ecx
$LN223@search_mv_:

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	mov	eax, DWORD PTR [esi+372]

; 1774 :   v2.x = ClipMVx(workarea, v.x);

	mov	DWORD PTR $T10[esp+136], ecx

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	test	eax, eax
	jg	SHORT $LN229@search_mv_

; 1766 :   else if (vy >= workarea.nDyMax) return workarea.nDyMax - 1;

	mov	eax, DWORD PTR [esi+380]
	test	eax, eax
	jg	SHORT $LN228@search_mv_
	dec	eax
	jmp	SHORT $LN229@search_mv_
$LN228@search_mv_:

; 1767 :   else return vy;

	xor	eax, eax
$LN229@search_mv_:

; 1775 :   v2.y = ClipMVy(workarea, v.y);

	mov	DWORD PTR $T10[esp+140], eax

; 1958 :       {
; 1959 :         workarea.predictors[4] = ClipMV(workarea, zeroMV);

	movq	xmm0, QWORD PTR $T10[esp+136]
	movq	QWORD PTR [esi+176], xmm0
	mov	DWORD PTR [esi+184], -1
$LN20@search_mv_:

; 1960 :       }
; 1961 : 
; 1962 :       if(bit8)
; 1963 :         PseudoEPZSearch<uint8_t>(workarea);

	cmp	DWORD PTR tv2506[esp+136], 1
	mov	ecx, ebx
	push	esi
	jne	SHORT $LN21@search_mv_
	call	??$PseudoEPZSearch@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ; PlaneOfBlocks::PseudoEPZSearch<unsigned char>

; 1964 :       else

	jmp	SHORT $LN22@search_mv_
$LN21@search_mv_:

; 1965 :         PseudoEPZSearch<uint16_t>(workarea);

	call	??$PseudoEPZSearch@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ; PlaneOfBlocks::PseudoEPZSearch<unsigned short>
$LN22@search_mv_:

; 1966 :       //			workarea.bestMV = zeroMV; // debug
; 1967 : 
; 1968 :       if (outfilebuf != NULL) // write vector to outfile

	mov	edi, DWORD PTR _outfilebuf$1$[esp+136]
	test	edi, edi
	je	SHORT $LN23@search_mv_

; 1969 :       {
; 1970 :         outfilebuf[workarea.blkx * 4 + 0] = workarea.bestMV.x;

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+100]
	mov	WORD PTR [edi+ecx*8], ax

; 1971 :         outfilebuf[workarea.blkx * 4 + 1] = workarea.bestMV.y;

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+104]
	mov	WORD PTR [edi+ecx*8+2], ax

; 1972 :         outfilebuf[workarea.blkx * 4 + 2] = (*(uint32_t *)(&workarea.bestMV.sad) & 0x0000ffff); // low word

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+108]
	mov	WORD PTR [edi+ecx*8+4], ax

; 1973 :         outfilebuf[workarea.blkx * 4 + 3] = (*(uint32_t *)(&workarea.bestMV.sad) >> 16);     // high word, usually null

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+110]
	mov	WORD PTR [edi+ecx*8+6], ax
$LN23@search_mv_:

; 1974 :       }
; 1975 : 
; 1976 :       /* write the results */
; 1977 :       pBlkData[workarea.blkx*N_PER_BLOCK + 0] = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR _pBlkData$1$[esp+136]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [edx+ecx*4], eax

; 1978 :       pBlkData[workarea.blkx*N_PER_BLOCK + 1] = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 1979 :       pBlkData[workarea.blkx*N_PER_BLOCK + 2] = *(uint32_t *)(&workarea.bestMV.sad);

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 1980 : 
; 1981 :       PROFILE_STOP(MOTION_PROFILE_ME);
; 1982 : 
; 1983 : 
; 1984 :       if (smallestPlane)

	cmp	BYTE PTR [ebx+120], 0
	je	$LN24@search_mv_

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [esi+8]
	cmp	eax, 2
	jne	SHORT $LN235@search_mv_
	mov	eax, DWORD PTR [ebx+164]
	add	edi, edi
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	add	eax, eax
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	eax, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN284@search_mv_
$LN235@search_mv_:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jne	SHORT $LN233@search_mv_
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN285@search_mv_
$LN233@search_mv_:
	mov	eax, DWORD PTR [esi+20]
	shl	edi, 2
	shl	eax, 2
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	eax, 2
$LN284@search_mv_:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
$LN285@search_mv_:
	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2004 :         workarea.sumLumaChange += (bigsad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (bigsad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [ebx+168]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	edi, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2004 :         workarea.sumLumaChange += (bigsad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (bigsad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [esi+88]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2004 :         workarea.sumLumaChange += (bigsad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (bigsad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	mov	eax, DWORD PTR [ebx+84]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	DWORD PTR tv2507[esp+144], edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2004 :         workarea.sumLumaChange += (bigsad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (bigsad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	call	eax
	mov	ebx, DWORD PTR [esi+72]
	mov	edi, DWORD PTR [esi+76]
	sub	ebx, eax
	mov	eax, DWORD PTR _this$1$[esp+144]
	sbb	edi, 0
	push	DWORD PTR [eax+180]
	mov	eax, DWORD PTR [eax+84]
	push	DWORD PTR tv2507[esp+148]
	call	eax
	add	esp, 16					; 00000010H
	xor	ecx, ecx
	add	eax, ebx
	mov	ebx, DWORD PTR _this$1$[esp+136]
	mov	DWORD PTR [esi+72], eax
	adc	ecx, edi
	mov	edi, DWORD PTR _outfilebuf$1$[esp+136]
	mov	DWORD PTR [esi+76], ecx
$LN24@search_mv_:

; 2005 :       }
; 2006 : 
; 2007 :       /* increment indexes & pointers */
; 2008 :       if (iblkx < nBlkX - 1)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _iblkx$1$[esp+136]
	dec	eax
	cmp	ecx, eax
	jge	SHORT $LN5@search_mv_

; 2009 :       {
; 2010 :         workarea.x[0] += nBlkSizeX_Ovr[0]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$1$[esp+136]
	add	DWORD PTR [esi+8], eax

; 2011 :         workarea.x[1] += nBlkSizeX_Ovr[1]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$3$[esp+136]
	add	DWORD PTR [esi+12], eax

; 2012 :         workarea.x[2] += nBlkSizeX_Ovr[2]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$3$[esp+136]
	add	DWORD PTR [esi+16], eax
$LN5@search_mv_:

; 1891 : 
; 1892 :     for (int iblkx = 0; iblkx < nBlkX; iblkx++)

	inc	ecx
	mov	DWORD PTR _iblkx$1$[esp+136], ecx
	cmp	ecx, DWORD PTR [ebx]
	jl	$LL7@search_mv_
	mov	edx, DWORD PTR _pBlkData$1$[esp+136]
$LN6@search_mv_:

; 2013 :       }
; 2014 :     }	// for iblkx
; 2015 : 
; 2016 :     pBlkData += nBlkX*N_PER_BLOCK;

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pBlkData$1$[esp+136], edx

; 2017 :     if (outfilebuf != NULL) // write vector to outfile

	test	edi, edi
	je	SHORT $LN26@search_mv_

; 2018 :     {
; 2019 :       outfilebuf += nBlkX * 4;// 4 short word per block

	lea	edi, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR _outfilebuf$1$[esp+136], edi
$LN26@search_mv_:

; 2020 :     }
; 2021 : 
; 2022 :     workarea.y[0] += nBlkSizeY_Ovr[0];

	mov	eax, DWORD PTR _nBlkSizeY_Ovr$1$[esp+136]
	add	DWORD PTR [esi+20], eax

; 2023 :     workarea.y[1] += nBlkSizeY_Ovr[1];

	mov	eax, DWORD PTR _nBlkSizeY_Ovr$3$[esp+136]
	add	DWORD PTR [esi+24], eax

; 2024 :     workarea.y[2] += nBlkSizeY_Ovr[2];

	add	DWORD PTR [esi+28], eax
	inc	DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+36]
	cmp	eax, DWORD PTR [esi+84]
	jl	$LL4@search_mv_
$LN3@search_mv_:
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+64]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2027 :   planeSAD += workarea.planeSAD; // PF todo check int overflow

	lea	ecx, DWORD PTR [ebx+264]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	DWORD PTR _ftor$9[esp+144], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	edx, DWORD PTR _ftor$9[esp+136]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR _ftor$9[esp+148], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	eax, DWORD PTR _val_new$5[esp+136]
	push	eax
	lea	eax, DWORD PTR _val_old$3[esp+140]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _ftor$9[esp+140], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	push	eax
	call	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+72]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2028 :   sumLumaChange += workarea.sumLumaChange;

	lea	ecx, DWORD PTR [ebx+272]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	DWORD PTR _ftor$8[esp+152], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	edx, DWORD PTR _ftor$8[esp+144]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR _ftor$8[esp+156], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	eax, DWORD PTR _val_new$4[esp+144]
	push	eax
	lea	eax, DWORD PTR _val_old$2[esp+148]
; File c:\github\mvtools\sources\conc\aioadd.h

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR _ftor$9[esp+148], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	push	eax
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _ftor$8[esp+152], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	call	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
	add	esp, 16					; 00000010H
; File c:\github\mvtools\sources\conc\aioadd.h

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR _ftor$8[esp+136], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2030 :   if (isse)

	cmp	BYTE PTR [ebx+121], 0
	je	SHORT $LN27@search_mv_

; 2031 :   {
; 2032 : #ifndef _M_X64
; 2033 :     _mm_empty();

	emms
$LN27@search_mv_:

; 2034 : #endif
; 2035 :   }
; 2036 : 
; 2037 : #ifdef ALLOW_DCT
; 2038 :   if (_dct_pool_ptr != 0)

	mov	ecx, DWORD PTR [ebx+128]
	test	ecx, ecx
	je	SHORT $LN28@search_mv_

; 2039 :   {
; 2040 :     _dct_pool_ptr->return_obj(*(workarea.DCT));

	push	DWORD PTR [esi+48]
	call	?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z ; conc::ObjPool<DCTClass>::return_obj

; 2041 :     workarea.DCT = 0;

	mov	DWORD PTR [esi+48], 0
$LN28@search_mv_:

; 2042 :   }
; 2043 : #endif
; 2044 : 
; 2045 :   _workarea_pool.return_obj(workarea);

	push	esi
	lea	ecx, DWORD PTR [ebx+376]
	call	?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::return_obj

; 2046 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?search_mv_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ENDP ; PlaneOfBlocks::search_mv_slice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nBlkSizeX$ = 8						; size = 4
_nBlkSizeY$ = 12					; size = 4
_dctpitch$ = 16						; size = 4
_nLogxRatioUV$ = 20					; size = 4
_xRatioUV$dead$ = 24					; size = 4
_nLogyRatioUV$ = 28					; size = 4
_yRatioUV$dead$ = 32					; size = 4
__pixelsize$ = 36					; size = 4
__bits_per_pixel$ = 40					; size = 4
??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z PROC	; PlaneOfBlocks::WorkingArea::WorkingArea, COMDAT
; _this$ = ecx

; 2430 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 2427 :   , DCT(0)
; 2428 :   , pixelsize(_pixelsize)

	mov	eax, DWORD PTR __pixelsize$[ebp]
	push	ebx
	push	esi

; 2425 :   : dctSrc(nBlkSizeY*dctpitch)

	mov	esi, DWORD PTR _nBlkSizeY$[ebp]
	mov	ebx, ecx
	imul	esi, DWORD PTR _dctpitch$[ebp]
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR [ebx+396], eax
	lea	ecx, DWORD PTR [ebx+404]
	mov	eax, DWORD PTR __bits_per_pixel$[ebp]
	push	esi
	mov	DWORD PTR [ebx], OFFSET ??_7WorkingArea@PlaneOfBlocks@@6B@
	mov	DWORD PTR [ebx+48], 0
	mov	DWORD PTR [ebx+400], eax
	call	??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@I@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::vector<unsigned char,AllocAlign<unsigned char,16> >

; 2426 :   , dctRef(nBlkSizeY*dctpitch)

	push	esi
	lea	ecx, DWORD PTR [ebx+416]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@I@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::vector<unsigned char,AllocAlign<unsigned char,16> >

; 2430 : {

	lea	edx, DWORD PTR [ebx+428]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [edx], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [edx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [edx+8], 0
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2433 :   int UVblocksize = blocksize >> (nLogxRatioUV + nLogyRatioUV); // >> nx >> ny

	mov	ecx, DWORD PTR _nLogyRatioUV$[ebp]
	add	ecx, DWORD PTR _nLogxRatioUV$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ebx, DWORD PTR [ebx+396]
	imul	ebx, DWORD PTR _nBlkSizeX$[ebp]
	imul	ebx, DWORD PTR _nBlkSizeY$[ebp]
	mov	esi, ebx
	sar	esi, cl

; 2434 :   int sizeAlignedBlock = blocksize + (ALIGN_SOURCEBLOCK - (blocksize%ALIGN_SOURCEBLOCK)) +
; 2435 :     2 * UVblocksize + (ALIGN_SOURCEBLOCK - (UVblocksize%ALIGN_SOURCEBLOCK));

	mov	eax, esi
	lea	ecx, DWORD PTR [esi*2+32]
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN26@WorkingAre
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN26@WorkingAre:

; 2436 :   // int sizeAlignedBlock=blocksize+(ALIGN_SOURCEBLOCK-(blocksize%ALIGN_SOURCEBLOCK))+
; 2437 :   //                         2*((blocksize/2)>>nLogyRatioUV)+(ALIGN_SOURCEBLOCK-(((blocksize/2)/yRatioUV)%ALIGN_SOURCEBLOCK)); // why >>Logy then /y?
; 2438 :   pSrc_temp_base.resize(sizeAlignedBlock);

	sub	ecx, eax
	mov	eax, ebx
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN27@WorkingAre

; 2434 :   int sizeAlignedBlock = blocksize + (ALIGN_SOURCEBLOCK - (blocksize%ALIGN_SOURCEBLOCK)) +
; 2435 :     2 * UVblocksize + (ALIGN_SOURCEBLOCK - (UVblocksize%ALIGN_SOURCEBLOCK));

	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN27@WorkingAre:

; 2436 :   // int sizeAlignedBlock=blocksize+(ALIGN_SOURCEBLOCK-(blocksize%ALIGN_SOURCEBLOCK))+
; 2437 :   //                         2*((blocksize/2)>>nLogyRatioUV)+(ALIGN_SOURCEBLOCK-(((blocksize/2)/yRatioUV)%ALIGN_SOURCEBLOCK)); // why >>Logy then /y?
; 2438 :   pSrc_temp_base.resize(sizeAlignedBlock);

	sub	ecx, eax
	add	ecx, ebx
	push	ecx
	mov	ecx, edx
	call	?resize@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::resize

; 2439 :   pSrc_temp[0] = &pSrc_temp_base[0];

	mov	ecx, DWORD PTR _this$[ebp]

; 2440 :   pSrc_temp[1] = (uint8_t *)((((uintptr_t)pSrc_temp[0]) + blocksize + ALIGN_SOURCEBLOCK - 1)&(~(ALIGN_SOURCEBLOCK - 1)));
; 2441 :   pSrc_temp[2] = (uint8_t *)(((((uintptr_t)pSrc_temp[1]) + UVblocksize + ALIGN_SOURCEBLOCK - 1)&(~(ALIGN_SOURCEBLOCK - 1))));

	add	esi, 15					; 0000000fH
	mov	eax, DWORD PTR [ecx+428]
	mov	DWORD PTR [ecx+440], eax
	add	eax, 15					; 0000000fH
	add	eax, ebx
	and	eax, -16				; fffffff0H
	mov	DWORD PTR [ecx+444], eax
	add	eax, esi
	and	eax, -16				; fffffff0H
	mov	DWORD PTR [ecx+448], eax

; 2442 : #endif	// ALIGN_SOURCEBLOCK
; 2443 :   /* VS
; 2444 : #ifdef ALIGN_SOURCEBLOCK
; 2445 :     dctpitch = max(nBlkSizeX, 16) * bytesPerSample;
; 2446 :     dctSrc_base = new uint8_t[nBlkSizeY*dctpitch+ALIGN_PLANES-1];
; 2447 :     dctRef_base = new uint8_t[nBlkSizeY*dctpitch+ALIGN_PLANES-1];
; 2448 :     dctSrc = (uint8_t *)(((((intptr_t)dctSrc_base) + ALIGN_PLANES - 1)&(~(ALIGN_PLANES - 1))));//aligned like this means, that it will have optimum fit in the cache
; 2449 :     dctRef = (uint8_t *)(((((intptr_t)dctRef_base) + ALIGN_PLANES - 1)&(~(ALIGN_PLANES - 1))));
; 2450 : 
; 2451 :     int blocksize = nBlkSizeX * nBlkSizeY * bytesPerSample;
; 2452 :     int blocksizeUV = blocksize >> (nLogxRatioUV + nLogyRatioUV);
; 2453 :     int sizeAlignedBlock = blocksize + (ALIGN_SOURCEBLOCK - (blocksize % ALIGN_SOURCEBLOCK))
; 2454 :         + 2 * blocksizeUV + (ALIGN_SOURCEBLOCK - (blocksizeUV % ALIGN_SOURCEBLOCK));
; 2455 : 
; 2456 :     pSrc_temp_base = new uint8_t[sizeAlignedBlock + ALIGN_PLANES - 1];
; 2457 :     pSrc_temp[0] = (uint8_t *)(((intptr_t)pSrc_temp_base + ALIGN_PLANES - 1) & (~(ALIGN_PLANES - 1)));
; 2458 :     pSrc_temp[1] = (uint8_t *)(((intptr_t)pSrc_temp[0] + blocksize + ALIGN_SOURCEBLOCK - 1) & (~(ALIGN_SOURCEBLOCK - 1)));
; 2459 :     pSrc_temp[2] = (uint8_t *)(((intptr_t)pSrc_temp[1] + blocksizeUV + ALIGN_SOURCEBLOCK - 1) & (~(ALIGN_SOURCEBLOCK - 1)));
; 2460 : #else
; 2461 :     dctpitch = max(nBlkSizeX, 16) * bytesPerSample;
; 2462 :     dctSrc = new uint8_t[nBlkSizeY*dctpitch];
; 2463 :     dctRef = new uint8_t[nBlkSizeY*dctpitch];
; 2464 : #endif
; 2465 : */
; 2466 : 
; 2467 : }

	mov	eax, ecx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::~vector<unsigned char,AllocAlign<unsigned char,16> >
__unwindfunclet$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	jmp	??1?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::~vector<unsigned char,AllocAlign<unsigned char,16> >
__unwindfunclet$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	jmp	??1?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::~vector<unsigned char,AllocAlign<unsigned char,16> >
__ehhandler$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z:
	mov	eax, OFFSET __ehfuncinfo$??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z ENDP	; PlaneOfBlocks::WorkingArea::WorkingArea
; Function compile flags: /Ogtpy
;	COMDAT ??_GWorkingArea@PlaneOfBlocks@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GWorkingArea@PlaneOfBlocks@@UAEPAXI@Z PROC		; PlaneOfBlocks::WorkingArea::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1WorkingArea@PlaneOfBlocks@@UAE@XZ	; PlaneOfBlocks::WorkingArea::~WorkingArea
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	456					; 000001c8H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GWorkingArea@PlaneOfBlocks@@UAEPAXI@Z ENDP		; PlaneOfBlocks::WorkingArea::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??1WorkingArea@PlaneOfBlocks@@UAE@XZ
_TEXT	SEGMENT
??1WorkingArea@PlaneOfBlocks@@UAE@XZ PROC		; PlaneOfBlocks::WorkingArea::~WorkingArea, COMDAT
; _this$ = ecx

; 2472 : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7WorkingArea@PlaneOfBlocks@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [esi+428]
	test	eax, eax
	je	SHORT $LN7@WorkingAre
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	push	DWORD PTR [eax-4]
	call	??_V@YAXPAX@Z				; operator delete[]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+428], 0
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+432], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+436], 0
$LN7@WorkingAre:

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [esi+416]
	test	eax, eax
	je	SHORT $LN105@WorkingAre
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	push	DWORD PTR [eax-4]
	call	??_V@YAXPAX@Z				; operator delete[]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+416], 0
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+420], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+424], 0
$LN105@WorkingAre:

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [esi+404]
	test	eax, eax
	je	SHORT $LN203@WorkingAre
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	push	DWORD PTR [eax-4]
	call	??_V@YAXPAX@Z				; operator delete[]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+404], 0
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+408], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+412], 0
$LN203@WorkingAre:
	pop	esi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2474 : }

	ret	0
??1WorkingArea@PlaneOfBlocks@@UAE@XZ ENDP		; PlaneOfBlocks::WorkingArea::~WorkingArea
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?IsVectorOK@WorkingArea@PlaneOfBlocks@@QBE_NHH@Z
_TEXT	SEGMENT
_vx$ = 8						; size = 4
_vy$ = 12						; size = 4
?IsVectorOK@WorkingArea@PlaneOfBlocks@@QBE_NHH@Z PROC	; PlaneOfBlocks::WorkingArea::IsVectorOK, COMDAT
; _this$ = ecx

; 2482 :   return (

	mov	edx, DWORD PTR _vx$[esp-4]
	cmp	edx, DWORD PTR [ecx+368]
	jl	SHORT $LN3@IsVectorOK
	mov	eax, DWORD PTR _vy$[esp-4]
	cmp	eax, DWORD PTR [ecx+372]
	jl	SHORT $LN3@IsVectorOK
	cmp	edx, DWORD PTR [ecx+376]
	jge	SHORT $LN3@IsVectorOK
	cmp	eax, DWORD PTR [ecx+380]
	jge	SHORT $LN3@IsVectorOK
	mov	al, 1

; 2483 :     (vx >= nDxMin)
; 2484 :     && (vy >= nDyMin)
; 2485 :     && (vx < nDxMax)
; 2486 :     && (vy < nDyMax)
; 2487 :     );
; 2488 : }

	ret	8
$LN3@IsVectorOK:

; 2482 :   return (

	xor	al, al

; 2483 :     (vx >= nDxMin)
; 2484 :     && (vy >= nDyMin)
; 2485 :     && (vx < nDxMax)
; 2486 :     && (vy < nDyMax)
; 2487 :     );
; 2488 : }

	ret	8
?IsVectorOK@WorkingArea@PlaneOfBlocks@@QBE_NHH@Z ENDP	; PlaneOfBlocks::WorkingArea::IsVectorOK
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?MotionDistorsion@WorkingArea@PlaneOfBlocks@@QBEHHH@Z
_TEXT	SEGMENT
_vx$ = 8						; size = 4
_vy$ = 12						; size = 4
?MotionDistorsion@WorkingArea@PlaneOfBlocks@@QBEHHH@Z PROC ; PlaneOfBlocks::WorkingArea::MotionDistorsion, COMDAT
; _this$ = ecx

; 2492 : {

	push	esi
	mov	esi, ecx

; 2493 :   int dist = SquareDifferenceNorm(predictor, vx, vy);
; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	mov	ecx, 16					; 00000010H

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	mov	edx, DWORD PTR [esi+120]
	mov	eax, DWORD PTR [esi+116]
	sub	eax, DWORD PTR _vx$[esp]
	sub	edx, DWORD PTR _vy$[esp]

; 2493 :   int dist = SquareDifferenceNorm(predictor, vx, vy);
; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	sub	ecx, DWORD PTR [esi+400]

; 1807 :   return (v1.x - v2x) * (v1.x - v2x) + (v1.y - v2y) * (v1.y - v2y);

	imul	eax, eax
	imul	edx, edx
	add	eax, edx

; 2493 :   int dist = SquareDifferenceNorm(predictor, vx, vy);
; 2494 :   return (nLambda * dist) >> (16 - bits_per_pixel) /*8*/; // PF scaling because it appears as a sad addition 

	imul	eax, DWORD PTR [esi+384]
	pop	esi
	sar	eax, cl

; 2495 : }

	ret	8
?MotionDistorsion@WorkingArea@PlaneOfBlocks@@QBEHHH@Z ENDP ; PlaneOfBlocks::WorkingArea::MotionDistorsion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??0WorkingAreaFactory@PlaneOfBlocks@@QAE@HHHHHHHHH@Z
_TEXT	SEGMENT
_nBlkSizeX$ = 8						; size = 4
_nBlkSizeY$ = 12					; size = 4
_dctpitch$ = 16						; size = 4
_nLogxRatioUV$ = 20					; size = 4
_xRatioUV$ = 24						; size = 4
_nLogyRatioUV$ = 28					; size = 4
_yRatioUV$ = 32						; size = 4
_pixelsize$ = 36					; size = 4
_bits_per_pixel$ = 40					; size = 4
??0WorkingAreaFactory@PlaneOfBlocks@@QAE@HHHHHHHHH@Z PROC ; PlaneOfBlocks::WorkingAreaFactory::WorkingAreaFactory, COMDAT
; _this$ = ecx

; 2506 :   : _blk_size_x(nBlkSizeX)

	mov	eax, DWORD PTR _nBlkSizeX$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 2507 :   , _blk_size_y(nBlkSizeY)

	mov	eax, DWORD PTR _nBlkSizeY$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 2508 :   , _dctpitch(dctpitch)

	mov	eax, DWORD PTR _dctpitch$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 2509 :   , _x_ratio_uv_log(nLogxRatioUV)

	mov	eax, DWORD PTR _nLogxRatioUV$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 2510 :   , _x_ratio_uv(xRatioUV)

	mov	eax, DWORD PTR _xRatioUV$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 2511 :   , _y_ratio_uv_log(nLogyRatioUV)

	mov	eax, DWORD PTR _nLogyRatioUV$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 2512 :   , _y_ratio_uv(yRatioUV)

	mov	eax, DWORD PTR _yRatioUV$[esp-4]
	mov	DWORD PTR [ecx+28], eax

; 2513 :   , _pixelsize(pixelsize)

	mov	eax, DWORD PTR _pixelsize$[esp-4]
	mov	DWORD PTR [ecx+32], eax

; 2514 :   , _bits_per_pixel(bits_per_pixel)

	mov	eax, DWORD PTR _bits_per_pixel$[esp-4]
	mov	DWORD PTR [ecx+36], eax

; 2516 :   // Nothing
; 2517 : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7WorkingAreaFactory@PlaneOfBlocks@@6B@
	ret	36					; 00000024H
??0WorkingAreaFactory@PlaneOfBlocks@@QAE@HHHHHHHHH@Z ENDP ; PlaneOfBlocks::WorkingAreaFactory::WorkingAreaFactory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objfactoryinterface.h
;	COMDAT ??_GWorkingAreaFactory@PlaneOfBlocks@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GWorkingAreaFactory@PlaneOfBlocks@@UAEPAXI@Z PROC	; PlaneOfBlocks::WorkingAreaFactory::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 47   : 	virtual			~ObjFactoryInterface () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
	je	SHORT $LN10@scalar
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GWorkingAreaFactory@PlaneOfBlocks@@UAEPAXI@Z ENDP	; PlaneOfBlocks::WorkingAreaFactory::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ PROC ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
	mov	eax, ecx
	ret	0
??0?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ENDP ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objfactoryinterface.h
;	COMDAT ??_G?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z PROC ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 47   : 	virtual			~ObjFactoryInterface () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z ENDP ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ PROC ; PlaneOfBlocks::WorkingAreaFactory::do_create, COMDAT
; _this$ = ecx

; 2522 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi

; 2523 :   return (new WorkingArea(

	push	456					; 000001c8H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+32]
	push	ecx
	push	DWORD PTR [esi+24]
	push	ecx
	push	DWORD PTR [esi+16]
	mov	ecx, eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	call	??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z ; PlaneOfBlocks::WorkingArea::WorkingArea

; 2524 :     _blk_size_x,
; 2525 :     _blk_size_y,
; 2526 :     _dctpitch,
; 2527 :     _x_ratio_uv_log,
; 2528 :     _x_ratio_uv,
; 2529 :     _y_ratio_uv_log,
; 2530 :     _y_ratio_uv,
; 2531 :     _pixelsize,
; 2532 :     _bits_per_pixel
; 2533 :   ));
; 2534 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ$0:
	push	456					; 000001c8H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ:
	mov	eax, OFFSET __ehfuncinfo$?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_create@WorkingAreaFactory@PlaneOfBlocks@@MAEPAVWorkingArea@2@XZ ENDP ; PlaneOfBlocks::WorkingAreaFactory::do_create
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiosub.h
;	COMDAT ??1?$AioSub@H@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$AioSub@H@conc@@UAE@XZ PROC				; conc::AioSub<int>::~AioSub<int>, COMDAT
; _this$ = ecx

; 50   : 	virtual			~AioSub () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$AioSub@H@conc@@6B@
	ret	0
??1?$AioSub@H@conc@@UAE@XZ ENDP				; conc::AioSub<int>::~AioSub<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXXZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::pop_back, COMDAT
; _this$ = ecx

; 1314 : 		this->_Getal().destroy(_Unfancy(this->_Mylast() - 1));
; 1315 : 		--this->_Mylast();

	add	DWORD PTR [ecx+4], -4			; fffffffcH

; 1316 : 		}

	ret	0
?pop_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXXZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXABQAVDCTClass@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXABQAVDCTClass@@@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

	push	esi
	mov	esi, ecx
	push	edi

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	edi, DWORD PTR __Val$[esp+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	edi, eax
	jae	SHORT $LN2@push_back
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, edi
	ja	SHORT $LN2@push_back

; 1277 : 		if (_Inside(_STD addressof(_Val)))
; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	edi, ecx
	sar	edi, 2

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	push	ecx
	mov	ecx, esi
	call	?_Reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN209@push_back
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi

; 1295 : 			}
; 1296 : 		}

	ret	4
$LN2@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),
; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();
; 1286 : 			}
; 1287 : 		else
; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	push	ecx
	mov	ecx, esi
	call	?_Reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN209@push_back
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN209@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi

; 1295 : 			}
; 1296 : 		}

	ret	4
?push_back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXABQAVDCTClass@@@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEAAPAVDCTClass@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEAAPAVDCTClass@@XZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::back, COMDAT
; _this$ = ecx

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR [ecx+4]

; 179  : 		_Ptr += _Off;

	add	eax, -4					; fffffffcH

; 1267 : 		return (*(end() - 1));
; 1268 : 		}

	ret	0
?back@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEAAPAVDCTClass@@XZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBE_NXZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::empty, COMDAT
; _this$ = ecx

; 1189 : 		{	// test if sequence is empty

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1190 : 		return (this->_Myfirst() == this->_Mylast());
; 1191 : 		}

	ret	0
?empty@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBE_NXZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXI@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::reserve, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1033 : 		if (capacity() < _Count)

	mov	edx, DWORD PTR __Count$[esp-4]

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	eax, 2

; 1033 : 		if (capacity() < _Count)

	cmp	eax, edx
	jae	SHORT $LN2@reserve

; 1034 : 			{	// something to do, check and reallocate
; 1035 : 			if (max_size() < _Count)

	cmp	edx, 1073741823				; 3fffffffH
	jbe	SHORT $LN3@reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN49@reserve:
$LN3@reserve:

; 1036 : 				_Xlen();
; 1037 : 			_Reallocate(_Count);

	mov	DWORD PTR __Count$[esp-4], edx
	jmp	?_Reallocate@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reallocate
$LN2@reserve:

; 1038 : 			}
; 1039 : 		}

	ret	4
$LN48@reserve:
?reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXI@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::~vector<DCTClass *,std::allocator<DCTClass *> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	ret	0
??1?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::~vector<DCTClass *,std::allocator<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::vector<DCTClass *,std::allocator<DCTClass *> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::vector<DCTClass *,std::allocator<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
;	COMDAT ??1?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAE@XZ PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::~AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >, COMDAT
; _this$ = ecx

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	ret	0
??1?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAE@XZ ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::~AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\lockfreestack.h
;	COMDAT ??1?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ PROC ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::~LockFreeStack<PlaneOfBlocks::WorkingArea *>, COMDAT
; _this$ = ecx

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [ecx+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	ret	0
??1?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ENDP ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::~LockFreeStack<PlaneOfBlocks::WorkingArea *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objfactoryinterface.h
;	COMDAT ??1?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ PROC ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::~ObjFactoryInterface<PlaneOfBlocks::WorkingArea>, COMDAT
; _this$ = ecx

; 47   : 	virtual			~ObjFactoryInterface () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@6B@
	ret	0
??1?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ENDP ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::~ObjFactoryInterface<PlaneOfBlocks::WorkingArea>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEAAEI@Z
_TEXT	SEGMENT
__Pos$dead$ = 8						; size = 4
??A?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEAAEI@Z PROC	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [ecx]

; 1243 : 		}

	ret	4
??A?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEAAEI@Z ENDP	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?resize@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::resize, COMDAT
; _this$ = ecx

; 1133 : 		{	// determine new length, padding as needed

	push	esi
	mov	esi, ecx
	push	edi

; 1134 : 		if (_Newsize < size())

	mov	edi, DWORD PTR __Newsize$[esp+4]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi]
	sub	ecx, eax

; 1134 : 		if (_Newsize < size())

	cmp	ecx, edi
	ja	SHORT $LN195@resize

; 1135 : 			_Pop_back_n(size() - _Newsize);
; 1136 : 		else if (size() < _Newsize)

	jae	SHORT $LN4@resize

; 1137 : 			{	// pad as needed
; 1138 : 			_Reserve(_Newsize - size());

	sub	eax, edx
	mov	ecx, esi
	add	eax, edi
	push	eax
	call	?_Reserve@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Reserve
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	eax
	push	0
	push	ecx
	call	_memset
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1146 : 			this->_Mylast() += _Newsize - size();

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	add	esp, 12					; 0000000cH
$LN195@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1146 : 			this->_Mylast() += _Newsize - size();

	add	eax, edi
	mov	DWORD PTR [esi+4], eax
$LN4@resize:

; 1147 : 			}
; 1148 : 		}

	pop	edi
	pop	esi
	ret	4
?resize@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ PROC	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::~vector<unsigned char,AllocAlign<unsigned char,16> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	push	DWORD PTR [eax-4]
	call	??_V@YAXPAX@Z				; operator delete[]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	ret	0
??1?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::~vector<unsigned char,AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@I@Z PROC	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::vector<unsigned char,AllocAlign<unsigned char,16> >, COMDAT
; _this$ = ecx

; 717  : 		{	// construct from _Count * value_type()

	push	esi
	mov	esi, ecx
	push	edi

; 1566 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Count$[esp+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	je	SHORT $LN157@vector
; File c:\github\mvtools\sources\allocalign.hpp

; 63   : 	const size_t	alloc_bytes = offset + nbr_bytes;

	lea	eax, DWORD PTR [edi+19]

; 64   : 	void *			alloc_ptr = new char [alloc_bytes];

	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 65   : 	pointer			zone_ptr = 0;

	xor	ecx, ecx

; 66   : 	if (alloc_ptr != 0)

	test	eax, eax
	je	SHORT $LN80@vector

; 67   : 	{
; 68   : 		const ptrdiff_t	alloc_l = reinterpret_cast <ptrdiff_t> (alloc_ptr);
; 69   : 		const ptrdiff_t	zone_l = (alloc_l + offset) & (-ALIG);

	lea	ecx, DWORD PTR [eax+19]
	and	ecx, -16				; fffffff0H

; 70   : 		assert (zone_l >= ptrdiff_t (alloc_l + ptr_size));
; 71   : 		void **			ptr_ptr = reinterpret_cast <void **> (zone_l - ptr_size);
; 72   : 		*ptr_ptr = alloc_ptr;

	mov	DWORD PTR [ecx-4], eax
$LN80@vector:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], ecx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], ecx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	add	eax, edi
	mov	DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	DWORD PTR [esi]
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	add	DWORD PTR [esi+4], edi
$LN157@vector:

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@I@Z ENDP	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::vector<unsigned char,AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ PROC	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::vector<unsigned char,AllocAlign<unsigned char,16> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::vector<unsigned char,AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAEAAUVECTOR@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAEAAUVECTOR@@I@Z PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 1243 : 		}

	ret	4
??A?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAEAAUVECTOR@@I@Z ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEIXZ PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1181 : 		}

	ret	0
?size@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEIXZ ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::~vector<VECTOR,std::allocator<VECTOR> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	ret	0
??1?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::~vector<VECTOR,std::allocator<VECTOR> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Count$ = 8						; size = 4
??0?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@I@Z PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::vector<VECTOR,std::allocator<VECTOR> >, COMDAT
; _this$ = ecx

; 717  : 		{	// construct from _Count * value_type()

	push	esi
	mov	esi, ecx
	push	edi

; 718  : 		if (_Buy(_Count))

	mov	edi, DWORD PTR __Count$[esp+4]
	push	edi

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+8], 0

; 718  : 		if (_Buy(_Count))

	call	?_Buy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAE_NI@Z ; std::vector<VECTOR,std::allocator<VECTOR> >::_Buy
	test	al, al
	je	SHORT $LN41@vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+4]
	mov	edx, edi
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	??$_Uninitialized_default_fill_n1@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<VECTOR *,unsigned int,std::allocator<VECTOR> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	lea	eax, DWORD PTR [edi+edi*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 723  : 			this->_Mylast() += _Count;

	shl	eax, 2
	add	DWORD PTR [esi+4], eax
$LN41@vector:

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QAE@I@Z ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::vector<VECTOR,std::allocator<VECTOR> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiosub.h
;	COMDAT ??_G?$AioSub@H@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$AioSub@H@conc@@UAEPAXI@Z PROC			; conc::AioSub<int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 50   : 	virtual			~AioSub () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$AioSub@H@conc@@6B@
	je	SHORT $LN7@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$AioSub@H@conc@@UAEPAXI@Z ENDP			; conc::AioSub<int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
;	COMDAT ??_G?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAEPAXI@Z PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	je	SHORT $LN7@scalar
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@UAEPAXI@Z ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
;	COMDAT ??_G?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z PROC ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	je	SHORT $LN10@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z ENDP ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::~_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::~_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::~_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::~_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::~_Wrap_alloc<AllocAlign<unsigned char,16> >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::~_Wrap_alloc<AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$dead$ = 12					; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator-, COMDAT
; _this$ = ecx

; 384  : 		_Myiter _Tmp = *this;
; 385  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 179  : 		_Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	sub	ecx, 4

; 384  : 		_Myiter _Tmp = *this;
; 385  : 		return (_Tmp -= _Off);

	mov	DWORD PTR [eax], ecx

; 386  : 		}

	ret	8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBEAAPAVDCTClass@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBEAAPAVDCTClass@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator*, COMDAT
; _this$ = ecx

; 331  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 332  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBEAAPAVDCTClass@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAPAPAVDCTClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEXPAPAVDCTClass@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEXPAPAVDCTClass@@0@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1794 : 		}

	ret	8
?_Orphan_range@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEXPAPAVDCTClass@@0@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEXXZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEXXZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXXZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	ret	0
?_Tidy@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXXZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?_Reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	esi
	mov	esi, ecx
	push	edi

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, 1
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	push	ebx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	ebx, 1073741823				; 3fffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, ebx
	sub	eax, edx
	cmp	eax, 1
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN136@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	edx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edi, 2
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, edi
	shr	eax, 1
	sub	ebx, eax
	add	eax, edi
	cmp	ebx, edi
	cmovae	ecx, eax
	cmp	ecx, edx
	cmovae	edx, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, esi
	push	edx
	call	?_Reallocate@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reallocate
	pop	ebx
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	ret	4
$LN135@Reserve:
?_Reserve@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	ebp, DWORD PTR __Count$[esp+4]
	push	esi
	push	edi
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@PAVDCTClass@@@std@@QAEPAPAVDCTClass@@I@Z ; std::allocator<DCTClass *>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	esi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR [edi+4]
	sub	edx, esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	esi
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [edi+4]
	sub	esi, ecx
	sar	esi, 2

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	lea	eax, DWORD PTR [ebx+ebp*4]
	mov	DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [edi], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1623 : 		}

	ret	4
?_Reallocate@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXI@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBE_NPBQAVDCTClass@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBE_NPBQAVDCTClass@@@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Inside, COMDAT
; _this$ = ecx

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN3@Inside
	cmp	DWORD PTR [ecx], eax
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1598 : 		}

	ret	4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	xor	al, al

; 1598 : 		}

	ret	4
?_Inside@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBE_NPBQAVDCTClass@@@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@2@XZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::end, COMDAT
; _this$ = ecx

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1069 : 		}

	ret	4
?end@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@2@XZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1044 : 		}

	ret	0
?capacity@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXXZ PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	push	DWORD PTR [eax-4]
	call	??_V@YAXPAX@Z				; operator delete[]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	ret	0
?_Tidy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXXZ ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR __Count$[esp+8]

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	ebx, DWORD PTR [edi+8]
	mov	eax, ebx
	mov	esi, DWORD PTR [edi+4]
	sub	eax, esi

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, ecx
	jae	SHORT $LN2@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	edx, DWORD PTR [edi]
	mov	eax, edx
	sub	eax, esi
	dec	eax
	cmp	eax, ecx
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN139@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	ebx, edx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	sub	esi, edx
	add	esi, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, ebx
	shr	eax, 1
	xor	edx, edx
	mov	ecx, eax
	add	eax, ebx
	not	ecx
	cmp	ecx, ebx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, edi
	cmovae	edx, eax
	cmp	edx, esi
	cmovae	esi, edx
	push	esi
	call	?_Reallocate@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Reallocate
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN138@Reserve:
?_Reserve@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAE_NI@Z PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, ecx
	push	edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1567 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1577 : 		}

	ret	4
$LN2@Buy:
; File c:\github\mvtools\sources\allocalign.hpp

; 63   : 	const size_t	alloc_bytes = offset + nbr_bytes;

	lea	eax, DWORD PTR [edi+19]

; 64   : 	void *			alloc_ptr = new char [alloc_bytes];

	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 65   : 	pointer			zone_ptr = 0;

	xor	ecx, ecx

; 66   : 	if (alloc_ptr != 0)

	test	eax, eax
	je	SHORT $LN66@Buy

; 67   : 	{
; 68   : 		const ptrdiff_t	alloc_l = reinterpret_cast <ptrdiff_t> (alloc_ptr);
; 69   : 		const ptrdiff_t	zone_l = (alloc_l + offset) & (-ALIG);

	lea	ecx, DWORD PTR [eax+19]
	and	ecx, -16				; fffffff0H

; 70   : 		assert (zone_l >= ptrdiff_t (alloc_l + ptr_size));
; 71   : 		void **			ptr_ptr = reinterpret_cast <void **> (zone_l - ptr_size);
; 72   : 		*ptr_ptr = alloc_ptr;

	mov	DWORD PTR [ecx-4], eax
$LN66@Buy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], ecx

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], ecx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]
	add	eax, edi
	mov	DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1577 : 		}

	ret	4
?_Buy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAE_NI@Z ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;

	mov	eax, DWORD PTR __Count$[esp-4]
	sub	DWORD PTR [ecx+4], eax

; 1536 : 		}

	ret	4
?_Pop_back_n@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ PROC	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]

; 1181 : 		}

	ret	0
?size@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,AllocAlign<unsigned char,16> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\allocalign.h
;	COMDAT ??1?$AllocAlign@E$0BA@@@QAE@XZ
_TEXT	SEGMENT
??1?$AllocAlign@E$0BA@@@QAE@XZ PROC			; AllocAlign<unsigned char,16>::~AllocAlign<unsigned char,16>, COMDAT
; _this$dead$ = ecx

; 58   : 						~AllocAlign () {}

	ret	0
??1?$AllocAlign@E$0BA@@@QAE@XZ ENDP			; AllocAlign<unsigned char,16>::~AllocAlign<unsigned char,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABQAUVECTOR@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABQAUVECTOR@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABQAUVECTOR@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABQAUVECTOR@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABQAUVECTOR@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABQAUVECTOR@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAEXXZ PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	ret	0
?_Tidy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAEXXZ ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAE_NI@Z PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, ecx
	push	edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1567 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1577 : 		}

	ret	4
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN4@Buy

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN110@Buy:
$LN4@Buy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@UVECTOR@@@std@@QAEPAUVECTOR@@I@Z ; std::allocator<VECTOR>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();
; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [esi]
	pop	edi
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1
	pop	esi

; 1577 : 		}

	ret	4
$LN109@Buy:
?_Buy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBEABQAVDCTClass@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBEABQAVDCTClass@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)
; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 74   : 			_SCL_SECURE_OUT_OF_RANGE;
; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QBEABQAVDCTClass@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator-=, COMDAT
; _this$ = ecx

; 179  : 		_Ptr += _Off;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 379  : 		return (*this += -_Off);

	mov	eax, ecx

; 380  : 		}

	ret	4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAE@PAPAVDCTClass@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAE@PAPAVDCTClass@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >, COMDAT
; _this$ = ecx

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 314  : 		}

	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAE@PAPAVDCTClass@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<DCTClass *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<DCTClass *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@I@Z PROC ; std::_Wrap_alloc<std::allocator<DCTClass *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<DCTClass *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEPAPAVDCTClass@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEPAPAVDCTClass@@I@Z PROC ; std::_Wrap_alloc<std::allocator<DCTClass *> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@PAVDCTClass@@@std@@QAEPAPAVDCTClass@@I@Z ; std::allocator<DCTClass *>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEPAPAVDCTClass@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<DCTClass *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABQAPAVDCTClass@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<DCTClass *,std::allocator<DCTClass *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEII@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	esi, DWORD PTR [ecx+8]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 1073741823				; 3fffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	esi, DWORD PTR [ecx]
	sar	esi, 2

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IBEII@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXPAPAVDCTClass@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXPAPAVDCTClass@@0@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	8
?_Destroy@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEXPAPAVDCTClass@@0@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1181 : 		}

	ret	0
?size@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@QBEIXZ ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAEI@Z PROC ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::deallocate, COMDAT
; _this$dead$ = ecx
; File c:\github\mvtools\sources\allocalign.hpp

; 84   : 	if (ptr != 0)

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate

; 85   : 	{
; 86   : 		using namespace std;
; 87   : 
; 88   : 		const size_t	ptr_size = sizeof (void *);
; 89   : 		const ptrdiff_t	zone_l = reinterpret_cast <ptrdiff_t> (ptr);
; 90   : 		void **			ptr_ptr = reinterpret_cast <void **> (zone_l - ptr_size);
; 91   : 		void *			alloc_ptr = *ptr_ptr;
; 92   : 		assert (alloc_ptr != 0);
; 93   : 		assert (reinterpret_cast <ptrdiff_t> (alloc_ptr) < zone_l);
; 94   : 
; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	push	DWORD PTR [eax-4]
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN4@deallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAEI@Z ENDP ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEPAEI@Z PROC ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::allocate, COMDAT
; _this$dead$ = ecx
; File c:\github\mvtools\sources\allocalign.hpp

; 63   : 	const size_t	alloc_bytes = offset + nbr_bytes;

	mov	eax, DWORD PTR __Count$[esp-4]
	add	eax, 19					; 00000013H

; 64   : 	void *			alloc_ptr = new char [alloc_bytes];

	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, eax
	add	esp, 4

; 65   : 	pointer			zone_ptr = 0;
; 66   : 	if (alloc_ptr != 0)

	test	ecx, ecx
	je	SHORT $LN6@allocate

; 67   : 	{
; 68   : 		const ptrdiff_t	alloc_l = reinterpret_cast <ptrdiff_t> (alloc_ptr);
; 69   : 		const ptrdiff_t	zone_l = (alloc_l + offset) & (-ALIG);

	lea	eax, DWORD PTR [ecx+19]
	and	eax, -16				; fffffff0H

; 70   : 		assert (zone_l >= ptrdiff_t (alloc_l + ptr_size));
; 71   : 		void **			ptr_ptr = reinterpret_cast <void **> (zone_l - ptr_size);
; 72   : 		*ptr_ptr = alloc_ptr;

	mov	DWORD PTR [eax-4], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 977  : 		}

	ret	4
$LN6@allocate:

; 976  : 		return (_Mybase::allocate(_Count));

	xor	eax, eax

; 977  : 		}

	ret	4
?allocate@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEPAEI@Z ENDP ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IBEXXZ PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IBEXXZ ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebx
; File c:\github\mvtools\sources\allocalign.hpp

; 63   : 	const size_t	alloc_bytes = offset + nbr_bytes;

	mov	ebx, DWORD PTR __Count$[esp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebp
	push	esi
	push	edi
; File c:\github\mvtools\sources\allocalign.hpp

; 63   : 	const size_t	alloc_bytes = offset + nbr_bytes;

	lea	eax, DWORD PTR [ebx+19]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	edi, ecx
; File c:\github\mvtools\sources\allocalign.hpp

; 64   : 	void *			alloc_ptr = new char [alloc_bytes];

	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 65   : 	pointer			zone_ptr = 0;

	xor	esi, esi

; 66   : 	if (alloc_ptr != 0)

	test	eax, eax
	je	SHORT $LN18@Reallocate

; 67   : 	{
; 68   : 		const ptrdiff_t	alloc_l = reinterpret_cast <ptrdiff_t> (alloc_ptr);
; 69   : 		const ptrdiff_t	zone_l = (alloc_l + offset) & (-ALIG);

	lea	esi, DWORD PTR [eax+19]
	and	esi, -16				; fffffff0H

; 70   : 		assert (zone_l >= ptrdiff_t (alloc_l + ptr_size));
; 71   : 		void **			ptr_ptr = reinterpret_cast <void **> (zone_l - ptr_size);
; 72   : 		*ptr_ptr = alloc_ptr;

	mov	DWORD PTR [esi-4], eax
$LN18@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR [edi+4]
	push	ecx
	push	DWORD PTR $T1[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	push	esi
	call	??$_Uninitialized_move_al_unchecked1@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ebp, DWORD PTR [edi+4]
	sub	ebp, eax

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	eax, eax
	je	SHORT $LN158@Reallocate
; File c:\github\mvtools\sources\allocalign.hpp

; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	push	DWORD PTR [eax-4]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN158@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	lea	eax, DWORD PTR [esi+ebx]
	mov	DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [esi+ebp]
	mov	DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [edi], esi

; 1623 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
?_Reallocate@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXI@Z ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IBEII@Z PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [ecx]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, esi
	shr	eax, 1
	mov	edx, eax
	not	edx
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IBEII@Z ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXPAE0@Z PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	8
?_Destroy@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEXPAE0@Z ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	or	eax, -1

; 1186 : 		}

	ret	0
?max_size@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEXPAUVECTOR@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEXPAUVECTOR@@I@Z PROC ; std::_Wrap_alloc<std::allocator<VECTOR> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	12					; 0000000cH
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEXPAUVECTOR@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<VECTOR> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEPAUVECTOR@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEPAUVECTOR@@I@Z PROC ; std::_Wrap_alloc<std::allocator<VECTOR> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@UVECTOR@@@std@@QAEPAUVECTOR@@I@Z ; std::allocator<VECTOR>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEPAUVECTOR@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<VECTOR> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAPAUVECTOR@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IBEXXZ PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IBEXXZ ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAEXPAUVECTOR@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAEXPAUVECTOR@@0@Z PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	8
?_Destroy@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@IAEXPAUVECTOR@@0@Z ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEIXZ PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 357913941				; 15555555H

; 1186 : 		}

	ret	0
?max_size@?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEIXZ ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAE@PAPAVDCTClass@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAE@PAPAVDCTClass@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >, COMDAT
; _this$ = ecx

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAE@PAPAVDCTClass@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator+=, COMDAT
; _this$ = ecx

; 179  : 		_Ptr += _Off;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 367  : 		*(_Mybase *)this += _Off;
; 368  : 		return (*this);

	mov	eax, ecx

; 369  : 		}

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAIABV?$allocator@PAVDCTClass@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAIABV?$allocator@PAVDCTClass@@@2@@Z PROC ; std::allocator_traits<std::allocator<DCTClass *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAIABV?$allocator@PAVDCTClass@@@2@@Z ENDP ; std::allocator_traits<std::allocator<DCTClass *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVDCTClass@@@std@@QAEPAPAVDCTClass@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVDCTClass@@@std@@QAEPAPAVDCTClass@@I@Z PROC ; std::allocator<DCTClass *>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@PAVDCTClass@@@std@@QAEPAPAVDCTClass@@I@Z ENDP ; std::allocator<DCTClass *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@I@Z PROC ; std::allocator<DCTClass *>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@I@Z ENDP ; std::allocator<DCTClass *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$AllocAlign@E$0BA@@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,AllocAlign<unsigned char,16> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1044 : 		}

	ret	0
?capacity@?$vector@EV?$AllocAlign@E$0BA@@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<VECTOR> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 357913941				; 15555555H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<VECTOR> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<VECTOR,std::allocator<VECTOR> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UVECTOR@@@std@@QAEPAUVECTOR@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UVECTOR@@@std@@QAEPAUVECTOR@@I@Z PROC ; std::allocator<VECTOR>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@UVECTOR@@@std@@QAEPAUVECTOR@@I@Z ENDP ; std::allocator<VECTOR>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UVECTOR@@@std@@QAEXPAUVECTOR@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UVECTOR@@@std@@QAEXPAUVECTOR@@I@Z PROC ; std::allocator<VECTOR>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	12					; 0000000cH
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@UVECTOR@@@std@@QAEXPAUVECTOR@@I@Z ENDP ; std::allocator<VECTOR>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator+=, COMDAT
; _this$ = ecx

; 156  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 157  : 		if (_Off != 0)
; 158  : 			{
; 159  : 			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 160  : 			if (_Mycont == 0
; 161  : 				|| _Ptr + _Off < _Mycont->_Myfirst
; 162  : 				|| _Mycont->_Mylast < _Ptr + _Off)
; 163  : 				{
; 164  : 				_DEBUG_ERROR("vector iterator + offset out of range");
; 165  : 				_SCL_SECURE_OUT_OF_RANGE;
; 166  : 				}
; 167  : 			}
; 168  : 
; 169  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 170  : 		if (_Off != 0)
; 171  : 			{
; 172  : 			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 173  : 			_SCL_SECURE_VALIDATE(_Mycont != 0);
; 174  : 			_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr + _Off
; 175  : 				&& _Ptr + _Off <= _Mycont->_Mylast);
; 176  : 			}
; 177  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 178  : 
; 179  : 		_Ptr += _Off;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 180  : 		return (*this);

	mov	eax, ecx

; 181  : 		}

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DCTClass *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVDCTClass@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVDCTClass@@@std@@QBEIXZ PROC	; std::allocator<DCTClass *>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@PAVDCTClass@@@std@@QBEIXZ ENDP	; std::allocator<DCTClass *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAIABV?$AllocAlign@E$0BA@@@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAIABV?$AllocAlign@E$0BA@@@@Z PROC ; std::allocator_traits<AllocAlign<unsigned char,16> >::max_size, COMDAT
; __Al$dead$ = ecx

; 648  : 		return (_Alloc_max_size::_Fn(0, _Al));

	or	eax, -1

; 649  : 		}

	ret	0
?max_size@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAIABV?$AllocAlign@E$0BA@@@@Z ENDP ; std::allocator_traits<AllocAlign<unsigned char,16> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UVECTOR@@@std@@@std@@SAIABV?$allocator@UVECTOR@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@UVECTOR@@@std@@@std@@SAIABV?$allocator@UVECTOR@@@2@@Z PROC ; std::allocator_traits<std::allocator<VECTOR> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 357913941				; 15555555H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@UVECTOR@@@std@@@std@@SAIABV?$allocator@UVECTOR@@@2@@Z ENDP ; std::allocator_traits<std::allocator<VECTOR> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UVECTOR@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UVECTOR@@@std@@QBEIXZ PROC	; std::allocator<VECTOR>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 357913941				; 15555555H

; 750  : 		}

	ret	0
?max_size@?$allocator@UVECTOR@@@std@@QBEIXZ ENDP	; std::allocator<VECTOR>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?start@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXHAAVPlaneOfBlocks@@P82@AEXAAVTaskData@1@@ZH@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_nbr_threads$4 = -20					; size = 4
_task_data$5 = -16					; size = 16
_height$ = 8						; size = 4
_glob_data$ = 12					; size = 4
_y_beg$1$ = 16						; size = 4
_proc_ptr$ = 16						; size = 4
_min_slice_h$ = 20					; size = 4
?start@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXHAAVPlaneOfBlocks@@P82@AEXAAVTaskData@1@@ZH@Z PROC ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::start, COMDAT
; _this$ = ecx

; 145  : 	assert (height > 0);
; 146  : 	assert (&glob_data != 0);
; 147  : 	assert (proc_ptr != 0);
; 148  : 	assert (min_slice_h > 0);
; 149  : 
; 150  : 	_proc_ptr = proc_ptr;

	mov	edx, DWORD PTR _proc_ptr$[esp-4]
	sub	esp, 32					; 00000020H
	push	esi
	mov	esi, ecx

; 151  : 
; 152  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1040], 0
	mov	DWORD PTR [esi+8], edx
	je	$LN8@start

; 153  : 	{
; 154  : 		int				nbr_threads = _avstp.get_nbr_threads ();

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	push	edi
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 132  : 	return (_avstp_get_nbr_threads_ptr ());

	mov	eax, DWORD PTR [eax+16]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	ecx, DWORD PTR _height$[esp+40]
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, 64					; 00000040H
; File c:\github\mvtools\sources\mtslicer.hpp

; 155  : 		nbr_threads = std::min (nbr_threads, int (MAXT));

	mov	DWORD PTR $T1[esp+44], 64		; 00000040H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 157  : 		nbr_threads = std::max (nbr_threads, 1);

	mov	DWORD PTR $T3[esp+44], 1

; 158  : 
; 159  : 		int				y_beg = 0;

	mov	DWORD PTR _y_beg$1$[esp+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovg	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	eax, ecx
	cdq
	idiv	DWORD PTR _min_slice_h$[esp+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, edi
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	DWORD PTR $T2[esp+44], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	edi, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	cmp	edi, eax
	cmovl	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 157  : 		nbr_threads = std::max (nbr_threads, 1);

	mov	DWORD PTR _nbr_threads$4[esp+44], edi

; 160  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	test	edi, edi
	jle	SHORT $LN3@start

; 153  : 	{
; 154  : 		int				nbr_threads = _avstp.get_nbr_threads ();

	push	ebp
	mov	ebx, ecx
	mov	ebp, edi
	lea	ecx, DWORD PTR [esi+24]
$LL4@start:

; 161  : 		{
; 162  : 			const int		y_end = (t_cnt + 1) * height / nbr_threads;

	mov	eax, ebx

; 163  : 			TaskData &		task_data = _task_data_arr [t_cnt];
; 164  : 			task_data._glob_data_ptr = &glob_data;
; 165  : 			task_data._slicer_ptr    = this;

	mov	DWORD PTR [ecx-4], esi
	cdq
	lea	ecx, DWORD PTR [ecx+16]
	idiv	edi
	mov	edx, DWORD PTR _glob_data$[esp+44]
	add	ebx, DWORD PTR _height$[esp+44]
	mov	DWORD PTR [ecx-24], edx

; 166  : 			task_data._y_beg         = y_beg;

	mov	edx, DWORD PTR _y_beg$1$[esp+44]
	mov	DWORD PTR [ecx-16], edx

; 167  : 			task_data._y_end         = y_end;

	mov	DWORD PTR [ecx-12], eax

; 168  : 			y_beg = y_end;

	mov	DWORD PTR _y_beg$1$[esp+44], eax
	sub	ebp, 1
	jne	SHORT $LL4@start
	pop	ebp
$LN3@start:

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	eax, DWORD PTR [esi+4]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 118  : 	return (_avstp_create_dispatcher_ptr ());

	mov	eax, DWORD PTR [eax+8]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	DWORD PTR [esi+12], eax

; 174  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	test	edi, edi
	jle	SHORT $LN40@start

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	lea	ebx, DWORD PTR [esi+16]
$LL7@start:

; 175  : 		{
; 176  : 			_avstp.enqueue_task (

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 139  : 	return (_avstp_enqueue_task_ptr (td_ptr, task_ptr, user_data_ptr));

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	push	OFFSET ?redirect_task@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::redirect_task
	push	eax
	mov	eax, DWORD PTR [ecx+20]
	call	eax
	add	esp, 12					; 0000000cH
; File c:\github\mvtools\sources\mtslicer.hpp

; 174  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	add	ebx, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL7@start
$LN40@start:
	pop	edi
	pop	ebx
	pop	esi

; 196  : 	}
; 197  : }

	add	esp, 32					; 00000020H
	ret	16					; 00000010H
$LN8@start:

; 177  : 				_dispatcher_ptr,
; 178  : 				&redirect_task,
; 179  : 				&_task_data_arr [t_cnt]
; 180  : 			);
; 181  : 		}
; 182  : 	}
; 183  : 
; 184  : 	// Multi-threading disabled
; 185  : 	else
; 186  : 	{
; 187  : 		TaskData			task_data;
; 188  : 		task_data._glob_data_ptr = &glob_data;
; 189  : 		task_data._slicer_ptr    = this;
; 190  : 		task_data._y_beg         = 0;
; 191  : 		task_data._y_end         = height;

	mov	eax, DWORD PTR _height$[esp+32]
	mov	ecx, DWORD PTR _glob_data$[esp+32]
	mov	DWORD PTR _task_data$5[esp+48], eax

; 192  : 
; 193  : 		T *				this_ptr =
; 194  : 			MTSlicer_Access <T, GD>::access (&glob_data);
; 195  : 		((*this_ptr).*(proc_ptr)) (task_data);

	lea	eax, DWORD PTR _task_data$5[esp+36]
	push	eax
	mov	DWORD PTR _task_data$5[esp+40], ecx
	mov	DWORD PTR _task_data$5[esp+44], esi
	mov	DWORD PTR _task_data$5[esp+48], 0
	call	edx
	pop	esi

; 196  : 	}
; 197  : }

	add	esp, 32					; 00000020H
	ret	16					; 00000010H
?start@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXHAAVPlaneOfBlocks@@P82@AEXAAVTaskData@1@@ZH@Z ENDP ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?use_factory@?$ObjPool@VDCTClass@@@conc@@QBEAAV?$ObjFactoryInterface@VDCTClass@@@2@XZ
_TEXT	SEGMENT
?use_factory@?$ObjPool@VDCTClass@@@conc@@QBEAAV?$ObjFactoryInterface@VDCTClass@@@2@XZ PROC ; conc::ObjPool<DCTClass>::use_factory, COMDAT
; _this$ = ecx

; 101  : 	assert (_factory_ptr != 0);
; 102  : 
; 103  : 	return (*_factory_ptr);

	mov	eax, DWORD PTR [ecx+8]

; 104  : }

	ret	0
?use_factory@?$ObjPool@VDCTClass@@@conc@@QBEAAV?$ObjFactoryInterface@VDCTClass@@@2@XZ ENDP ; conc::ObjPool<DCTClass>::use_factory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\objfactoryinterface.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ
_TEXT	SEGMENT
_obj_ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ PROC ; conc::ObjPool<DCTClass>::take_obj, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	assert (_factory_ptr != 0);
; 126  : 
; 127  : 	ObjType *		obj_ptr = 0;
; 128  : 
; 129  : 	PtrCell *		cell_ptr = _stack_free.pop ();

	lea	ecx, DWORD PTR [edi+16]
	call	?pop@?$LockFreeStack@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ; conc::LockFreeStack<DCTClass *>::pop

; 130  : 	if (cell_ptr == 0)

	test	eax, eax
	jne	SHORT $LN2@take_obj

; 131  : 	{
; 132  : 		obj_ptr = _factory_ptr->create ();

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\objfactoryinterface.hpp

; 55   : 	return (do_create ());

	call	DWORD PTR [eax+4]
	mov	esi, eax
	mov	DWORD PTR _obj_ptr$[ebp], esi
; File c:\github\mvtools\sources\conc\objpool.hpp

; 134  : 		if (obj_ptr != 0)

	test	esi, esi
	je	$LN43@take_obj

; 135  : 		{
; 136  : 			bool				ok_flag = false;
; 137  : 			try
; 138  : 			{
; 139  : 				cell_ptr = _obj_cell_pool.take_cell (true);

	push	ecx
	lea	ecx, DWORD PTR [edi+64]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	xor	bl, bl
	call	?take_cell@?$CellPool@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@_N@Z ; conc::CellPool<DCTClass *>::take_cell

; 140  : 				if (cell_ptr != 0)

	test	eax, eax
	je	SHORT $LN6@take_obj

; 141  : 				{
; 142  : 					cell_ptr->_val = obj_ptr;
; 143  : 					_stack_all.push (*cell_ptr);

	push	eax
	lea	ecx, DWORD PTR [edi+40]
	mov	DWORD PTR [eax+4], esi
	call	?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ; conc::LockFreeStack<DCTClass *>::push

; 144  : 					ok_flag = true;

	mov	bl, 1
$LN6@take_obj:

; 151  : 
; 152  : 			if (! ok_flag)

	test	bl, bl
	je	SHORT $LN48@take_obj

; 165  : 	return (obj_ptr);

	mov	eax, esi

; 166  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ$0:

; 145  : 				}
; 146  : 			}
; 147  : 			catch (...)
; 148  : 			{
; 149  : 				// Nothing
; 150  : 			}

	mov	eax, $LN51@take_obj
	ret	0
$LN51@take_obj:
	mov	esi, DWORD PTR _obj_ptr$[ebp]
$LN48@take_obj:

; 153  : 			{
; 154  : 				delete obj_ptr;

	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 165  : 	return (obj_ptr);

	xor	eax, eax

; 166  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@take_obj:

; 155  : 				obj_ptr = 0;
; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 	else
; 160  : 	{
; 161  : 		obj_ptr = cell_ptr->_val;

	mov	esi, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 165  : 	_cell_stack.push (cell);

	lea	ecx, DWORD PTR [edi+72]
	push	eax
	call	?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ; conc::LockFreeStack<DCTClass *>::push

; 166  : 
; 167  : 	++ _nbr_avail_cells;

	add	edi, 352				; 00000160H
$LL30@take_obj:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [edi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [edi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL30@take_obj
; File c:\github\mvtools\sources\conc\objpool.hpp

; 165  : 	return (obj_ptr);

	mov	eax, esi
$LN43@take_obj:

; 166  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ ENDP ; conc::ObjPool<DCTClass>::take_obj
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 12
__InitData$3 = -28					; size = 8
__$EHRec$ = -16						; size = 16
_obj$ = 8						; size = 4
?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z PROC ; conc::ObjPool<DCTClass>::return_obj, COMDAT
; _this$ = ecx

; 186  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp

; 187  : 	assert (&obj != 0);
; 188  : 
; 189  : 	PtrCell *		cell_ptr = 0;
; 190  : 	try
; 191  : 	{
; 192  : 		cell_ptr = _obj_cell_pool.take_cell (true);

	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR [esi+64]
	call	?take_cell@?$CellPool@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@_N@Z ; conc::CellPool<DCTClass *>::take_cell
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	test	eax, eax
	je	SHORT $LN14@return_obj

; 202  : 	}
; 203  : 	else
; 204  : 	{
; 205  : 		cell_ptr->_val = &obj;

	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 206  : 		_stack_free.push (*cell_ptr);

	lea	ecx, DWORD PTR [esi+16]
	push	eax
	call	?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ; conc::LockFreeStack<DCTClass *>::push

; 207  : 	}
; 208  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z$0:

; 193  : 	}
; 194  : 	catch (...)
; 195  : 	{
; 196  : 		// Nothing
; 197  : 	}

	mov	eax, $LN9@return_obj
	ret	0
$LN9@return_obj:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN14@return_obj:

; 55   :         __std_exception_copy(&_InitData, &_Data);

	lea	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR $T2[ebp], OFFSET ??_7exception@std@@6B@
	push	eax
	lea	eax, DWORD PTR __InitData$3[ebp]
	mov	DWORD PTR __InitData$3[ebp], OFFSET ??_C@_0CK@INGOFGFH@return_obj?$CI?$CJ?3?5cannot?5allocate?5a?5@
	xorps	xmm0, xmm0

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	BYTE PTR __InitData$3[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	movq	QWORD PTR $T2[ebp+4], xmm0
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept

; 168  : 		{	// construct from message string

	mov	DWORD PTR $T2[ebp], OFFSET ??_7runtime_error@std@@6B@
; File c:\github\mvtools\sources\conc\objpool.hpp

; 201  : 		throw std::runtime_error ("return_obj(): cannot allocate a new cell.");

	lea	eax, DWORD PTR $T2[ebp]
	push	OFFSET __TI2?AVruntime_error@std@@
	push	eax
	call	__CxxThrowException@8
$LN17@return_obj:
$LN16@return_obj:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z ENDP ; conc::ObjPool<DCTClass>::return_obj
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@J@Z PROC ; conc::Array<std::vector<int,std::allocator<int> >,2>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 56   : }

	ret	4
??A?$Array@V?$vector@HV?$allocator@H@std@@@std@@$01@conc@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@J@Z ENDP ; conc::Array<std::vector<int,std::allocator<int> >,2>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??0?$AtomicInt@_J@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$AtomicInt@_J@conc@@QAE@XZ PROC			; conc::AtomicInt<__int64>::AtomicInt<__int64>, COMDAT
; _this$ = ecx

; 54   : :	_val ()

	mov	DWORD PTR [ecx], 0

; 56   : 	assert (is_ptr_aligned_nz ((const void *) (&_val), sizeof (_val)));
; 57   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$AtomicInt@_J@conc@@QAE@XZ ENDP			; conc::AtomicInt<__int64>::AtomicInt<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??4?$AtomicInt@_J@conc@@QAEAAV01@_J@Z
_TEXT	SEGMENT
_old$1 = -24						; size = 8
_other$ = -12						; size = 8
_dest$ = -4						; size = 4
_other$dead$ = 8					; size = 8
??4?$AtomicInt@_J@conc@@QAEAAV01@_J@Z PROC		; conc::AtomicInt<__int64>::operator=, COMDAT
; _this$ = ecx

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _other$[ebp], xmm0

; 83   : 	StoredTypeWrapper::swap (_val, other);

	mov	DWORD PTR _dest$[ebp], edi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 83   : 		push				ebx

	push	ebx

; 84   : 		mov				esi, [dest]

	mov	esi, DWORD PTR _dest$[ebp]

; 85   : 		mov				ebx, [dword ptr excg    ]

	mov	ebx, DWORD PTR _other$[ebp]

; 86   : 		mov				ecx, [dword ptr excg + 4]

	mov	ecx, DWORD PTR _other$[ebp+4]
$cas_loop$8:

; 87   : 
; 88   : 	cas_loop:
; 89   : 		mov				eax, [esi    ]

	mov	eax, DWORD PTR [esi]

; 90   : 		mov				edx, [esi + 4]

	mov	edx, DWORD PTR [esi+4]

; 91   : 		lock cmpxchg8b	[esi]

	lock	 cmpxchg8b QWORD PTR [esi]

; 92   : 		jnz				cas_loop

	jne	SHORT $cas_loop$8

; 93   : 
; 94   : 		mov				[dword ptr old    ], eax

	mov	DWORD PTR _old$1[ebp], eax

; 95   : 		mov				[dword ptr old + 4], edx

	mov	DWORD PTR _old$1[ebp+4], edx

; 96   : 		pop				ebx

	pop	ebx
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 85   : 	return (*this);

	mov	eax, edi

; 86   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??4?$AtomicInt@_J@conc@@QAEAAV01@_J@Z ENDP		; conc::AtomicInt<__int64>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??B?$AtomicInt@_J@conc@@QBE_JXZ
_TEXT	SEGMENT
??B?$AtomicInt@_J@conc@@QBE_JXZ PROC			; conc::AtomicInt<__int64>::operator __int64, COMDAT
; _this$ = ecx

; 93   : 	return (T (_val));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 94   : }

	ret	0
??B?$AtomicInt@_J@conc@@QBE_JXZ ENDP			; conc::AtomicInt<__int64>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??Y?$AtomicInt@_J@conc@@QAEAAV01@AB_J@Z
_TEXT	SEGMENT
_val_new$1 = -32					; size = 8
_val_old$2 = -24					; size = 8
_ftor$ = -16						; size = 16
_other$ = 8						; size = 4
??Y?$AtomicInt@_J@conc@@QAEAAV01@AB_J@Z PROC		; conc::AtomicInt<__int64>::operator+=, COMDAT
; _this$ = ecx

; 116  : {

	sub	esp, 36					; 00000024H
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	edx, DWORD PTR _other$[esp+32]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 116  : {

	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _ftor$[esp+40], OFFSET ??_7?$AioAdd@_J@conc@@6B@

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _ftor$[esp+48], eax
	mov	eax, DWORD PTR [edx+4]
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	edx, DWORD PTR _ftor$[esp+40]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	DWORD PTR _ftor$[esp+52], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	eax, DWORD PTR _val_new$1[esp+40]
	push	eax
	lea	eax, DWORD PTR _val_old$2[esp+44]
	push	eax
	call	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
	add	esp, 8
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 122  : 	return (*this);

	mov	eax, esi

; 123  : }

	pop	esi
	add	esp, 36					; 00000024H
	ret	4
??Y?$AtomicInt@_J@conc@@QAEAAV01@AB_J@Z ENDP		; conc::AtomicInt<__int64>::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\allocalign.hpp
;	COMDAT ?allocate@?$AllocAlign@E$0BA@@@QAEPAEIPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
___formal$dead$ = 12					; size = 4
?allocate@?$AllocAlign@E$0BA@@@QAEPAEIPBX@Z PROC	; AllocAlign<unsigned char,16>::allocate, COMDAT
; _this$dead$ = ecx

; 54   : 	CHECK_COMPILE_TIME (IntTypeSize, (sizeof (ptrdiff_t) >= sizeof (void *)));
; 55   : 
; 56   : 	assert (n >= 0);
; 57   : 
; 58   : 	using namespace std;
; 59   : 
; 60   : 	const size_t	nbr_bytes = sizeof (T) * n;
; 61   : 	const size_t	ptr_size = sizeof (void *);
; 62   : 	const size_t	offset = ptr_size + ALIG - 1;
; 63   : 	const size_t	alloc_bytes = offset + nbr_bytes;

	mov	eax, DWORD PTR _n$[esp-4]
	add	eax, 19					; 00000013H

; 64   : 	void *			alloc_ptr = new char [alloc_bytes];

	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, eax
	add	esp, 4

; 65   : 	pointer			zone_ptr = 0;
; 66   : 	if (alloc_ptr != 0)

	test	ecx, ecx
	je	SHORT $LN4@allocate

; 67   : 	{
; 68   : 		const ptrdiff_t	alloc_l = reinterpret_cast <ptrdiff_t> (alloc_ptr);
; 69   : 		const ptrdiff_t	zone_l = (alloc_l + offset) & (-ALIG);

	lea	eax, DWORD PTR [ecx+19]
	and	eax, -16				; fffffff0H

; 70   : 		assert (zone_l >= ptrdiff_t (alloc_l + ptr_size));
; 71   : 		void **			ptr_ptr = reinterpret_cast <void **> (zone_l - ptr_size);
; 72   : 		*ptr_ptr = alloc_ptr;

	mov	DWORD PTR [eax-4], ecx

; 77   : }

	ret	8
$LN4@allocate:

; 73   : 		zone_ptr = reinterpret_cast <pointer> (zone_l);
; 74   : 	}
; 75   : 
; 76   : 	return (zone_ptr);

	xor	eax, eax

; 77   : }

	ret	8
?allocate@?$AllocAlign@E$0BA@@@QAEPAEIPBX@Z ENDP	; AllocAlign<unsigned char,16>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\allocalign.hpp
;	COMDAT ?deallocate@?$AllocAlign@E$0BA@@@QAEXPAEI@Z
_TEXT	SEGMENT
?deallocate@?$AllocAlign@E$0BA@@@QAEXPAEI@Z PROC	; AllocAlign<unsigned char,16>::deallocate, COMDAT
; _ptr$ = ecx

; 84   : 	if (ptr != 0)
; 85   : 	{
; 86   : 		using namespace std;
; 87   : 
; 88   : 		const size_t	ptr_size = sizeof (void *);
; 89   : 		const ptrdiff_t	zone_l = reinterpret_cast <ptrdiff_t> (ptr);
; 90   : 		void **			ptr_ptr = reinterpret_cast <void **> (zone_l - ptr_size);
; 91   : 		void *			alloc_ptr = *ptr_ptr;
; 92   : 		assert (alloc_ptr != 0);
; 93   : 		assert (reinterpret_cast <ptrdiff_t> (alloc_ptr) < zone_l);
; 94   : 
; 95   : 		delete [] reinterpret_cast <char *> (alloc_ptr);

	push	DWORD PTR [ecx-4]
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx

; 96   : 	}
; 97   : }

	ret	0
?deallocate@?$AllocAlign@E$0BA@@@QAEXPAEI@Z ENDP	; AllocAlign<unsigned char,16>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::ObjPool<PlaneOfBlocks::WorkingArea>, COMDAT
; _this$ = ecx

; 55   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR [edi], OFFSET ??_7?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@

; 51   : :	_factory_ptr (0)

	mov	DWORD PTR [edi+8], 0
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 41   : {

	mov	DWORD PTR [edi+16], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 41   : {

	mov	DWORD PTR [edi+24], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	movq	QWORD PTR [edi+32], xmm0
	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR [edi+36]

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+32], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+36], 0

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+32], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+36], 0
; File c:\github\mvtools\sources\conc\objpool.hpp

; 52   : ,	_stack_free ()

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 41   : {

	mov	DWORD PTR [edi+40], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 41   : {

	mov	DWORD PTR [edi+48], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	movq	QWORD PTR [edi+56], xmm0
	mov	eax, DWORD PTR [edi+56]
	mov	ecx, DWORD PTR [edi+60]

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+56], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+60], 0

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+56], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+60], 0
; File c:\github\mvtools\sources\conc\objpool.hpp

; 54   : ,	_obj_cell_pool ()

	lea	ecx, DWORD PTR [edi+64]
	call	??0?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::CellPool<PlaneOfBlocks::WorkingArea *>

; 56   : 	_obj_cell_pool.expand_to (1024);

	push	1024					; 00000400H
	lea	ecx, DWORD PTR [edi+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?expand_to@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXI@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::expand_to

; 57   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::~LockFreeStack<PlaneOfBlocks::WorkingArea *>
__unwindfunclet$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::~LockFreeStack<PlaneOfBlocks::WorkingArea *>
__unwindfunclet$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::~CellPool<PlaneOfBlocks::WorkingArea *>
__ehhandler$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ENDP ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::ObjPool<PlaneOfBlocks::WorkingArea>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ??1?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::~ObjPool<PlaneOfBlocks::WorkingArea>, COMDAT
; _this$ = ecx

; 70   : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 227  : 	const int		count_free = delete_obj_stack  (_stack_free, false);

	push	0
	lea	ebx, DWORD PTR [esi+16]

; 70   : {

	mov	DWORD PTR [esi], OFFSET ??_7?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@6B@

; 227  : 	const int		count_free = delete_obj_stack  (_stack_free, false);

	push	ebx
	call	?delete_obj_stack@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@AAEHAAV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::delete_obj_stack

; 228  : 	const int		count_all  = delete_obj_stack  (_stack_all,  true);

	push	1
	lea	edi, DWORD PTR [esi+40]
	mov	ecx, esi
	push	edi
	call	?delete_obj_stack@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@AAEHAAV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::delete_obj_stack
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 63   : 	clear_all ();

	lea	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [esi+64], OFFSET ??_7?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
	call	?clear_all@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::clear_all
; File c:\github\mvtools\sources\conc\mutex.hpp

; 46   : 	::DeleteCriticalSection (&_crit_sec);

	lea	eax, DWORD PTR [esi+360]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [esi+72], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi+80], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [edi], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [edi+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	pop	edi
	pop	esi
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [ebx], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [ebx+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	pop	ebx
; File c:\github\mvtools\sources\conc\objpool.hpp

; 72   : }

	ret	0
??1?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ENDP ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::~ObjPool<PlaneOfBlocks::WorkingArea>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?set_factory@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@2@@Z
_TEXT	SEGMENT
_fact$ = 8						; size = 4
?set_factory@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@2@@Z PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::set_factory, COMDAT
; _this$ = ecx

; 91   : 	assert (&fact != 0);
; 92   : 
; 93   : 	_factory_ptr = &fact;

	mov	eax, DWORD PTR _fact$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 94   : }

	ret	4
?set_factory@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@2@@Z ENDP ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::set_factory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
_TEXT	SEGMENT
_obj_ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::take_obj, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	assert (_factory_ptr != 0);
; 126  : 
; 127  : 	ObjType *		obj_ptr = 0;
; 128  : 
; 129  : 	PtrCell *		cell_ptr = _stack_free.pop ();

	lea	ecx, DWORD PTR [edi+16]
	call	?pop@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::pop

; 130  : 	if (cell_ptr == 0)

	test	eax, eax
	jne	SHORT $LN2@take_obj

; 131  : 	{
; 132  : 		obj_ptr = _factory_ptr->create ();

	mov	ecx, DWORD PTR [edi+8]
	call	?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::create
	mov	esi, eax
	mov	DWORD PTR _obj_ptr$[ebp], esi

; 133  : 
; 134  : 		if (obj_ptr != 0)

	test	esi, esi
	je	$LN41@take_obj

; 135  : 		{
; 136  : 			bool				ok_flag = false;
; 137  : 			try
; 138  : 			{
; 139  : 				cell_ptr = _obj_cell_pool.take_cell (true);

	push	ecx
	lea	ecx, DWORD PTR [edi+64]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	xor	bl, bl
	call	?take_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::take_cell

; 140  : 				if (cell_ptr != 0)

	test	eax, eax
	je	SHORT $LN6@take_obj

; 141  : 				{
; 142  : 					cell_ptr->_val = obj_ptr;
; 143  : 					_stack_all.push (*cell_ptr);

	push	eax
	lea	ecx, DWORD PTR [edi+40]
	mov	DWORD PTR [eax+4], esi
	call	?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push

; 144  : 					ok_flag = true;

	mov	bl, 1
$LN6@take_obj:

; 151  : 
; 152  : 			if (! ok_flag)

	test	bl, bl
	je	SHORT $LN46@take_obj

; 165  : 	return (obj_ptr);

	mov	eax, esi

; 166  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ$0:

; 145  : 				}
; 146  : 			}
; 147  : 			catch (...)
; 148  : 			{
; 149  : 				// Nothing
; 150  : 			}

	mov	eax, $LN49@take_obj
	ret	0
$LN49@take_obj:
	mov	esi, DWORD PTR _obj_ptr$[ebp]
$LN46@take_obj:

; 153  : 			{
; 154  : 				delete obj_ptr;

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	1
	call	DWORD PTR [eax]

; 165  : 	return (obj_ptr);

	xor	eax, eax

; 166  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@take_obj:

; 155  : 				obj_ptr = 0;
; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 	else
; 160  : 	{
; 161  : 		obj_ptr = cell_ptr->_val;

	mov	esi, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 165  : 	_cell_stack.push (cell);

	lea	ecx, DWORD PTR [edi+72]
	push	eax
	call	?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push

; 166  : 
; 167  : 	++ _nbr_avail_cells;

	add	edi, 352				; 00000160H
$LL28@take_obj:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [edi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [edi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL28@take_obj
; File c:\github\mvtools\sources\conc\objpool.hpp

; 165  : 	return (obj_ptr);

	mov	eax, esi
$LN41@take_obj:

; 166  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ ENDP ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::take_obj
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 12
__InitData$3 = -28					; size = 8
__$EHRec$ = -16						; size = 16
_obj$ = 8						; size = 4
?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::return_obj, COMDAT
; _this$ = ecx

; 186  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp

; 187  : 	assert (&obj != 0);
; 188  : 
; 189  : 	PtrCell *		cell_ptr = 0;
; 190  : 	try
; 191  : 	{
; 192  : 		cell_ptr = _obj_cell_pool.take_cell (true);

	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR [esi+64]
	call	?take_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::take_cell
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	test	eax, eax
	je	SHORT $LN14@return_obj

; 202  : 	}
; 203  : 	else
; 204  : 	{
; 205  : 		cell_ptr->_val = &obj;

	mov	ecx, DWORD PTR _obj$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 206  : 		_stack_free.push (*cell_ptr);

	lea	ecx, DWORD PTR [esi+16]
	push	eax
	call	?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push

; 207  : 	}
; 208  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z$0:

; 193  : 	}
; 194  : 	catch (...)
; 195  : 	{
; 196  : 		// Nothing
; 197  : 	}

	mov	eax, $LN9@return_obj
	ret	0
$LN9@return_obj:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN14@return_obj:

; 55   :         __std_exception_copy(&_InitData, &_Data);

	lea	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR $T2[ebp], OFFSET ??_7exception@std@@6B@
	push	eax
	lea	eax, DWORD PTR __InitData$3[ebp]
	mov	DWORD PTR __InitData$3[ebp], OFFSET ??_C@_0CK@INGOFGFH@return_obj?$CI?$CJ?3?5cannot?5allocate?5a?5@
	xorps	xmm0, xmm0

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	BYTE PTR __InitData$3[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	movq	QWORD PTR $T2[ebp+4], xmm0
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept

; 168  : 		{	// construct from message string

	mov	DWORD PTR $T2[ebp], OFFSET ??_7runtime_error@std@@6B@
; File c:\github\mvtools\sources\conc\objpool.hpp

; 201  : 		throw std::runtime_error ("return_obj(): cannot allocate a new cell.");

	lea	eax, DWORD PTR $T2[ebp]
	push	OFFSET __TI2?AVruntime_error@std@@
	push	eax
	call	__CxxThrowException@8
$LN17@return_obj:
$LN16@return_obj:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z ENDP ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::return_obj
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ??1?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::~CellPool<PlaneOfBlocks::WorkingArea *>, COMDAT
; _this$ = ecx

; 62   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@

; 63   : 	clear_all ();

	call	?clear_all@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::clear_all
; File c:\github\mvtools\sources\conc\mutex.hpp

; 46   : 	::DeleteCriticalSection (&_crit_sec);

	lea	eax, DWORD PTR [esi+296]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [esi+8], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi+16], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	pop	esi
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 64   : }

	ret	0
??1?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::~CellPool<PlaneOfBlocks::WorkingArea *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.h
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??$recalculate_mv_slice@E@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_nVy$1$ = -220						; size = 4
_mvy$1$ = -220						; size = 4
_saduv$1$ = -220					; size = 4
_vector1_sad$1$ = -220					; size = 4
_blkxold2$1$ = -220					; size = 4
tv3678 = -220						; size = 4
tv3675 = -220						; size = 4
$T1 = -220						; size = 4
_blkxold$2 = -220					; size = 4
$T3 = -216						; size = 4
_this$1$ = -216						; size = 4
_deltaY$1$ = -216					; size = 4
_mvx$1$ = -212						; size = 4
_mvy$1$ = -212						; size = 4
_vectorOld4$1$ = -212					; size = 4
_blkyold2$1$ = -212					; size = 4
tv3795 = -212						; size = 4
$T4 = -212						; size = 4
_blkyold$5 = -212					; size = 4
$T6 = -208						; size = 4
$T7 = -208						; size = 4
$T8 = -208						; size = 4
_mvy$1$ = -208						; size = 4
_mvx$1$ = -208						; size = 4
_mvx$1$ = -208						; size = 4
_this$1$ = -204						; size = 4
_nStepXold$1$ = -200					; size = 4
_blkxold1$1$ = -196					; size = 4
tv3784 = -196						; size = 4
_deltaX$1$ = -192					; size = 4
tv3823 = -192						; size = 4
_nStepYold$1$ = -188					; size = 4
_nBlkXold$1$ = -184					; size = 4
_nVx$1$ = -180						; size = 4
_vectorOld3$3$ = -180					; size = 4
tv3726 = -176						; size = 4
$T9 = -176						; size = 4
$T10 = -176						; size = 4
$T11 = -176						; size = 4
$T12 = -176						; size = 4
$T13 = -176						; size = 4
_pBlkData$1$ = -172					; size = 4
_outfilebuf$1$ = -168					; size = 4
_nBlkSizeYold$1$ = -164					; size = 4
_result$1$ = -160					; size = 4
_nBlkSizeX_Ovr$3$ = -156				; size = 4
_ftor$14 = -152						; size = 16
_ftor$15 = -152						; size = 16
$T16 = -152						; size = 12
_blkxStart$1$ = -136					; size = 4
_nBlkYold$1$ = -132					; size = 4
_iblkx$1$ = -128					; size = 4
_nBlkSizeX_Ovr$1$ = -124				; size = 4
_vectorOld$17 = -120					; size = 12
tv3748 = -108						; size = 4
tv3747 = -104						; size = 4
tv3746 = -100						; size = 4
tv3745 = -96						; size = 4
$T18 = -92						; size = 4
$T19 = -88						; size = 4
$T20 = -84						; size = 4
$T21 = -80						; size = 4
$T22 = -76						; size = 4
_nBlkSizeY_Ovr$1$ = -72					; size = 4
_val_old$23 = -72					; size = 8
_val_old$24 = -72					; size = 8
_nBlkSizeY_Ovr$3$ = -64					; size = 4
_val_new$25 = -64					; size = 8
_val_new$26 = -64					; size = 8
_nBlkSizeXold$1$ = -52					; size = 4
_vectorOld2$27 = -48					; size = 12
_vectorOld1$28 = -36					; size = 12
_vectorOld4$29 = -24					; size = 12
_vectorOld3$30 = -12					; size = 12
_td$ = 8						; size = 4
??$recalculate_mv_slice@E@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z PROC ; PlaneOfBlocks::recalculate_mv_slice<unsigned char>, COMDAT
; _this$ = ecx

; 2052 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 220				; 000000dcH
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[esp+232], ebx

; 2053 :   assert(&td != 0);
; 2054 : 
; 2055 :   short *			outfilebuf = _outfilebuf;

	mov	edi, DWORD PTR [ebx+300]

; 2056 : 
; 2057 :   WorkingArea &	workarea = *(_workarea_pool.take_obj());

	lea	ecx, DWORD PTR [ebx+376]
	mov	DWORD PTR _outfilebuf$1$[esp+232], edi
	call	?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::take_obj

; 2058 :   assert(&workarea != 0);
; 2059 : 
; 2060 :   workarea.blky_beg = td._y_beg;

	mov	edx, DWORD PTR _td$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+80], eax

; 2061 :   workarea.blky_end = td._y_end;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+84], eax

; 2062 : 
; 2063 :   workarea.DCT = 0;

	mov	DWORD PTR [esi+48], 0

; 2064 : #ifdef ALLOW_DCT
; 2065 :   if (_dct_pool_ptr != 0)

	mov	ecx, DWORD PTR [ebx+128]
	test	ecx, ecx
	je	SHORT $LN23@recalculat

; 2066 :   {
; 2067 :     workarea.DCT = _dct_pool_ptr->take_obj();

	call	?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ ; conc::ObjPool<DCTClass>::take_obj
	mov	DWORD PTR [esi+48], eax
$LN23@recalculat:

; 2068 :   }
; 2069 : #endif	// ALLOW_DCT
; 2070 :   workarea.globalMVPredictor = _glob_mv_pred_def;

	movq	xmm0, QWORD PTR [ebx+280]

; 2071 : 
; 2072 :   int *pBlkData = _out + 1 + workarea.blky_beg * nBlkX*N_PER_BLOCK;

	mov	edx, DWORD PTR [esi+80]
	movq	QWORD PTR [esi+52], xmm0
	mov	eax, DWORD PTR [ebx+288]
	mov	DWORD PTR [esi+60], eax
	imul	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+296]
	lea	ecx, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, 4
	mov	DWORD PTR _pBlkData$1$[esp+232], eax

; 2073 :   if (outfilebuf != NULL)

	test	edi, edi
	je	SHORT $LN24@recalculat

; 2074 :   {
; 2075 :     outfilebuf += workarea.blky_beg * nBlkX * 4;// 4 short word per block

	lea	edi, DWORD PTR [edi+edx*8]
	mov	DWORD PTR _outfilebuf$1$[esp+232], edi
$LN24@recalculat:

; 2078 :   workarea.y[0] = pSrcFrame->GetPlane(YPLANE)->GetVPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2078 :   workarea.y[0] = pSrcFrame->GetPlane(YPLANE)->GetVPadding();

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], ecx

; 2079 :   workarea.y[0] += workarea.blky_beg * (nBlkSizeY - nOverlapY);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	imul	eax, DWORD PTR [esi+80]
	add	eax, ecx
	mov	DWORD PTR [esi+20], eax

; 2080 :   if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	SHORT $LN25@recalculat

; 2082 :     workarea.y[1] = pSrcFrame->GetPlane(UPLANE)->GetVPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2082 :     workarea.y[1] = pSrcFrame->GetPlane(UPLANE)->GetVPadding();

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+24], eax

; 2083 :     workarea.y[2] = pSrcFrame->GetPlane(VPLANE)->GetVPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2083 :     workarea.y[2] = pSrcFrame->GetPlane(VPLANE)->GetVPadding();

	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+28], edx

; 2084 :     workarea.y[1] += workarea.blky_beg * ((nBlkSizeY - nOverlapY) >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR [ebx+60]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+80]
	add	DWORD PTR [esi+24], eax

; 2085 :     workarea.y[2] += workarea.blky_beg * ((nBlkSizeY - nOverlapY) >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR [ebx+60]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+80]
	add	eax, edx
	mov	DWORD PTR [esi+28], eax
$LN25@recalculat:

; 2086 :   }
; 2087 : 
; 2088 :   workarea.planeSAD = 0;

	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0

; 2089 :   workarea.sumLumaChange = 0;

	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+76], 0
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+320]
	mov	eax, DWORD PTR [eax+88]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 64   : 	inline int GetReducedWidth() const { return nBlkX; }

	mov	ecx, DWORD PTR [eax+8]

; 71   : 	inline int GetBlockSizeY() const { return nBlkSizeY; }

	mov	edx, DWORD PTR [eax+20]

; 64   : 	inline int GetReducedWidth() const { return nBlkX; }

	mov	DWORD PTR _nBlkXold$1$[esp+232], ecx

; 65   : 	inline int GetReducedHeight() const { return nBlkY; }

	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _nBlkYold$1$[esp+232], ecx

; 70   : 	inline int GetBlockSizeX() const { return nBlkSizeX; }

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _nBlkSizeXold$1$[esp+232], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2099 :   int nStepXold = nBlkSizeXold - nOverlapXold;

	sub	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _nStepXold$1$[esp+232], ecx

; 2100 :   int nStepYold = nBlkSizeYold - nOverlapYold;

	mov	ecx, edx
	sub	ecx, DWORD PTR [eax+48]

; 2101 :   int nPelold = plane.GetPel();
; 2102 :   int nLogPelold = ilog2(nPelold);

	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _nStepYold$1$[esp+232], ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 25   : 	int result = 0;

	xor	ecx, ecx
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 71   : 	inline int GetBlockSizeY() const { return nBlkSizeY; }

	mov	DWORD PTR _nBlkSizeYold$1$[esp+232], edx
; File c:\github\mvtools\sources\commonfunctions.h

; 25   : 	int result = 0;

	mov	DWORD PTR _result$1$[esp+232], ecx

; 26   : 	while ( i > 1 ) { i /= 2; result++; }

	cmp	eax, 1
	jle	SHORT $LN105@recalculat
	npad	7
$LL104@recalculat:
	cdq
	inc	ecx
	sub	eax, edx
	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL104@recalculat
	mov	DWORD PTR _result$1$[esp+232], ecx
$LN105@recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2104 :   int nBlkSizeX_Ovr[3] = { (nBlkSizeX - nOverlapX), (nBlkSizeX - nOverlapX) >> nLogxRatioUV, (nBlkSizeX - nOverlapX) >> nLogxRatioUV };

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR _nBlkSizeX_Ovr$1$[esp+232], eax
	sar	eax, cl

; 2105 :   int nBlkSizeY_Ovr[3] = { (nBlkSizeY - nOverlapY), (nBlkSizeY - nOverlapY) >> nLogyRatioUV, (nBlkSizeY - nOverlapY) >> nLogyRatioUV };

	mov	ecx, DWORD PTR [ebx+60]
	mov	DWORD PTR _nBlkSizeX_Ovr$3$[esp+232], eax
	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR _nBlkSizeY_Ovr$1$[esp+232], eax
	sar	eax, cl
	mov	DWORD PTR _nBlkSizeY_Ovr$3$[esp+232], eax

; 2106 : 
; 2107 :   // Functions using float must not be used here
; 2108 :   for (workarea.blky = workarea.blky_beg; workarea.blky < workarea.blky_end; workarea.blky++)

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [esi+36], eax
	cmp	eax, DWORD PTR [esi+84]
	jge	$LN3@recalculat
	mov	edx, DWORD PTR _pBlkData$1$[esp+232]
	npad	2
$LL4@recalculat:

; 2109 :   {
; 2110 :     workarea.blkScanDir = (workarea.blky % 2 == 0 || !_meander_flag) ? 1 : -1;

	mov	eax, DWORD PTR [esi+36]
	and	eax, 1
	je	SHORT $LN60@recalculat
	cmp	BYTE PTR [ebx+308], 0
	je	SHORT $LN60@recalculat
	or	ecx, -1
	jmp	SHORT $LN61@recalculat
$LN60@recalculat:
	mov	ecx, 1
$LN61@recalculat:
	mov	DWORD PTR [esi+44], ecx
	test	eax, eax

; 2111 :     // meander (alternate) scan blocks (even row left to right, odd row right to left)
; 2112 :     int blkxStart = (workarea.blky % 2 == 0 || !_meander_flag) ? 0 : nBlkX - 1;

	je	SHORT $LN62@recalculat
	cmp	BYTE PTR [ebx+308], 0
	je	SHORT $LN62@recalculat
	mov	eax, DWORD PTR [ebx]
	dec	eax
	mov	DWORD PTR _blkxStart$1$[esp+232], eax
	jmp	SHORT $LN63@recalculat
$LN62@recalculat:
	mov	DWORD PTR _blkxStart$1$[esp+232], 0
$LN63@recalculat:

; 2114 :     {
; 2115 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2113 :     if (workarea.blkScanDir == 1) // start with leftmost block

	cmp	ecx, 1
	jne	SHORT $LN26@recalculat

; 2114 :     {
; 2115 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+8], eax

; 2116 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	SHORT $LN29@recalculat

; 2118 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2118 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], eax

; 2119 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2119 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], eax

; 2120 :       }
; 2121 :     }
; 2122 :     else // start with rightmost block, but it is already set at prev row

	jmp	SHORT $LN29@recalculat
$LN26@recalculat:

; 2123 :     {
; 2124 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding() + nBlkSizeX_Ovr[0]*(nBlkX - 1);

	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$1$[esp+232]
	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+8], ecx

; 2125 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	SHORT $LN29@recalculat

; 2127 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding() + nBlkSizeX_Ovr[1]*(nBlkX - 1);

	mov	eax, DWORD PTR [ebx+160]
	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$3$[esp+232]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2127 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding() + nBlkSizeX_Ovr[1]*(nBlkX - 1);

	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], ecx

; 2128 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding() + nBlkSizeX_Ovr[2]*(nBlkX - 1);

	mov	eax, DWORD PTR [ebx+160]
	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$3$[esp+232]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2128 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding() + nBlkSizeX_Ovr[2]*(nBlkX - 1);

	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], ecx
$LN29@recalculat:

; 2129 :       }
; 2130 :     }
; 2131 : 
; 2132 :     for (int iblkx = 0; iblkx < nBlkX; iblkx++)

	xor	ecx, ecx
	mov	DWORD PTR _iblkx$1$[esp+232], ecx
	cmp	DWORD PTR [ebx], ecx
	jle	$LN6@recalculat

; 2187 :       int blkyold = (centerY - nBlkSizeYold / 2) / nStepYold;
; 2188 : 
; 2189 :       int deltaX = std::max(0, centerX - (nBlkSizeXold / 2 + nStepXold*blkxold)); // distance from old to new

	mov	edi, DWORD PTR _nBlkSizeXold$1$[esp+232]
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	DWORD PTR $T13[esp+232], ecx
	sar	eax, 1
	mov	DWORD PTR tv3748[esp+232], eax
	mov	eax, DWORD PTR _nBlkSizeYold$1$[esp+232]
	cdq
	sub	eax, edx

; 2190 :       int deltaY = std::max(0, centerY - (nBlkSizeYold / 2 + nStepYold*blkyold));

	mov	DWORD PTR $T12[esp+232], ecx
	sar	eax, 1
	mov	DWORD PTR tv3747[esp+232], eax
	mov	eax, edi
	cdq
	sub	eax, edx

; 2191 : 
; 2192 :       int blkxold1 = std::min(nBlkXold - 1, std::max(0, blkxold));

	mov	DWORD PTR $T18[esp+232], ecx
	sar	eax, 1
	neg	eax

; 2193 :       int blkxold2 = std::min(nBlkXold - 1, std::max(0, blkxold + 1));

	mov	DWORD PTR $T20[esp+232], ecx
	mov	DWORD PTR tv3746[esp+232], eax
	mov	eax, DWORD PTR _nBlkSizeYold$1$[esp+232]
	cdq
	sub	eax, edx

; 2194 :       int blkyold1 = std::min(nBlkYold - 1, std::max(0, blkyold));

	mov	DWORD PTR $T21[esp+232], ecx
	mov	edx, DWORD PTR _nBlkXold$1$[esp+232]
	dec	edx
	sar	eax, 1
	neg	eax
	mov	DWORD PTR $T11[esp+232], edx
	mov	DWORD PTR $T19[esp+232], edx
	mov	edx, DWORD PTR _nBlkYold$1$[esp+232]
	mov	DWORD PTR tv3745[esp+232], eax
	dec	edx
	mov	eax, DWORD PTR _nBlkSizeYold$1$[esp+232]
	imul	eax, edi
	mov	DWORD PTR $T10[esp+232], edx

; 2195 :       int blkyold2 = std::min(nBlkYold - 1, std::max(0, blkyold + 1));

	mov	DWORD PTR $T9[esp+232], edx
	mov	DWORD PTR $T22[esp+232], ecx
	mov	DWORD PTR tv3726[esp+232], eax
$LL7@recalculat:

; 2133 :     {
; 2134 :       workarea.blkx = blkxStart + iblkx*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, ecx
	mov	ecx, DWORD PTR _blkxStart$1$[esp+232]
	add	ecx, eax

; 2135 :       workarea.blkIdx = workarea.blky*nBlkX + workarea.blkx;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+32], ecx
	imul	eax, DWORD PTR [ebx]
	add	eax, ecx
	mov	DWORD PTR [esi+40], eax

; 2141 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	add	eax, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2141 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);

	mov	DWORD PTR [esi+88], eax

; 2142 :       //create aligned copy
; 2143 :       BLITLUMA(workarea.pSrc_temp[0], nSrcPitch[0], workarea.pSrc[0], nSrcPitch_plane[0]);

	push	DWORD PTR [ebx+192]
	push	eax
	push	DWORD PTR [ebx+168]
	mov	eax, DWORD PTR [ebx+92]
	push	DWORD PTR [esi+440]
	call	eax

; 2144 :       //set the to the aligned copy
; 2145 :       workarea.pSrc[0] = workarea.pSrc_temp[0];

	mov	eax, DWORD PTR [esi+440]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+88], eax

; 2146 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	$LN30@recalculat

; 2148 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2148 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);

	mov	DWORD PTR [esi+92], edi

; 2149 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2149 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);

	mov	DWORD PTR [esi+96], edi

; 2150 :         BLITCHROMA(workarea.pSrc_temp[1], nSrcPitch[1], workarea.pSrc[1], nSrcPitch_plane[1]);

	push	DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [ebx+96]
	push	DWORD PTR [esi+92]
	push	DWORD PTR [ebx+172]
	push	DWORD PTR [esi+444]
	call	eax

; 2151 :         BLITCHROMA(workarea.pSrc_temp[2], nSrcPitch[2], workarea.pSrc[2], nSrcPitch_plane[2]);

	push	DWORD PTR [ebx+200]
	mov	eax, DWORD PTR [ebx+96]
	push	DWORD PTR [esi+96]
	push	DWORD PTR [ebx+176]
	push	DWORD PTR [esi+448]
	call	eax

; 2152 :         workarea.pSrc[1] = workarea.pSrc_temp[1];

	mov	eax, DWORD PTR [esi+444]
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+92], eax

; 2153 :         workarea.pSrc[2] = workarea.pSrc_temp[2];

	mov	eax, DWORD PTR [esi+448]
	mov	DWORD PTR [esi+96], eax
$LN30@recalculat:

; 2154 :       }
; 2155 : #else	// ALIGN_SOURCEBLOCK
; 2156 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);
; 2157 :       if (chroma)
; 2158 :       {
; 2159 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);
; 2160 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);
; 2161 :       }
; 2162 : #endif	// ALIGN_SOURCEBLOCK
; 2163 : 
; 2164 :       if (workarea.blky == workarea.blky_beg)

	mov	eax, DWORD PTR [esi+36]
	cmp	eax, DWORD PTR [esi+80]
	jne	SHORT $LN31@recalculat

; 2165 :       {
; 2166 :         workarea.nLambda = 0;

	mov	DWORD PTR [esi+384], 0

; 2167 :       }
; 2168 :       else

	jmp	SHORT $LN32@recalculat
$LN31@recalculat:

; 2169 :       {
; 2170 :         workarea.nLambda = _lambda_level;

	mov	eax, DWORD PTR [ebx+292]
	mov	DWORD PTR [esi+384], eax
$LN32@recalculat:

; 2171 :       }
; 2172 : 
; 2173 :       penaltyNew = _pnew; // penalty for new vector

	mov	eax, DWORD PTR [ebx+312]
	mov	DWORD PTR [ebx+236], eax

; 2174 :       LSAD = _lsad;    // SAD limit for lambda using

	mov	eax, DWORD PTR [ebx+316]
	mov	DWORD PTR [ebx+232], eax

; 2178 :       workarea.nDxMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedWidth() - workarea.x[0] - nBlkSizeX);

	mov	eax, DWORD PTR [ebx+160]

; 2182 : 
; 2183 :       // get and interplolate old vectors
; 2184 :       int centerX = nBlkSizeX / 2 + (nBlkSizeX - nOverlapX)*workarea.blkx; // center of new block

	mov	ecx, DWORD PTR _this$1$[esp+232]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2178 :       workarea.nDxMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedWidth() - workarea.x[0] - nBlkSizeX);

	mov	eax, DWORD PTR [eax+36]
	sub	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [ebx+8]
	imul	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [esi+376], eax

; 2179 :       workarea.nDyMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedHeight() - workarea.y[0] - nBlkSizeY);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2179 :       workarea.nDyMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedHeight() - workarea.y[0] - nBlkSizeY);

	mov	eax, DWORD PTR [eax+40]
	sub	eax, DWORD PTR [esi+20]
	sub	eax, DWORD PTR [ebx+12]
	imul	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [esi+380], eax

; 2180 :       workarea.nDxMin = -nPel * workarea.x[0];

	mov	eax, DWORD PTR [esi+8]
	imul	eax, DWORD PTR [ebx+20]
	neg	eax
	mov	DWORD PTR [esi+368], eax

; 2181 :       workarea.nDyMin = -nPel * workarea.y[0];

	mov	eax, DWORD PTR [esi+20]
	imul	eax, DWORD PTR [ebx+20]
	neg	eax
	mov	DWORD PTR [esi+372], eax
	mov	DWORD PTR $T8[esp+232], eax

; 2182 : 
; 2183 :       // get and interplolate old vectors
; 2184 :       int centerX = nBlkSizeX / 2 + (nBlkSizeX - nOverlapX)*workarea.blkx; // center of new block

	mov	eax, DWORD PTR [ebx+8]
	mov	ebx, eax
	sub	ebx, DWORD PTR [ecx+40]
	imul	ebx, DWORD PTR [esi+32]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ebx, eax

; 2185 :       int blkxold = (centerX - nBlkSizeXold / 2) / nStepXold; // centerXold less or equal to new

	mov	eax, ebx
	sub	eax, DWORD PTR tv3748[esp+232]
	cdq
	idiv	DWORD PTR _nStepXold$1$[esp+232]

; 2186 :       int centerY = nBlkSizeY / 2 + (nBlkSizeY - nOverlapY)*workarea.blky;

	mov	edx, DWORD PTR _this$1$[esp+232]
	mov	ecx, eax
	mov	DWORD PTR _blkxold$2[esp+232], ecx

; 2187 :       int blkyold = (centerY - nBlkSizeYold / 2) / nStepYold;
; 2188 : 
; 2189 :       int deltaX = std::max(0, centerX - (nBlkSizeXold / 2 + nStepXold*blkxold)); // distance from old to new

	imul	ecx, DWORD PTR _nStepXold$1$[esp+232]
	mov	eax, DWORD PTR [edx+12]
	mov	edi, eax
	sub	edi, DWORD PTR [edx+44]
	imul	edi, DWORD PTR [esi+36]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	edi, eax
	mov	eax, edi
	sub	eax, DWORD PTR tv3747[esp+232]
	cdq
	idiv	DWORD PTR _nStepYold$1$[esp+232]
	mov	edx, DWORD PTR tv3746[esp+232]
	sub	edx, ecx
	mov	DWORD PTR _blkyold$5[esp+232], eax
	add	edx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	ecx, ecx
	test	edx, edx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ebx, DWORD PTR $T19[esp+232]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovg	ecx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2190 :       int deltaY = std::max(0, centerY - (nBlkSizeYold / 2 + nStepYold*blkyold));

	imul	eax, DWORD PTR _nStepYold$1$[esp+232]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _deltaX$1$[esp+232], ecx
	lea	edx, DWORD PTR $T18[esp+232]
	mov	ecx, DWORD PTR _blkxold$2[esp+232]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2190 :       int deltaY = std::max(0, centerY - (nBlkSizeYold / 2 + nStepYold*blkyold));

	sub	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	eax, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2190 :       int deltaY = std::max(0, centerY - (nBlkSizeYold / 2 + nStepYold*blkyold));

	add	edi, DWORD PTR tv3745[esp+232]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	edi, edi
	cmovg	eax, edi
	test	ecx, ecx
	mov	DWORD PTR _deltaY$1$[esp+232], eax
	lea	eax, DWORD PTR _blkxold$2[esp+232]
	cmovle	eax, edx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, ebx
	mov	eax, DWORD PTR [eax]
	cmp	eax, ebx
	cmovl	edx, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2193 :       int blkxold2 = std::min(nBlkXold - 1, std::max(0, blkxold + 1));

	lea	eax, DWORD PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR _blkxold1$1$[esp+232], edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	eax, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2193 :       int blkxold2 = std::min(nBlkXold - 1, std::max(0, blkxold + 1));

	mov	DWORD PTR $T1[esp+232], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edi, DWORD PTR $T20[esp+232]
	lea	ecx, DWORD PTR $T1[esp+232]
	cmovle	ecx, edi
	lea	edi, DWORD PTR $T21[esp+232]

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx]
	cmp	eax, ebx
	mov	ecx, ebx
	mov	ebx, DWORD PTR _nBlkYold$1$[esp+232]
	cmovl	ecx, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR _blkyold$5[esp+232]

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR _blkxold2$1$[esp+232], ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR _blkyold$5[esp+232]
	test	ecx, ecx
	cmovle	eax, edi

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	dec	ebx
	mov	edi, ebx
	mov	eax, DWORD PTR [eax]
	cmp	eax, ebx
	cmovl	edi, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2195 :       int blkyold2 = std::min(nBlkYold - 1, std::max(0, blkyold + 1));

	lea	eax, DWORD PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	eax, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2195 :       int blkyold2 = std::min(nBlkYold - 1, std::max(0, blkyold + 1));

	mov	DWORD PTR $T4[esp+232], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T22[esp+232]
	lea	ecx, DWORD PTR $T4[esp+232]
	cmovle	ecx, eax

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx]
	cmp	eax, ebx
	mov	ecx, ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2201 :       if (_smooth == 1) // interpolate

	mov	ebx, DWORD PTR _this$1$[esp+232]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	ecx, eax
	mov	DWORD PTR _blkyold2$1$[esp+232], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2201 :       if (_smooth == 1) // interpolate

	cmp	DWORD PTR [ebx+324], 1
	jne	$LN33@recalculat
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+320]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	imul	edi, DWORD PTR _nBlkXold$1$[esp+232]
	mov	ebx, DWORD PTR _blkxold2$1$[esp+232]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+52]
	lea	eax, DWORD PTR [edx+edi]
	lea	eax, DWORD PTR [eax+eax*4]
	movq	xmm0, QWORD PTR [ecx+eax*4+8]
	mov	edx, DWORD PTR [ecx+eax*4+16]
	lea	eax, DWORD PTR [ebx+edi]
	lea	eax, DWORD PTR [eax+eax*4]
	movq	QWORD PTR _vectorOld1$28[esp+232], xmm0
	mov	edi, DWORD PTR [ecx+eax*4+16]
	movq	xmm0, QWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR _blkxold1$1$[esp+232]
	mov	DWORD PTR _vector1_sad$1$[esp+232], edi
	mov	edi, DWORD PTR _blkyold2$1$[esp+232]
	imul	edi, DWORD PTR _nBlkXold$1$[esp+232]
	movq	QWORD PTR _vectorOld2$27[esp+232], xmm0
	add	eax, edi
	lea	eax, DWORD PTR [eax+eax*4]
	movq	xmm0, QWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [ecx+eax*4+16]
	mov	DWORD PTR _vectorOld3$3$[esp+232], eax
	lea	eax, DWORD PTR [ebx+edi]
	lea	eax, DWORD PTR [eax+eax*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2209 :         int vector1_x = vectorOld1.x*nStepXold + deltaX*(vectorOld2.x - vectorOld1.x); // scaled by nStepXold to skip slow division

	mov	edi, DWORD PTR _vectorOld2$27[esp+232]

; 2210 :         int vector1_y = vectorOld1.y*nStepXold + deltaX*(vectorOld2.y - vectorOld1.y);

	mov	ebx, DWORD PTR _vectorOld2$27[esp+236]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR _vectorOld3$30[esp+232], xmm0
	movq	xmm0, QWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [ecx+eax*4+16]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2209 :         int vector1_x = vectorOld1.x*nStepXold + deltaX*(vectorOld2.x - vectorOld1.x); // scaled by nStepXold to skip slow division

	mov	ecx, DWORD PTR _deltaX$1$[esp+232]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	mov	DWORD PTR _vectorOld4$1$[esp+232], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2209 :         int vector1_x = vectorOld1.x*nStepXold + deltaX*(vectorOld2.x - vectorOld1.x); // scaled by nStepXold to skip slow division

	mov	eax, DWORD PTR _vectorOld1$28[esp+232]
	sub	edi, eax
	imul	eax, DWORD PTR _nStepXold$1$[esp+232]
	imul	edi, ecx
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR _vectorOld4$29[esp+232], xmm0
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2209 :         int vector1_x = vectorOld1.x*nStepXold + deltaX*(vectorOld2.x - vectorOld1.x); // scaled by nStepXold to skip slow division

	add	edi, eax

; 2210 :         int vector1_y = vectorOld1.y*nStepXold + deltaX*(vectorOld2.y - vectorOld1.y);

	mov	eax, DWORD PTR _vectorOld1$28[esp+236]
	sub	ebx, eax
	imul	eax, DWORD PTR _nStepXold$1$[esp+232]
	imul	ebx, ecx
	add	ebx, eax

; 2211 :         cumulated_sad_t vector1_sad = (cumulated_sad_t)vectorOld1.sad*nStepXold + deltaX*((cumulated_sad_t)vectorOld2.sad - vectorOld1.sad);

	mov	eax, DWORD PTR _vector1_sad$1$[esp+232]
	sub	eax, edx
	imul	edx, DWORD PTR _nStepXold$1$[esp+232]
	imul	eax, ecx

; 2212 : 
; 2213 :         int vector2_x = vectorOld3.x*nStepXold + deltaX*(vectorOld4.x - vectorOld3.x);

	mov	ecx, DWORD PTR _vectorOld3$30[esp+232]
	add	eax, edx
	mov	DWORD PTR _vector1_sad$1$[esp+232], eax
	mov	eax, DWORD PTR _vectorOld4$29[esp+232]
	sub	eax, ecx
	imul	ecx, DWORD PTR _nStepXold$1$[esp+232]
	imul	eax, DWORD PTR _deltaX$1$[esp+232]

; 2216 : 
; 2217 :         vectorOld.x = (vector1_x + deltaY*(vector2_x - vector1_x) / nStepYold) / nStepXold;

	add	eax, ecx
	mov	ecx, DWORD PTR _vectorOld3$30[esp+236]
	sub	eax, edi
	imul	eax, DWORD PTR _deltaY$1$[esp+232]
	cdq
	idiv	DWORD PTR _nStepYold$1$[esp+232]
	add	eax, edi
	cdq
	idiv	DWORD PTR _nStepXold$1$[esp+232]
	mov	DWORD PTR _vectorOld$17[esp+232], eax
	mov	eax, DWORD PTR _vectorOld4$29[esp+236]
	sub	eax, ecx
	imul	ecx, DWORD PTR _nStepXold$1$[esp+232]
	imul	eax, DWORD PTR _deltaX$1$[esp+232]

; 2218 :         vectorOld.y = (vector1_y + deltaY*(vector2_y - vector1_y) / nStepYold) / nStepXold;

	add	eax, ecx
	sub	eax, ebx
	imul	eax, DWORD PTR _deltaY$1$[esp+232]
	cdq
	idiv	DWORD PTR _nStepYold$1$[esp+232]
	add	eax, ebx
	mov	ebx, DWORD PTR _nStepXold$1$[esp+232]
	cdq
	idiv	ebx
	mov	DWORD PTR _vectorOld$17[esp+236], eax
	mov	eax, DWORD PTR _vectorOld4$1$[esp+232]

; 2214 :         int vector2_y = vectorOld3.y*nStepXold + deltaX*(vectorOld4.y - vectorOld3.y);
; 2215 :         cumulated_sad_t vector2_sad = (cumulated_sad_t)vectorOld3.sad*nStepXold + deltaX*((cumulated_sad_t)vectorOld4.sad - vectorOld3.sad);

	mov	ecx, DWORD PTR _vectorOld3$3$[esp+232]
	sub	eax, ecx
	imul	eax, DWORD PTR _deltaX$1$[esp+232]
	imul	ecx, ebx

; 2219 :         vectorOld.sad = (sad_t)((vector1_sad + deltaY*(vector2_sad - vector1_sad) / nStepYold) / nStepXold);

	add	eax, ecx
	sub	eax, DWORD PTR _vector1_sad$1$[esp+232]
	imul	eax, DWORD PTR _deltaY$1$[esp+232]
	cdq
	idiv	DWORD PTR _nStepYold$1$[esp+232]
	add	eax, DWORD PTR _vector1_sad$1$[esp+232]
	cdq
	idiv	ebx

; 2220 :       }
; 2221 : 
; 2222 :       else // nearest

	mov	ebx, DWORD PTR _this$1$[esp+232]
	jmp	SHORT $LN499@recalculat
$LN33@recalculat:

; 2223 :       {
; 2224 :         if (deltaX * 2 < nStepXold && deltaY * 2 < nStepYold)

	mov	edx, DWORD PTR _deltaX$1$[esp+232]
	mov	eax, DWORD PTR _deltaY$1$[esp+232]
	add	edx, edx
	add	eax, eax
	cmp	edx, DWORD PTR _nStepXold$1$[esp+232]
	jge	SHORT $LN498@recalculat
	cmp	eax, DWORD PTR _nStepYold$1$[esp+232]
	jge	SHORT $LN37@recalculat

; 2226 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold1 + blkyold1*nBlkXold).GetMV();

	imul	edi, DWORD PTR _nBlkXold$1$[esp+232]
	add	edi, DWORD PTR _blkxold1$1$[esp+232]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	lea	ecx, DWORD PTR [edi+edi*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2226 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold1 + blkyold1*nBlkXold).GetMV();

	jmp	SHORT $LN500@recalculat
$LN498@recalculat:

; 2227 :         }
; 2228 :         else if (deltaX * 2 >= nStepXold && deltaY * 2 < nStepYold)

	cmp	eax, DWORD PTR _nStepYold$1$[esp+232]
	jge	SHORT $LN37@recalculat

; 2230 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold2 + blkyold1*nBlkXold).GetMV();

	imul	edi, DWORD PTR _nBlkXold$1$[esp+232]
	add	edi, DWORD PTR _blkxold2$1$[esp+232]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	lea	ecx, DWORD PTR [edi+edi*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2230 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold2 + blkyold1*nBlkXold).GetMV();

	jmp	SHORT $LN500@recalculat
$LN37@recalculat:

; 2231 :         }
; 2232 :         else if (deltaX * 2 < nStepXold && deltaY * 2 >= nStepYold)

	cmp	edx, DWORD PTR _nStepXold$1$[esp+232]
	jge	SHORT $LN39@recalculat
	cmp	eax, DWORD PTR _nStepYold$1$[esp+232]
	jl	SHORT $LN39@recalculat

; 2233 :         {
; 2234 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold1 + blkyold2*nBlkXold).GetMV();

	imul	ecx, DWORD PTR _nBlkXold$1$[esp+232]
	add	ecx, DWORD PTR _blkxold1$1$[esp+232]

; 2235 :         }
; 2236 :         else //(deltaX*2>=nStepXold && deltaY*2>=nStepYold )

	jmp	SHORT $LN501@recalculat
$LN39@recalculat:

; 2238 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold2 + blkyold2*nBlkXold).GetMV();

	imul	ecx, DWORD PTR _nBlkXold$1$[esp+232]
	add	ecx, DWORD PTR _blkxold2$1$[esp+232]
$LN501@recalculat:
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	lea	ecx, DWORD PTR [ecx+ecx*4]
$LN500@recalculat:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+320]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2238 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold2 + blkyold2*nBlkXold).GetMV();

	movq	xmm0, QWORD PTR [eax+ecx*4+8]
	mov	eax, DWORD PTR [eax+ecx*4+16]
	movq	QWORD PTR _vectorOld$17[esp+232], xmm0
$LN499@recalculat:

; 2239 :         }
; 2240 :       }
; 2241 : 
; 2242 :       // scale vector to new nPel
; 2243 :       vectorOld.x = (vectorOld.x << nLogPel) >> nLogPelold;

	mov	edx, DWORD PTR _vectorOld$17[esp+232]
	mov	ecx, DWORD PTR [ebx+24]

; 2244 :       vectorOld.y = (vectorOld.y << nLogPel) >> nLogPelold;

	mov	edi, DWORD PTR _vectorOld$17[esp+236]
	shl	edx, cl
	mov	ecx, DWORD PTR _result$1$[esp+232]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebx+24]
	shl	edi, cl
	mov	ecx, DWORD PTR _result$1$[esp+232]
	mov	DWORD PTR $T3[esp+232], eax

; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;

	mov	eax, DWORD PTR [esi+368]

; 2244 :       vectorOld.y = (vectorOld.y << nLogPel) >> nLogPelold;

	sar	edi, cl

; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;

	cmp	edx, eax
	jl	SHORT $LN284@recalculat

; 1757 :   else if (vx >= workarea.nDxMax) return workarea.nDxMax - 1;

	mov	eax, DWORD PTR [esi+376]
	cmp	edx, eax
	jl	SHORT $LN283@recalculat
	dec	eax
	jmp	SHORT $LN284@recalculat
$LN283@recalculat:

; 1758 :   else return vx;

	mov	eax, edx
$LN284@recalculat:

; 1774 :   v2.x = ClipMVx(workarea, v.x);

	mov	DWORD PTR $T16[esp+232], eax

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	mov	eax, DWORD PTR $T8[esp+232]
	cmp	edi, eax
	jl	SHORT $LN290@recalculat

; 1766 :   else if (vy >= workarea.nDyMax) return workarea.nDyMax - 1;

	mov	eax, DWORD PTR [esi+380]
	cmp	edi, eax
	jl	SHORT $LN289@recalculat
	dec	eax
	jmp	SHORT $LN290@recalculat
$LN289@recalculat:

; 1767 :   else return vy;

	mov	eax, edi
$LN290@recalculat:

; 2245 : 
; 2246 :       workarea.predictor = ClipMV(workarea, vectorOld); // predictor

	mov	ecx, DWORD PTR $T3[esp+232]

; 1775 :   v2.y = ClipMVy(workarea, v.y);

	mov	DWORD PTR $T16[esp+236], eax

; 2245 : 
; 2246 :       workarea.predictor = ClipMV(workarea, vectorOld); // predictor

	movq	xmm0, QWORD PTR $T16[esp+232]
	movq	QWORD PTR [esi+116], xmm0
	mov	DWORD PTR [esi+124], ecx

; 2247 :       workarea.predictor.sad = (sad_t)((cumulated_sad_t)vectorOld.sad * (nBlkSizeX*nBlkSizeY) / (nBlkSizeXold*nBlkSizeYold)); // normalized to new block size

	mov	eax, DWORD PTR [ebx+8]
	imul	eax, ecx
	imul	eax, DWORD PTR [ebx+12]
	cdq
	idiv	DWORD PTR tv3726[esp+232]
	mov	DWORD PTR [esi+124], eax

; 2248 : 
; 2249 : //			workarea.bestMV = workarea.predictor; // by pointer?
; 2250 :       workarea.bestMV.x = workarea.predictor.x;

	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR [esi+100], eax

; 2251 :       workarea.bestMV.y = workarea.predictor.y;

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+104], eax

; 2252 :       workarea.bestMV.sad = workarea.predictor.sad;

	mov	eax, DWORD PTR [esi+124]
	mov	DWORD PTR [esi+108], eax

; 2253 : 
; 2254 :       // update SAD
; 2255 : #ifdef ALLOW_DCT
; 2256 :       if (dctmode != 0) // DCT method (luma only - currently use normal spatial SAD chroma)

	mov	eax, DWORD PTR [ebx+216]
	test	eax, eax
	je	SHORT $LN42@recalculat

; 2257 :       {
; 2258 :         // make dct of source block
; 2259 :         if (dctmode <= 4) //don't do the slow dct conversion if SATD used

	cmp	eax, 4
	jg	SHORT $LN42@recalculat

; 2260 :         {
; 2261 :           workarea.DCT->DCTBytes2D(workarea.pSrc[0], nSrcPitch[0], &workarea.dctSrc[0], dctpitch);

	push	DWORD PTR [ebx+124]
	mov	ecx, DWORD PTR [esi+48]
	push	DWORD PTR [esi+404]
	push	DWORD PTR [ebx+168]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [esi+88]
	call	DWORD PTR [eax]
$LN42@recalculat:

; 2262 :         }
; 2263 :       }
; 2264 :       if (dctmode >= 3) // most use it and it should be fast anyway //if (dctmode == 3 || dctmode == 4) // check it

	cmp	DWORD PTR [ebx+216], 3
	jl	SHORT $LN43@recalculat

; 2265 :       {
; 2266 :         workarea.srcLuma = LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [ebx+168]
	mov	eax, DWORD PTR [ebx+84]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 8
	mov	DWORD PTR [esi+392], eax
$LN43@recalculat:

; 2270 :       sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	cmp	BYTE PTR [ebx+122], 0
	je	$LN64@recalculat

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]

; 2270 :       sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	mov	ecx, DWORD PTR [esi+120]
	mov	edi, DWORD PTR [esi+116]
	mov	DWORD PTR _nVy$1$[esp+232], ecx
	mov	DWORD PTR _nVx$1$[esp+232], edi

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	cmp	eax, 2
	jne	SHORT $LN307@recalculat
	mov	eax, DWORD PTR [ebx+164]
	mov	edx, ecx
	mov	DWORD PTR _this$1$[esp+232], eax
	mov	eax, DWORD PTR [ebx+60]
	mov	ecx, eax
	sar	edx, cl
	mov	ecx, DWORD PTR _this$1$[esp+232]
	mov	DWORD PTR tv3795[esp+232], eax
	mov	eax, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [ecx+52]
	mov	ecx, eax
	mov	DWORD PTR tv3784[esp+232], eax
	mov	eax, DWORD PTR [esi+12]
	mov	edx, edi
	sar	edx, cl
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	add	edx, edx

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN502@recalculat
$LN307@recalculat:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR _this$1$[esp+232], eax
	jne	SHORT $LN305@recalculat
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+60]
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR tv3795[esp+232], eax
	mov	eax, edi
	sar	eax, cl
	add	eax, DWORD PTR [esi+12]
	mov	DWORD PTR tv3784[esp+232], ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebx+60]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	DWORD PTR tv3823[esp+232], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR _nVy$1$[esp+232]
	sar	eax, cl
	add	eax, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR tv3823[esp+232]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN503@recalculat
$LN305@recalculat:
	mov	eax, DWORD PTR [ebx+60]
	mov	edx, ecx
	mov	ecx, eax
	mov	DWORD PTR tv3795[esp+232], eax
	mov	eax, DWORD PTR [esi+24]
	sar	edx, cl
	mov	ecx, DWORD PTR _this$1$[esp+232]
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	edx, edi
	mov	eax, DWORD PTR [ecx+52]
	mov	ecx, eax
	sar	edx, cl
	mov	DWORD PTR tv3784[esp+232], eax
	mov	eax, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	shl	edx, 2
	and	eax, 3

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN502@recalculat:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR _this$1$[esp+232]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$1$[esp+232]
	add	ecx, edi
	mov	edi, DWORD PTR _nVx$1$[esp+232]
	mov	eax, DWORD PTR [edx+4]
	imul	ebx, DWORD PTR [eax+12]
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+232]
$LN503@recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	DWORD PTR tv3823[esp+232], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	cmp	eax, 2
	jne	SHORT $LN334@recalculat
	mov	ecx, DWORD PTR tv3795[esp+232]
	mov	edx, DWORD PTR _nVy$1$[esp+232]
	mov	eax, DWORD PTR [esi+28]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3784[esp+232]
	sar	edi, cl
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edi+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1
	or	edx, eax

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR _this$1$[esp+232]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$1$[esp+232]
	add	eax, edi
	mov	DWORD PTR _nVx$1$[esp+232], eax
	mov	edi, DWORD PTR _nVx$1$[esp+232]
	mov	eax, DWORD PTR [edx+8]
	imul	ebx, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN504@recalculat
$LN334@recalculat:
	cmp	eax, 1
	jne	SHORT $LN332@recalculat
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [edx+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR tv3784[esp+232]
	mov	edx, DWORD PTR _nVy$1$[esp+232]
	sar	edi, cl
	add	edi, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	shl	edi, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebx+60]
	sar	edx, cl
	add	edx, DWORD PTR [esi+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax]
	add	edi, edx
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN333@recalculat
$LN332@recalculat:
	mov	ecx, DWORD PTR tv3795[esp+232]
	mov	edx, DWORD PTR _nVy$1$[esp+232]
	mov	eax, DWORD PTR [esi+28]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3784[esp+232]
	sar	edi, cl
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edi+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3
	or	edx, eax

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR _this$1$[esp+232]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	edi, eax
	mov	edx, DWORD PTR _this$1$[esp+232]
	mov	ecx, DWORD PTR [edx+8]
	imul	ebx, DWORD PTR [ecx+12]
$LN504@recalculat:
	add	edi, ebx
	mov	ebx, DWORD PTR _this$1$[esp+232]
$LN333@recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2270 :       sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	push	DWORD PTR [ebx+184]
	mov	eax, DWORD PTR [ebx+100]
	push	DWORD PTR tv3823[esp+236]
	push	DWORD PTR [ebx+172]
	push	DWORD PTR [esi+92]
	call	eax
	push	DWORD PTR [ebx+188]
	mov	ecx, DWORD PTR [ebx+100]
	push	edi
	push	DWORD PTR [ebx+176]
	mov	DWORD PTR _saduv$1$[esp+260], eax
	push	DWORD PTR [esi+96]
	call	ecx
	add	esp, 32					; 00000020H
	add	DWORD PTR _saduv$1$[esp+232], eax
	jmp	SHORT $LN65@recalculat
$LN64@recalculat:
	mov	DWORD PTR _saduv$1$[esp+232], 0
$LN65@recalculat:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebx+20]

; 2271 :         + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[2]) : 0;
; 2272 :       sad_t sad = LumaSAD(workarea, GetRefBlock(workarea, workarea.predictor.x, workarea.predictor.y));

	mov	edi, DWORD PTR [esi+120]
	mov	edx, DWORD PTR [esi+116]

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	cmp	eax, 2
	jne	SHORT $LN361@recalculat
	mov	eax, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	add	edx, edx

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN505@recalculat
$LN361@recalculat:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	jne	SHORT $LN359@recalculat
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	mov	DWORD PTR $T6[esp+232], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	add	eax, DWORD PTR [esi+116]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	shl	eax, cl
	mov	ecx, DWORD PTR $T6[esp+232]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN360@recalculat
$LN359@recalculat:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	shl	edx, 2
	and	eax, 3

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN505@recalculat:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	DWORD PTR $T7[esp+232], ecx
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR $T7[esp+232]
	add	ecx, edi
	imul	ebx, DWORD PTR [eax+12]
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+232]
$LN360@recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [ebx+216], 0
	jne	SHORT $LN386@recalculat
	push	DWORD PTR [ebx+180]
	mov	eax, DWORD PTR [ebx+80]
	push	ecx
	push	DWORD PTR [ebx+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN387@recalculat
$LN386@recalculat:
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN387@recalculat:

; 2273 :       sad += saduv;

	add	eax, DWORD PTR _saduv$1$[esp+232]

; 2274 :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], eax

; 2275 :       workarea.nMinCost = sad;

	mov	DWORD PTR [esi+112], eax

; 2276 : 
; 2277 :       if (workarea.bestMV.sad > _thSAD)// if old interpolated vector is bad

	cmp	eax, DWORD PTR [ebx+328]
	jle	$LN21@recalculat

; 2278 :       {
; 2279 :         //				CheckMV(vectorOld1.x, vectorOld1.y);
; 2280 :         //				CheckMV(vectorOld2.x, vectorOld2.y);
; 2281 :         //				CheckMV(vectorOld3.x, vectorOld3.y);
; 2282 :         //				CheckMV(vectorOld4.x, vectorOld4.y);
; 2283 :                 // then, we refine, according to the search type
; 2284 :         if (searchType & ONETIME)

	test	BYTE PTR [ebx+224], 1
	je	SHORT $LN9@recalculat

; 2285 :         {
; 2286 :           for (int i = nSearchParam; i > 0; i /= 2)

	mov	edi, DWORD PTR [ebx+228]
	test	edi, edi
	jle	SHORT $LN9@recalculat
$LL10@recalculat:

; 2287 :           {
; 2288 :             OneTimeSearch(workarea, i);

	push	edi
	push	esi
	mov	ecx, ebx
	call	?OneTimeSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::OneTimeSearch
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	test	edi, edi
	jg	SHORT $LL10@recalculat
$LN9@recalculat:

; 2289 :           }
; 2290 :         }
; 2291 : 
; 2292 :         if (searchType & NSTEP)

	test	BYTE PTR [ebx+224], 2
	je	SHORT $LN46@recalculat

; 2293 :         {
; 2294 :           NStepSearch(workarea, nSearchParam);

	push	DWORD PTR [ebx+228]
	mov	ecx, ebx
	push	esi
	call	?NStepSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::NStepSearch
$LN46@recalculat:

; 2295 :         }
; 2296 : 
; 2297 :         if (searchType & LOGARITHMIC)

	test	BYTE PTR [ebx+224], 4
	je	SHORT $LN12@recalculat

; 2298 :         {
; 2299 :           for (int i = nSearchParam; i > 0; i /= 2)

	mov	edi, DWORD PTR [ebx+228]
	test	edi, edi
	jle	SHORT $LN12@recalculat
$LL13@recalculat:

; 2300 :           {
; 2301 :             DiamondSearch(workarea, i);

	push	edi
	push	esi
	mov	ecx, ebx
	call	?DiamondSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::DiamondSearch
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	test	edi, edi
	jg	SHORT $LL13@recalculat
$LN12@recalculat:

; 2302 :           }
; 2303 :         }
; 2304 : 
; 2305 :         if (searchType & EXHAUSTIVE)

	test	BYTE PTR [ebx+224], 8
	je	SHORT $LN15@recalculat

; 2306 :         {
; 2307 :           //       ExhaustiveSearch(nSearchParam);
; 2308 :           int mvx = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]

; 2309 :           int mvy = workarea.bestMV.y;
; 2310 :           for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	edi, 1
	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR _mvx$1$[esp+232], eax
	mov	DWORD PTR _mvy$1$[esp+232], ecx
	cmp	DWORD PTR [ebx+228], edi
	jl	SHORT $LN15@recalculat
	npad	4
$LL16@recalculat:

; 2311 :           {
; 2312 :             ExpandingSearch(workarea, i, 1, mvx, mvy);

	push	ecx
	push	eax
	push	1
	push	edi
	push	esi
	mov	ecx, ebx
	call	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch
	mov	eax, DWORD PTR _mvx$1$[esp+232]
	inc	edi
	mov	ecx, DWORD PTR _mvy$1$[esp+232]
	cmp	edi, DWORD PTR [ebx+228]
	jle	SHORT $LL16@recalculat
$LN15@recalculat:

; 2313 :           }
; 2314 :         }
; 2315 : 
; 2316 :         if (searchType & HEX2SEARCH)

	test	BYTE PTR [ebx+224], 16			; 00000010H
	je	SHORT $LN49@recalculat

; 2317 :         {
; 2318 :           Hex2Search(workarea, nSearchParam);

	push	DWORD PTR [ebx+228]
	mov	ecx, ebx
	push	esi
	call	?Hex2Search@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::Hex2Search
$LN49@recalculat:

; 2319 :         }
; 2320 : 
; 2321 :         if (searchType & UMHSEARCH)

	test	BYTE PTR [ebx+224], 32			; 00000020H
	je	SHORT $LN50@recalculat

; 2322 :         {
; 2323 :           UMHSearch(workarea, nSearchParam, workarea.bestMV.x, workarea.bestMV.y);

	push	DWORD PTR [esi+104]
	mov	ecx, ebx
	push	DWORD PTR [esi+100]
	push	DWORD PTR [ebx+228]
	push	esi
	call	?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z ; PlaneOfBlocks::UMHSearch
$LN50@recalculat:

; 2324 :         }
; 2325 : 
; 2326 :         if (searchType & HSEARCH)

	test	BYTE PTR [ebx+224], 64			; 00000040H
	je	SHORT $LN18@recalculat

; 2327 :         {
; 2328 :           int mvx = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]

; 2329 :           int mvy = workarea.bestMV.y;
; 2330 :           for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	edi, 1
	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR _mvx$1$[esp+232], eax
	mov	DWORD PTR _mvy$1$[esp+232], ecx
	cmp	DWORD PTR [ebx+228], edi
	jl	SHORT $LN18@recalculat

; 2327 :         {
; 2328 :           int mvx = workarea.bestMV.x;

	dec	eax
	mov	DWORD PTR tv3678[esp+232], eax
	npad	5
$LL19@recalculat:

; 2331 :           {
; 2332 :             CheckMV(workarea, mvx - i, mvy);

	push	ecx
	push	eax
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 2333 :             CheckMV(workarea, mvx + i, mvy);

	push	DWORD PTR _mvy$1$[esp+232]
	mov	eax, DWORD PTR _mvx$1$[esp+236]
	mov	ecx, ebx
	add	eax, edi
	push	eax
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	mov	eax, DWORD PTR tv3678[esp+232]
	inc	edi
	mov	ecx, DWORD PTR _mvy$1$[esp+232]
	dec	eax
	mov	DWORD PTR tv3678[esp+232], eax
	cmp	edi, DWORD PTR [ebx+228]
	jle	SHORT $LL19@recalculat
$LN18@recalculat:

; 2334 :           }
; 2335 :         }
; 2336 : 
; 2337 :         if (searchType & VSEARCH)

	test	BYTE PTR [ebx+224], 128			; 00000080H
	je	SHORT $LN21@recalculat

; 2338 :         {
; 2339 :           int mvx = workarea.bestMV.x;

	mov	ecx, DWORD PTR [esi+100]

; 2340 :           int mvy = workarea.bestMV.y;
; 2341 :           for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	edi, 1
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR _mvx$1$[esp+232], ecx
	mov	DWORD PTR _mvy$1$[esp+232], eax
	cmp	DWORD PTR [ebx+228], edi
	jl	SHORT $LN21@recalculat

; 2338 :         {
; 2339 :           int mvx = workarea.bestMV.x;

	dec	eax
	mov	DWORD PTR tv3675[esp+232], eax
	npad	4
$LL22@recalculat:

; 2342 :           {
; 2343 :             CheckMV(workarea, mvx, mvy - i);

	push	eax
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 2344 :             CheckMV(workarea, mvx, mvy + i);

	mov	eax, DWORD PTR _mvy$1$[esp+232]
	mov	ecx, ebx
	add	eax, edi
	push	eax
	push	DWORD PTR _mvx$1$[esp+236]
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	mov	eax, DWORD PTR tv3675[esp+232]
	inc	edi
	mov	ecx, DWORD PTR _mvx$1$[esp+232]
	dec	eax
	mov	DWORD PTR tv3675[esp+232], eax
	cmp	edi, DWORD PTR [ebx+228]
	jle	SHORT $LL22@recalculat
$LN21@recalculat:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2350 :       vectors[workarea.blkIdx].x = workarea.bestMV.x;

	mov	ecx, DWORD PTR [ebx+108]

; 2353 : 
; 2354 :       if (outfilebuf != NULL) // write vector to outfile

	mov	edi, DWORD PTR _outfilebuf$1$[esp+232]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2350 :       vectors[workarea.blkIdx].x = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [ecx+edx*4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2351 :       vectors[workarea.blkIdx].y = workarea.bestMV.y;

	mov	ecx, DWORD PTR [ebx+108]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2351 :       vectors[workarea.blkIdx].y = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [ecx+edx*4+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2352 :       vectors[workarea.blkIdx].sad = workarea.bestMV.sad;

	mov	ecx, DWORD PTR [ebx+108]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2352 :       vectors[workarea.blkIdx].sad = workarea.bestMV.sad;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [ecx+edx*4+8], eax

; 2353 : 
; 2354 :       if (outfilebuf != NULL) // write vector to outfile

	test	edi, edi
	je	SHORT $LN53@recalculat

; 2355 :       {
; 2356 :         outfilebuf[workarea.blkx * 4 + 0] = workarea.bestMV.x;

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+100]
	mov	WORD PTR [edi+ecx*8], ax

; 2357 :         outfilebuf[workarea.blkx * 4 + 1] = workarea.bestMV.y;

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+104]
	mov	WORD PTR [edi+ecx*8+2], ax

; 2358 :         // todo: SAD as int when it is float
; 2359 :         outfilebuf[workarea.blkx * 4 + 2] = (workarea.bestMV.sad & 0x0000ffff); // low word

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+108]
	mov	WORD PTR [edi+ecx*8+4], ax

; 2360 :         outfilebuf[workarea.blkx * 4 + 3] = (workarea.bestMV.sad >> 16);     // high word, usually null

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+110]
	mov	WORD PTR [edi+ecx*8+6], ax
$LN53@recalculat:

; 2361 :       }
; 2362 : 
; 2363 :       /* write the results */
; 2364 :       pBlkData[workarea.blkx*N_PER_BLOCK + 0] = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR _pBlkData$1$[esp+232]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [edx+ecx*4], eax

; 2365 :       pBlkData[workarea.blkx*N_PER_BLOCK + 1] = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 2366 :       pBlkData[workarea.blkx*N_PER_BLOCK + 2] = workarea.bestMV.sad;

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 2367 : 
; 2368 : 
; 2369 :       PROFILE_STOP(MOTION_PROFILE_ME);
; 2370 : 
; 2371 :       if (smallestPlane)

	cmp	BYTE PTR [ebx+120], 0
	je	$LN54@recalculat

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [esi+8]
	cmp	eax, 2
	jne	SHORT $LN425@recalculat
	mov	eax, DWORD PTR [ebx+164]
	add	edi, edi
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	add	eax, eax
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	eax, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN506@recalculat
$LN425@recalculat:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jne	SHORT $LN423@recalculat
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN507@recalculat
$LN423@recalculat:
	mov	eax, DWORD PTR [esi+20]
	shl	edi, 2
	shl	eax, 2
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	eax, 2
$LN506@recalculat:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
$LN507@recalculat:
	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2375 :         workarea.sumLumaChange += (cumulated_sad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (cumulated_sad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [ebx+180]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2375 :         workarea.sumLumaChange += (cumulated_sad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (cumulated_sad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	mov	eax, DWORD PTR [ebx+84]
	push	edi
	call	eax
	push	DWORD PTR [ebx+168]
	mov	ecx, DWORD PTR [ebx+84]
	mov	edi, eax
	push	DWORD PTR [esi+88]
	call	ecx
	sub	edi, eax
	add	esp, 16					; 00000010H
	mov	eax, edi
	mov	edi, DWORD PTR _outfilebuf$1$[esp+232]
	cdq
	add	DWORD PTR [esi+72], eax
	adc	DWORD PTR [esi+76], edx
$LN54@recalculat:

; 2376 :       }
; 2377 : 
; 2378 :       if (iblkx < nBlkX - 1)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _iblkx$1$[esp+232]
	dec	eax
	cmp	ecx, eax
	jge	SHORT $LN5@recalculat

; 2379 :       {
; 2380 :         workarea.x[0] += nBlkSizeX_Ovr[0]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$1$[esp+232]
	add	DWORD PTR [esi+8], eax

; 2381 :         workarea.x[1] += nBlkSizeX_Ovr[1]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$3$[esp+232]
	add	DWORD PTR [esi+12], eax

; 2382 :         workarea.x[2] += nBlkSizeX_Ovr[2]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$3$[esp+232]
	add	DWORD PTR [esi+16], eax
$LN5@recalculat:

; 2129 :       }
; 2130 :     }
; 2131 : 
; 2132 :     for (int iblkx = 0; iblkx < nBlkX; iblkx++)

	inc	ecx
	mov	DWORD PTR _iblkx$1$[esp+232], ecx
	cmp	ecx, DWORD PTR [ebx]
	jl	$LL7@recalculat
	mov	edx, DWORD PTR _pBlkData$1$[esp+232]
$LN6@recalculat:

; 2383 :       }
; 2384 :     }	// for workarea.blkx
; 2385 : 
; 2386 :     pBlkData += nBlkX*N_PER_BLOCK;

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pBlkData$1$[esp+232], edx

; 2387 :     if (outfilebuf != NULL) // write vector to outfile

	test	edi, edi
	je	SHORT $LN56@recalculat

; 2388 :     {
; 2389 :       outfilebuf += nBlkX * 4;// 4 short word per block

	lea	edi, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR _outfilebuf$1$[esp+232], edi
$LN56@recalculat:

; 2390 :     }
; 2391 : 
; 2392 :     workarea.y[0] += nBlkSizeY_Ovr[0];

	mov	eax, DWORD PTR _nBlkSizeY_Ovr$1$[esp+232]
	add	DWORD PTR [esi+20], eax

; 2393 :     workarea.y[1] += nBlkSizeY_Ovr[1];

	mov	eax, DWORD PTR _nBlkSizeY_Ovr$3$[esp+232]
	add	DWORD PTR [esi+24], eax

; 2394 :     workarea.y[2] += nBlkSizeY_Ovr[2];

	add	DWORD PTR [esi+28], eax
	inc	DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+36]
	cmp	eax, DWORD PTR [esi+84]
	jl	$LL4@recalculat
$LN3@recalculat:
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+64]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2397 :   planeSAD += workarea.planeSAD;

	lea	ecx, DWORD PTR [ebx+264]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	DWORD PTR _ftor$15[esp+240], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	edx, DWORD PTR _ftor$15[esp+232]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR _ftor$15[esp+244], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	eax, DWORD PTR _val_new$26[esp+232]
	push	eax
	lea	eax, DWORD PTR _val_old$24[esp+236]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _ftor$15[esp+236], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	push	eax
	call	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+72]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2398 :   sumLumaChange += workarea.sumLumaChange;

	lea	ecx, DWORD PTR [ebx+272]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	DWORD PTR _ftor$14[esp+248], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	edx, DWORD PTR _ftor$14[esp+240]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR _ftor$14[esp+252], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	eax, DWORD PTR _val_new$25[esp+240]
	push	eax
	lea	eax, DWORD PTR _val_old$23[esp+244]
; File c:\github\mvtools\sources\conc\aioadd.h

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR _ftor$15[esp+244], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	push	eax
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _ftor$14[esp+248], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	call	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
	add	esp, 16					; 00000010H
; File c:\github\mvtools\sources\conc\aioadd.h

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR _ftor$14[esp+232], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2400 :   if (isse)

	cmp	BYTE PTR [ebx+121], 0
	je	SHORT $LN57@recalculat

; 2401 :   {
; 2402 : #ifndef _M_X64
; 2403 :     _mm_empty();

	emms
$LN57@recalculat:

; 2404 : #endif
; 2405 :   }
; 2406 : 
; 2407 : #ifdef ALLOW_DCT
; 2408 :   if (_dct_pool_ptr != 0)

	mov	ecx, DWORD PTR [ebx+128]
	test	ecx, ecx
	je	SHORT $LN58@recalculat

; 2409 :   {
; 2410 :     _dct_pool_ptr->return_obj(*(workarea.DCT));

	push	DWORD PTR [esi+48]
	call	?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z ; conc::ObjPool<DCTClass>::return_obj

; 2411 :     workarea.DCT = 0;

	mov	DWORD PTR [esi+48], 0
$LN58@recalculat:

; 2412 :   }
; 2413 : #endif
; 2414 : 
; 2415 :   _workarea_pool.return_obj(workarea);

	push	esi
	lea	ecx, DWORD PTR [ebx+376]
	call	?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::return_obj

; 2416 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$recalculate_mv_slice@E@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ENDP ; PlaneOfBlocks::recalculate_mv_slice<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.h
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.h
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??$recalculate_mv_slice@G@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_nVy$1$ = -240						; size = 4
_saduv$1$ = -240					; size = 4
_blkxold2$1$ = -240					; size = 4
tv3726 = -240						; size = 4
tv3573 = -240						; size = 4
tv3571 = -240						; size = 4
tv3239 = -240						; size = 4
$T1 = -240						; size = 4
_blkxold$2 = -240					; size = 4
$T3 = -236						; size = 4
_this$1$ = -236						; size = 4
_deltaX$1$ = -236					; size = 4
_vector1_sad$1$ = -232					; size = 4
_mvx$1$ = -232						; size = 4
_mvy$1$ = -232						; size = 4
_vectorOld1$3$ = -232					; size = 4
tv3699 = -232						; size = 4
$T4 = -232						; size = 4
_blkyold$5 = -232					; size = 4
_this$1$ = -228						; size = 4
$T6 = -224						; size = 4
$T7 = -224						; size = 4
$T8 = -224						; size = 4
_mvy$1$ = -224						; size = 4
_mvx$1$ = -224						; size = 4
_mvx$1$ = -224						; size = 4
_nStepXold$1$ = -220					; size = 4
_deltaY$1$ = -216					; size = 4
tv3728 = -216						; size = 4
_nVx$1$ = -212						; size = 4
_blkxold1$1$ = -212					; size = 4
tv3241 = -212						; size = 4
_vector1_y$1$ = -208					; size = 4
_blkyold2$1$ = -208					; size = 4
tv3689 = -208						; size = 4
_nStepYold$1$ = -204					; size = 4
_nBlkXold$1$ = -200					; size = 4
tv3333 = -196						; size = 4
$T9 = -196						; size = 4
$T10 = -196						; size = 4
$T11 = -196						; size = 4
$T12 = -196						; size = 4
$T13 = -196						; size = 4
_pBlkData$1$ = -192					; size = 4
_outfilebuf$1$ = -188					; size = 4
_nBlkSizeYold$1$ = -184					; size = 4
_result$1$ = -180					; size = 4
_nBlkSizeX_Ovr$3$ = -176				; size = 4
_vector1_sad$2$ = -172					; size = 4
_mvy$1$ = -172						; size = 4
_ftor$14 = -168						; size = 16
_ftor$15 = -168						; size = 16
$T16 = -168						; size = 12
_blkxStart$1$ = -148					; size = 4
_nBlkYold$1$ = -144					; size = 4
_nBlkSizeX_Ovr$1$ = -140				; size = 4
_iblkx$1$ = -136					; size = 4
_vectorOld$17 = -132					; size = 12
tv3647 = -120						; size = 4
tv3646 = -116						; size = 4
$T18 = -112						; size = 4
$T19 = -108						; size = 4
$T20 = -104						; size = 4
$T21 = -100						; size = 4
$T22 = -96						; size = 4
_vectorOld4$1$ = -92					; size = 4
_vectorOld3$3$ = -88					; size = 4
tv3649 = -84						; size = 4
_nBlkSizeXold$1$ = -80					; size = 4
tv3331 = -76						; size = 4
_nBlkSizeY_Ovr$1$ = -72					; size = 4
_val_old$23 = -72					; size = 8
_val_old$24 = -72					; size = 8
_nBlkSizeY_Ovr$3$ = -64					; size = 4
_val_new$25 = -64					; size = 8
_val_new$26 = -64					; size = 8
tv3648 = -52						; size = 4
_vectorOld2$27 = -48					; size = 12
_vectorOld1$28 = -36					; size = 12
_vectorOld4$29 = -24					; size = 12
_vectorOld3$30 = -12					; size = 12
_td$ = 8						; size = 4
??$recalculate_mv_slice@G@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z PROC ; PlaneOfBlocks::recalculate_mv_slice<unsigned short>, COMDAT
; _this$ = ecx

; 2052 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 244				; 000000f4H
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[esp+256], ebx

; 2053 :   assert(&td != 0);
; 2054 : 
; 2055 :   short *			outfilebuf = _outfilebuf;

	mov	edi, DWORD PTR [ebx+300]

; 2056 : 
; 2057 :   WorkingArea &	workarea = *(_workarea_pool.take_obj());

	lea	ecx, DWORD PTR [ebx+376]
	mov	DWORD PTR _outfilebuf$1$[esp+256], edi
	call	?take_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::take_obj

; 2058 :   assert(&workarea != 0);
; 2059 : 
; 2060 :   workarea.blky_beg = td._y_beg;

	mov	edx, DWORD PTR _td$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+80], eax

; 2061 :   workarea.blky_end = td._y_end;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+84], eax

; 2062 : 
; 2063 :   workarea.DCT = 0;

	mov	DWORD PTR [esi+48], 0

; 2064 : #ifdef ALLOW_DCT
; 2065 :   if (_dct_pool_ptr != 0)

	mov	ecx, DWORD PTR [ebx+128]
	test	ecx, ecx
	je	SHORT $LN23@recalculat

; 2066 :   {
; 2067 :     workarea.DCT = _dct_pool_ptr->take_obj();

	call	?take_obj@?$ObjPool@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ ; conc::ObjPool<DCTClass>::take_obj
	mov	DWORD PTR [esi+48], eax
$LN23@recalculat:

; 2068 :   }
; 2069 : #endif	// ALLOW_DCT
; 2070 :   workarea.globalMVPredictor = _glob_mv_pred_def;

	movq	xmm0, QWORD PTR [ebx+280]

; 2071 : 
; 2072 :   int *pBlkData = _out + 1 + workarea.blky_beg * nBlkX*N_PER_BLOCK;

	mov	edx, DWORD PTR [esi+80]
	movq	QWORD PTR [esi+52], xmm0
	mov	eax, DWORD PTR [ebx+288]
	mov	DWORD PTR [esi+60], eax
	imul	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+296]
	lea	ecx, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, 4
	mov	DWORD PTR _pBlkData$1$[esp+256], eax

; 2073 :   if (outfilebuf != NULL)

	test	edi, edi
	je	SHORT $LN24@recalculat

; 2074 :   {
; 2075 :     outfilebuf += workarea.blky_beg * nBlkX * 4;// 4 short word per block

	lea	edi, DWORD PTR [edi+edx*8]
	mov	DWORD PTR _outfilebuf$1$[esp+256], edi
$LN24@recalculat:

; 2078 :   workarea.y[0] = pSrcFrame->GetPlane(YPLANE)->GetVPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2078 :   workarea.y[0] = pSrcFrame->GetPlane(YPLANE)->GetVPadding();

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+20], ecx

; 2079 :   workarea.y[0] += workarea.blky_beg * (nBlkSizeY - nOverlapY);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	imul	eax, DWORD PTR [esi+80]
	add	eax, ecx
	mov	DWORD PTR [esi+20], eax

; 2080 :   if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	SHORT $LN25@recalculat

; 2082 :     workarea.y[1] = pSrcFrame->GetPlane(UPLANE)->GetVPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2082 :     workarea.y[1] = pSrcFrame->GetPlane(UPLANE)->GetVPadding();

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+24], eax

; 2083 :     workarea.y[2] = pSrcFrame->GetPlane(VPLANE)->GetVPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2083 :     workarea.y[2] = pSrcFrame->GetPlane(VPLANE)->GetVPadding();

	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+28], edx

; 2084 :     workarea.y[1] += workarea.blky_beg * ((nBlkSizeY - nOverlapY) >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR [ebx+60]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+80]
	add	DWORD PTR [esi+24], eax

; 2085 :     workarea.y[2] += workarea.blky_beg * ((nBlkSizeY - nOverlapY) >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	ecx, DWORD PTR [ebx+60]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+80]
	add	eax, edx
	mov	DWORD PTR [esi+28], eax
$LN25@recalculat:

; 2086 :   }
; 2087 : 
; 2088 :   workarea.planeSAD = 0;

	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0

; 2089 :   workarea.sumLumaChange = 0;

	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+76], 0
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+320]
	mov	eax, DWORD PTR [eax+88]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 64   : 	inline int GetReducedWidth() const { return nBlkX; }

	mov	ecx, DWORD PTR [eax+8]

; 71   : 	inline int GetBlockSizeY() const { return nBlkSizeY; }

	mov	edx, DWORD PTR [eax+20]

; 64   : 	inline int GetReducedWidth() const { return nBlkX; }

	mov	DWORD PTR _nBlkXold$1$[esp+256], ecx

; 65   : 	inline int GetReducedHeight() const { return nBlkY; }

	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _nBlkYold$1$[esp+256], ecx

; 70   : 	inline int GetBlockSizeX() const { return nBlkSizeX; }

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _nBlkSizeXold$1$[esp+256], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2099 :   int nStepXold = nBlkSizeXold - nOverlapXold;

	sub	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _nStepXold$1$[esp+256], ecx

; 2100 :   int nStepYold = nBlkSizeYold - nOverlapYold;

	mov	ecx, edx
	sub	ecx, DWORD PTR [eax+48]

; 2101 :   int nPelold = plane.GetPel();
; 2102 :   int nLogPelold = ilog2(nPelold);

	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _nStepYold$1$[esp+256], ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 25   : 	int result = 0;

	xor	ecx, ecx
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 71   : 	inline int GetBlockSizeY() const { return nBlkSizeY; }

	mov	DWORD PTR _nBlkSizeYold$1$[esp+256], edx
; File c:\github\mvtools\sources\commonfunctions.h

; 25   : 	int result = 0;

	mov	DWORD PTR _result$1$[esp+256], ecx

; 26   : 	while ( i > 1 ) { i /= 2; result++; }

	cmp	eax, 1
	jle	SHORT $LN105@recalculat
	npad	7
$LL104@recalculat:
	cdq
	inc	ecx
	sub	eax, edx
	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL104@recalculat
	mov	DWORD PTR _result$1$[esp+256], ecx
$LN105@recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2104 :   int nBlkSizeX_Ovr[3] = { (nBlkSizeX - nOverlapX), (nBlkSizeX - nOverlapX) >> nLogxRatioUV, (nBlkSizeX - nOverlapX) >> nLogxRatioUV };

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR _nBlkSizeX_Ovr$1$[esp+256], eax
	sar	eax, cl

; 2105 :   int nBlkSizeY_Ovr[3] = { (nBlkSizeY - nOverlapY), (nBlkSizeY - nOverlapY) >> nLogyRatioUV, (nBlkSizeY - nOverlapY) >> nLogyRatioUV };

	mov	ecx, DWORD PTR [ebx+60]
	mov	DWORD PTR _nBlkSizeX_Ovr$3$[esp+256], eax
	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR _nBlkSizeY_Ovr$1$[esp+256], eax
	sar	eax, cl
	mov	DWORD PTR _nBlkSizeY_Ovr$3$[esp+256], eax

; 2106 : 
; 2107 :   // Functions using float must not be used here
; 2108 :   for (workarea.blky = workarea.blky_beg; workarea.blky < workarea.blky_end; workarea.blky++)

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [esi+36], eax
	cmp	eax, DWORD PTR [esi+84]
	jge	$LN3@recalculat
	mov	edx, DWORD PTR _pBlkData$1$[esp+256]
	npad	2
$LL4@recalculat:

; 2109 :   {
; 2110 :     workarea.blkScanDir = (workarea.blky % 2 == 0 || !_meander_flag) ? 1 : -1;

	mov	eax, DWORD PTR [esi+36]
	and	eax, 1
	je	SHORT $LN60@recalculat
	cmp	BYTE PTR [ebx+308], 0
	je	SHORT $LN60@recalculat
	or	ecx, -1
	jmp	SHORT $LN61@recalculat
$LN60@recalculat:
	mov	ecx, 1
$LN61@recalculat:
	mov	DWORD PTR [esi+44], ecx
	test	eax, eax

; 2111 :     // meander (alternate) scan blocks (even row left to right, odd row right to left)
; 2112 :     int blkxStart = (workarea.blky % 2 == 0 || !_meander_flag) ? 0 : nBlkX - 1;

	je	SHORT $LN62@recalculat
	cmp	BYTE PTR [ebx+308], 0
	je	SHORT $LN62@recalculat
	mov	eax, DWORD PTR [ebx]
	dec	eax
	mov	DWORD PTR _blkxStart$1$[esp+256], eax
	jmp	SHORT $LN63@recalculat
$LN62@recalculat:
	mov	DWORD PTR _blkxStart$1$[esp+256], 0
$LN63@recalculat:

; 2114 :     {
; 2115 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2113 :     if (workarea.blkScanDir == 1) // start with leftmost block

	cmp	ecx, 1
	jne	SHORT $LN26@recalculat

; 2114 :     {
; 2115 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+8], eax

; 2116 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	SHORT $LN29@recalculat

; 2118 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2118 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], eax

; 2119 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding();

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2119 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding();

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], eax

; 2120 :       }
; 2121 :     }
; 2122 :     else // start with rightmost block, but it is already set at prev row

	jmp	SHORT $LN29@recalculat
$LN26@recalculat:

; 2123 :     {
; 2124 :       workarea.x[0] = pSrcFrame->GetPlane(YPLANE)->GetHPadding() + nBlkSizeX_Ovr[0]*(nBlkX - 1);

	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$1$[esp+256]
	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+8], ecx

; 2125 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	SHORT $LN29@recalculat

; 2127 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding() + nBlkSizeX_Ovr[1]*(nBlkX - 1);

	mov	eax, DWORD PTR [ebx+160]
	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$3$[esp+256]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2127 :         workarea.x[1] = pSrcFrame->GetPlane(UPLANE)->GetHPadding() + nBlkSizeX_Ovr[1]*(nBlkX - 1);

	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+12], ecx

; 2128 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding() + nBlkSizeX_Ovr[2]*(nBlkX - 1);

	mov	eax, DWORD PTR [ebx+160]
	mov	ecx, DWORD PTR [ebx]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkSizeX_Ovr$3$[esp+256]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2128 :         workarea.x[2] = pSrcFrame->GetPlane(VPLANE)->GetHPadding() + nBlkSizeX_Ovr[2]*(nBlkX - 1);

	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+16], ecx
$LN29@recalculat:

; 2129 :       }
; 2130 :     }
; 2131 : 
; 2132 :     for (int iblkx = 0; iblkx < nBlkX; iblkx++)

	xor	ecx, ecx
	mov	DWORD PTR _iblkx$1$[esp+256], ecx
	cmp	DWORD PTR [ebx], ecx
	jle	$LN6@recalculat

; 2187 :       int blkyold = (centerY - nBlkSizeYold / 2) / nStepYold;
; 2188 : 
; 2189 :       int deltaX = std::max(0, centerX - (nBlkSizeXold / 2 + nStepXold*blkxold)); // distance from old to new

	mov	edi, DWORD PTR _nBlkSizeXold$1$[esp+256]
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	DWORD PTR $T13[esp+256], ecx
	sar	eax, 1
	mov	DWORD PTR tv3649[esp+256], eax
	mov	eax, DWORD PTR _nBlkSizeYold$1$[esp+256]
	cdq
	sub	eax, edx

; 2190 :       int deltaY = std::max(0, centerY - (nBlkSizeYold / 2 + nStepYold*blkyold));

	mov	DWORD PTR $T12[esp+256], ecx
	sar	eax, 1
	mov	DWORD PTR tv3648[esp+256], eax
	mov	eax, edi
	cdq
	sub	eax, edx

; 2191 : 
; 2192 :       int blkxold1 = std::min(nBlkXold - 1, std::max(0, blkxold));

	mov	DWORD PTR $T18[esp+256], ecx
	sar	eax, 1
	neg	eax

; 2193 :       int blkxold2 = std::min(nBlkXold - 1, std::max(0, blkxold + 1));

	mov	DWORD PTR $T20[esp+256], ecx
	mov	DWORD PTR tv3647[esp+256], eax
	mov	eax, DWORD PTR _nBlkSizeYold$1$[esp+256]
	cdq
	sub	eax, edx

; 2194 :       int blkyold1 = std::min(nBlkYold - 1, std::max(0, blkyold));

	mov	DWORD PTR $T21[esp+256], ecx
	mov	edx, DWORD PTR _nBlkXold$1$[esp+256]
	dec	edx
	sar	eax, 1
	neg	eax
	mov	DWORD PTR $T11[esp+256], edx
	mov	DWORD PTR $T19[esp+256], edx
	mov	edx, DWORD PTR _nBlkYold$1$[esp+256]
	mov	DWORD PTR tv3646[esp+256], eax
	dec	edx
	mov	eax, DWORD PTR _nBlkSizeYold$1$[esp+256]
	imul	eax, edi
	mov	DWORD PTR $T10[esp+256], edx

; 2195 :       int blkyold2 = std::min(nBlkYold - 1, std::max(0, blkyold + 1));

	mov	DWORD PTR $T9[esp+256], edx
	mov	DWORD PTR $T22[esp+256], ecx
	cdq
	mov	DWORD PTR tv3333[esp+256], eax
	mov	DWORD PTR tv3331[esp+256], edx
$LL7@recalculat:

; 2133 :     {
; 2134 :       workarea.blkx = blkxStart + iblkx*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, ecx
	mov	ecx, DWORD PTR _blkxStart$1$[esp+256]
	add	ecx, eax

; 2135 :       workarea.blkIdx = workarea.blky*nBlkX + workarea.blkx;

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+32], ecx
	imul	eax, DWORD PTR [ebx]
	add	eax, ecx
	mov	DWORD PTR [esi+40], eax

; 2141 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	add	eax, edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2141 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);

	mov	DWORD PTR [esi+88], eax

; 2142 :       //create aligned copy
; 2143 :       BLITLUMA(workarea.pSrc_temp[0], nSrcPitch[0], workarea.pSrc[0], nSrcPitch_plane[0]);

	push	DWORD PTR [ebx+192]
	push	eax
	push	DWORD PTR [ebx+168]
	mov	eax, DWORD PTR [ebx+92]
	push	DWORD PTR [esi+440]
	call	eax

; 2144 :       //set the to the aligned copy
; 2145 :       workarea.pSrc[0] = workarea.pSrc_temp[0];

	mov	eax, DWORD PTR [esi+440]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+88], eax

; 2146 :       if (chroma)

	cmp	BYTE PTR [ebx+122], 0
	je	$LN30@recalculat

; 2148 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2148 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);

	mov	DWORD PTR [esi+92], edi

; 2149 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvplane.h

; 109  : 		return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edx+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2149 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);

	mov	DWORD PTR [esi+96], edi

; 2150 :         BLITCHROMA(workarea.pSrc_temp[1], nSrcPitch[1], workarea.pSrc[1], nSrcPitch_plane[1]);

	push	DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [ebx+96]
	push	DWORD PTR [esi+92]
	push	DWORD PTR [ebx+172]
	push	DWORD PTR [esi+444]
	call	eax

; 2151 :         BLITCHROMA(workarea.pSrc_temp[2], nSrcPitch[2], workarea.pSrc[2], nSrcPitch_plane[2]);

	push	DWORD PTR [ebx+200]
	mov	eax, DWORD PTR [ebx+96]
	push	DWORD PTR [esi+96]
	push	DWORD PTR [ebx+176]
	push	DWORD PTR [esi+448]
	call	eax

; 2152 :         workarea.pSrc[1] = workarea.pSrc_temp[1];

	mov	eax, DWORD PTR [esi+444]
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+92], eax

; 2153 :         workarea.pSrc[2] = workarea.pSrc_temp[2];

	mov	eax, DWORD PTR [esi+448]
	mov	DWORD PTR [esi+96], eax
$LN30@recalculat:

; 2154 :       }
; 2155 : #else	// ALIGN_SOURCEBLOCK
; 2156 :       workarea.pSrc[0] = pSrcFrame->GetPlane(YPLANE)->GetAbsolutePelPointer(workarea.x[0], workarea.y[0]);
; 2157 :       if (chroma)
; 2158 :       {
; 2159 :         workarea.pSrc[1] = pSrcFrame->GetPlane(UPLANE)->GetAbsolutePelPointer(workarea.x[1], workarea.y[1]);
; 2160 :         workarea.pSrc[2] = pSrcFrame->GetPlane(VPLANE)->GetAbsolutePelPointer(workarea.x[2], workarea.y[2]);
; 2161 :       }
; 2162 : #endif	// ALIGN_SOURCEBLOCK
; 2163 : 
; 2164 :       if (workarea.blky == workarea.blky_beg)

	mov	eax, DWORD PTR [esi+36]
	cmp	eax, DWORD PTR [esi+80]
	jne	SHORT $LN31@recalculat

; 2165 :       {
; 2166 :         workarea.nLambda = 0;

	mov	DWORD PTR [esi+384], 0

; 2167 :       }
; 2168 :       else

	jmp	SHORT $LN32@recalculat
$LN31@recalculat:

; 2169 :       {
; 2170 :         workarea.nLambda = _lambda_level;

	mov	eax, DWORD PTR [ebx+292]
	mov	DWORD PTR [esi+384], eax
$LN32@recalculat:

; 2171 :       }
; 2172 : 
; 2173 :       penaltyNew = _pnew; // penalty for new vector

	mov	eax, DWORD PTR [ebx+312]
	mov	DWORD PTR [ebx+236], eax

; 2174 :       LSAD = _lsad;    // SAD limit for lambda using

	mov	eax, DWORD PTR [ebx+316]
	mov	DWORD PTR [ebx+232], eax

; 2178 :       workarea.nDxMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedWidth() - workarea.x[0] - nBlkSizeX);

	mov	eax, DWORD PTR [ebx+160]

; 2182 : 
; 2183 :       // get and interplolate old vectors
; 2184 :       int centerX = nBlkSizeX / 2 + (nBlkSizeX - nOverlapX)*workarea.blkx; // center of new block

	mov	ecx, DWORD PTR _this$1$[esp+256]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2178 :       workarea.nDxMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedWidth() - workarea.x[0] - nBlkSizeX);

	mov	eax, DWORD PTR [eax+36]
	sub	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [ebx+8]
	imul	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [esi+376], eax

; 2179 :       workarea.nDyMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedHeight() - workarea.y[0] - nBlkSizeY);

	mov	eax, DWORD PTR [ebx+160]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2179 :       workarea.nDyMax = nPel * (pSrcFrame->GetPlane(YPLANE)->GetExtendedHeight() - workarea.y[0] - nBlkSizeY);

	mov	eax, DWORD PTR [eax+40]
	sub	eax, DWORD PTR [esi+20]
	sub	eax, DWORD PTR [ebx+12]
	imul	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [esi+380], eax

; 2180 :       workarea.nDxMin = -nPel * workarea.x[0];

	mov	eax, DWORD PTR [esi+8]
	imul	eax, DWORD PTR [ebx+20]
	neg	eax
	mov	DWORD PTR [esi+368], eax

; 2181 :       workarea.nDyMin = -nPel * workarea.y[0];

	mov	eax, DWORD PTR [esi+20]
	imul	eax, DWORD PTR [ebx+20]
	neg	eax
	mov	DWORD PTR [esi+372], eax
	mov	DWORD PTR $T8[esp+256], eax

; 2182 : 
; 2183 :       // get and interplolate old vectors
; 2184 :       int centerX = nBlkSizeX / 2 + (nBlkSizeX - nOverlapX)*workarea.blkx; // center of new block

	mov	eax, DWORD PTR [ebx+8]
	mov	ebx, eax
	sub	ebx, DWORD PTR [ecx+40]
	imul	ebx, DWORD PTR [esi+32]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ebx, eax

; 2185 :       int blkxold = (centerX - nBlkSizeXold / 2) / nStepXold; // centerXold less or equal to new

	mov	eax, ebx
	sub	eax, DWORD PTR tv3649[esp+256]
	cdq
	idiv	DWORD PTR _nStepXold$1$[esp+256]

; 2186 :       int centerY = nBlkSizeY / 2 + (nBlkSizeY - nOverlapY)*workarea.blky;

	mov	edx, DWORD PTR _this$1$[esp+256]
	mov	ecx, eax
	mov	DWORD PTR _blkxold$2[esp+256], ecx

; 2187 :       int blkyold = (centerY - nBlkSizeYold / 2) / nStepYold;
; 2188 : 
; 2189 :       int deltaX = std::max(0, centerX - (nBlkSizeXold / 2 + nStepXold*blkxold)); // distance from old to new

	imul	ecx, DWORD PTR _nStepXold$1$[esp+256]
	mov	eax, DWORD PTR [edx+12]
	mov	edi, eax
	sub	edi, DWORD PTR [edx+44]
	imul	edi, DWORD PTR [esi+36]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	edi, eax
	mov	eax, edi
	sub	eax, DWORD PTR tv3648[esp+256]
	cdq
	idiv	DWORD PTR _nStepYold$1$[esp+256]
	mov	edx, DWORD PTR tv3647[esp+256]
	sub	edx, ecx
	mov	DWORD PTR _blkyold$5[esp+256], eax
	add	edx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	ecx, ecx
	test	edx, edx
	cmovg	ecx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2190 :       int deltaY = std::max(0, centerY - (nBlkSizeYold / 2 + nStepYold*blkyold));

	imul	eax, DWORD PTR _nStepYold$1$[esp+256]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _deltaX$1$[esp+256], ecx
	lea	edx, DWORD PTR $T18[esp+256]
	mov	ecx, DWORD PTR _blkxold$2[esp+256]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2190 :       int deltaY = std::max(0, centerY - (nBlkSizeYold / 2 + nStepYold*blkyold));

	sub	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	eax, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2190 :       int deltaY = std::max(0, centerY - (nBlkSizeYold / 2 + nStepYold*blkyold));

	add	edi, DWORD PTR tv3646[esp+256]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	edi, edi
	cmovg	eax, edi
	test	ecx, ecx
	mov	DWORD PTR _deltaY$1$[esp+256], eax
	lea	eax, DWORD PTR _blkxold$2[esp+256]
	cmovle	eax, edx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR $T19[esp+256]
	mov	edi, edx
	mov	eax, DWORD PTR [eax]
	cmp	eax, edx
	cmovl	edi, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2193 :       int blkxold2 = std::min(nBlkXold - 1, std::max(0, blkxold + 1));

	lea	eax, DWORD PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR _blkxold1$1$[esp+256], edi

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	eax, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2193 :       int blkxold2 = std::min(nBlkXold - 1, std::max(0, blkxold + 1));

	mov	DWORD PTR $T1[esp+256], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	ebx, DWORD PTR $T20[esp+256]
	lea	ecx, DWORD PTR $T1[esp+256]
	cmovle	ecx, ebx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ebx, DWORD PTR _nBlkYold$1$[esp+256]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, edx
	mov	ecx, edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T21[esp+256]

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	ecx, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR _blkyold$5[esp+256]

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR _blkxold2$1$[esp+256], ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR _blkyold$5[esp+256]
	test	ecx, ecx
	cmovle	eax, edx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	dec	ebx
	mov	edx, ebx
	mov	eax, DWORD PTR [eax]
	cmp	eax, ebx
	cmovl	edx, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2195 :       int blkyold2 = std::min(nBlkYold - 1, std::max(0, blkyold + 1));

	lea	eax, DWORD PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	eax, eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2195 :       int blkyold2 = std::min(nBlkYold - 1, std::max(0, blkyold + 1));

	mov	DWORD PTR $T4[esp+256], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T22[esp+256]
	lea	ecx, DWORD PTR $T4[esp+256]
	cmovle	ecx, eax

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx]
	cmp	eax, ebx
	mov	ecx, ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2201 :       if (_smooth == 1) // interpolate

	mov	ebx, DWORD PTR _this$1$[esp+256]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	ecx, eax
	mov	DWORD PTR _blkyold2$1$[esp+256], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2201 :       if (_smooth == 1) // interpolate

	cmp	DWORD PTR [ebx+324], 1
	jne	$LN33@recalculat
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+320]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	imul	edx, DWORD PTR _nBlkXold$1$[esp+256]
	mov	ebx, DWORD PTR _blkxold2$1$[esp+256]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+52]
	lea	eax, DWORD PTR [edi+edx]
	lea	eax, DWORD PTR [eax+eax*4]
	movq	xmm0, QWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [ecx+eax*4+16]
	mov	DWORD PTR _vectorOld1$3$[esp+256], eax
	lea	eax, DWORD PTR [ebx+edx]
	mov	edx, DWORD PTR _blkyold2$1$[esp+256]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	edi, DWORD PTR [ecx+eax*4+16]
	imul	edx, DWORD PTR _nBlkXold$1$[esp+256]
	movq	QWORD PTR _vectorOld1$28[esp+256], xmm0
	movq	xmm0, QWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR _blkxold1$1$[esp+256]
	movq	QWORD PTR _vectorOld2$27[esp+256], xmm0
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*4]
	movq	xmm0, QWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [ecx+eax*4+16]
	mov	DWORD PTR _vectorOld3$3$[esp+256], eax
	lea	eax, DWORD PTR [ebx+edx]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2209 :         int vector1_x = vectorOld1.x*nStepXold + deltaX*(vectorOld2.x - vectorOld1.x); // scaled by nStepXold to skip slow division

	mov	ebx, DWORD PTR _vectorOld2$27[esp+256]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	lea	eax, DWORD PTR [eax+eax*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2209 :         int vector1_x = vectorOld1.x*nStepXold + deltaX*(vectorOld2.x - vectorOld1.x); // scaled by nStepXold to skip slow division

	mov	edx, DWORD PTR _deltaX$1$[esp+256]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR _vectorOld3$30[esp+256], xmm0
	movq	xmm0, QWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR [ecx+eax*4+16]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2210 :         int vector1_y = vectorOld1.y*nStepXold + deltaX*(vectorOld2.y - vectorOld1.y);

	mov	ecx, DWORD PTR _vectorOld1$28[esp+260]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	mov	DWORD PTR _vectorOld4$1$[esp+256], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2209 :         int vector1_x = vectorOld1.x*nStepXold + deltaX*(vectorOld2.x - vectorOld1.x); // scaled by nStepXold to skip slow division

	mov	eax, DWORD PTR _vectorOld1$28[esp+256]
	sub	ebx, eax
	imul	eax, DWORD PTR _nStepXold$1$[esp+256]
	imul	ebx, edx
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR _vectorOld4$29[esp+256], xmm0
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2209 :         int vector1_x = vectorOld1.x*nStepXold + deltaX*(vectorOld2.x - vectorOld1.x); // scaled by nStepXold to skip slow division

	add	ebx, eax

; 2210 :         int vector1_y = vectorOld1.y*nStepXold + deltaX*(vectorOld2.y - vectorOld1.y);

	mov	eax, DWORD PTR _vectorOld2$27[esp+260]
	sub	eax, ecx
	imul	ecx, DWORD PTR _nStepXold$1$[esp+256]
	imul	eax, edx
	add	eax, ecx
	mov	DWORD PTR _vector1_y$1$[esp+256], eax

; 2211 :         cumulated_sad_t vector1_sad = (cumulated_sad_t)vectorOld1.sad*nStepXold + deltaX*((cumulated_sad_t)vectorOld2.sad - vectorOld1.sad);

	mov	eax, edx
	cdq
	mov	DWORD PTR tv3241[esp+256], eax
	mov	eax, edi
	mov	DWORD PTR tv3239[esp+256], edx
	push	DWORD PTR tv3239[esp+256]
	cdq
	push	DWORD PTR tv3241[esp+260]
	mov	edi, eax
	mov	ecx, edx
	mov	eax, DWORD PTR _vectorOld1$3$[esp+264]
	cdq
	sub	edi, eax
	sbb	ecx, edx
	push	ecx
	push	edi
	call	__allmul
	mov	ecx, eax
	mov	edi, edx
	mov	eax, DWORD PTR _vectorOld1$3$[esp+256]
	imul	DWORD PTR _nStepXold$1$[esp+256]
	add	ecx, eax

; 2212 : 
; 2213 :         int vector2_x = vectorOld3.x*nStepXold + deltaX*(vectorOld4.x - vectorOld3.x);

	mov	eax, DWORD PTR _vectorOld4$29[esp+256]
	mov	DWORD PTR _vector1_sad$2$[esp+256], ecx
	mov	ecx, DWORD PTR _vectorOld3$30[esp+256]
	adc	edi, edx
	sub	eax, ecx
	mov	DWORD PTR _vector1_sad$1$[esp+256], edi
	imul	eax, DWORD PTR _deltaX$1$[esp+256]
	imul	ecx, DWORD PTR _nStepXold$1$[esp+256]

; 2214 :         int vector2_y = vectorOld3.y*nStepXold + deltaX*(vectorOld4.y - vectorOld3.y);
; 2215 :         cumulated_sad_t vector2_sad = (cumulated_sad_t)vectorOld3.sad*nStepXold + deltaX*((cumulated_sad_t)vectorOld4.sad - vectorOld3.sad);
; 2216 : 
; 2217 :         vectorOld.x = (vector1_x + deltaY*(vector2_x - vector1_x) / nStepYold) / nStepXold;

	add	eax, ecx
	sub	eax, ebx
	imul	eax, DWORD PTR _deltaY$1$[esp+256]
	cdq
	idiv	DWORD PTR _nStepYold$1$[esp+256]
	add	eax, ebx
	mov	ecx, DWORD PTR _vectorOld3$30[esp+260]
	mov	ebx, DWORD PTR _nStepXold$1$[esp+256]
	cdq
	idiv	ebx
	push	DWORD PTR tv3239[esp+256]
	mov	DWORD PTR _vectorOld$17[esp+260], eax
	mov	eax, DWORD PTR _vectorOld4$29[esp+264]
	sub	eax, ecx
	imul	ecx, ebx
	imul	eax, DWORD PTR _deltaX$1$[esp+260]
	push	DWORD PTR tv3241[esp+260]

; 2218 :         vectorOld.y = (vector1_y + deltaY*(vector2_y - vector1_y) / nStepYold) / nStepXold;

	add	eax, ecx
	sub	eax, DWORD PTR _vector1_y$1$[esp+264]
	imul	eax, DWORD PTR _deltaY$1$[esp+264]
	cdq
	idiv	DWORD PTR _nStepYold$1$[esp+264]
	add	eax, DWORD PTR _vector1_y$1$[esp+264]
	cdq
	idiv	ebx
	mov	DWORD PTR _vectorOld$17[esp+268], eax
	mov	eax, DWORD PTR _vectorOld4$1$[esp+264]
	cdq
	mov	edi, eax
	mov	ecx, edx
	mov	eax, DWORD PTR _vectorOld3$3$[esp+264]
	cdq
	sub	edi, eax
	sbb	ecx, edx
	push	ecx
	push	edi
	call	__allmul
	mov	edi, eax
	mov	ecx, edx
	mov	eax, DWORD PTR _vectorOld3$3$[esp+256]
	imul	ebx

; 2219 :         vectorOld.sad = (sad_t)((vector1_sad + deltaY*(vector2_sad - vector1_sad) / nStepYold) / nStepXold);

	add	edi, eax
	mov	eax, DWORD PTR _deltaY$1$[esp+256]
	adc	ecx, edx
	sub	edi, DWORD PTR _vector1_sad$2$[esp+256]
	cdq
	sbb	ecx, DWORD PTR _vector1_sad$1$[esp+256]
	push	edx
	push	eax
	push	ecx
	push	edi
	call	__allmul
	mov	edi, eax
	mov	ecx, edx
	mov	eax, DWORD PTR _nStepYold$1$[esp+256]
	cdq
	push	edx
	push	eax
	push	ecx
	push	edi
	call	__alldiv
	mov	edi, eax
	mov	ecx, edx
	add	edi, DWORD PTR _vector1_sad$2$[esp+256]
	mov	eax, ebx
	cdq
	adc	ecx, DWORD PTR _vector1_sad$1$[esp+256]
	push	edx
	push	eax
	push	ecx
	push	edi
	call	__alldiv

; 2220 :       }
; 2221 : 
; 2222 :       else // nearest

	mov	ebx, DWORD PTR _this$1$[esp+256]
	jmp	$LN499@recalculat
$LN33@recalculat:

; 2223 :       {
; 2224 :         if (deltaX * 2 < nStepXold && deltaY * 2 < nStepYold)

	mov	eax, DWORD PTR _deltaX$1$[esp+256]
	add	eax, eax
	cmp	eax, DWORD PTR _nStepXold$1$[esp+256]
	mov	eax, DWORD PTR _deltaY$1$[esp+256]
	jge	SHORT $LN498@recalculat
	add	eax, eax
	cmp	eax, DWORD PTR _nStepYold$1$[esp+256]
	jge	SHORT $LN37@recalculat

; 2226 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold1 + blkyold1*nBlkXold).GetMV();

	imul	edx, DWORD PTR _nBlkXold$1$[esp+256]
	add	edx, edi
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	lea	ecx, DWORD PTR [edx+edx*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2226 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold1 + blkyold1*nBlkXold).GetMV();

	jmp	SHORT $LN500@recalculat
$LN498@recalculat:

; 2227 :         }
; 2228 :         else if (deltaX * 2 >= nStepXold && deltaY * 2 < nStepYold)

	add	eax, eax
	cmp	eax, DWORD PTR _nStepYold$1$[esp+256]
	jge	SHORT $LN37@recalculat

; 2230 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold2 + blkyold1*nBlkXold).GetMV();

	imul	edx, DWORD PTR _nBlkXold$1$[esp+256]
	add	edx, DWORD PTR _blkxold2$1$[esp+256]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	lea	ecx, DWORD PTR [edx+edx*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2230 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold2 + blkyold1*nBlkXold).GetMV();

	jmp	SHORT $LN500@recalculat
$LN37@recalculat:

; 2231 :         }
; 2232 :         else if (deltaX * 2 < nStepXold && deltaY * 2 >= nStepYold)

	mov	ebx, DWORD PTR _deltaX$1$[esp+256]
	lea	edx, DWORD PTR [ebx+ebx]
	mov	ebx, DWORD PTR _this$1$[esp+256]
	cmp	edx, DWORD PTR _nStepXold$1$[esp+256]
	jge	SHORT $LN39@recalculat
	cmp	eax, DWORD PTR _nStepYold$1$[esp+256]
	jl	SHORT $LN39@recalculat

; 2233 :         {
; 2234 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold1 + blkyold2*nBlkXold).GetMV();

	imul	ecx, DWORD PTR _nBlkXold$1$[esp+256]
	add	ecx, edi

; 2235 :         }
; 2236 :         else //(deltaX*2>=nStepXold && deltaY*2>=nStepYold )

	jmp	SHORT $LN501@recalculat
$LN39@recalculat:

; 2238 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold2 + blkyold2*nBlkXold).GetMV();

	imul	ecx, DWORD PTR _nBlkXold$1$[esp+256]
	add	ecx, DWORD PTR _blkxold2$1$[esp+256]
$LN501@recalculat:
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	lea	ecx, DWORD PTR [ecx+ecx*4]
$LN500@recalculat:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+320]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2238 :           vectorOld = _mv_clip_ptr->GetBlock(0, blkxold2 + blkyold2*nBlkXold).GetMV();

	movq	xmm0, QWORD PTR [eax+ecx*4+8]
	mov	eax, DWORD PTR [eax+ecx*4+16]
	movq	QWORD PTR _vectorOld$17[esp+256], xmm0
$LN499@recalculat:

; 2239 :         }
; 2240 :       }
; 2241 : 
; 2242 :       // scale vector to new nPel
; 2243 :       vectorOld.x = (vectorOld.x << nLogPel) >> nLogPelold;

	mov	edx, DWORD PTR _vectorOld$17[esp+256]
	mov	ecx, DWORD PTR [ebx+24]

; 2244 :       vectorOld.y = (vectorOld.y << nLogPel) >> nLogPelold;

	mov	edi, DWORD PTR _vectorOld$17[esp+260]
	shl	edx, cl
	mov	ecx, DWORD PTR _result$1$[esp+256]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebx+24]
	shl	edi, cl
	mov	ecx, DWORD PTR _result$1$[esp+256]
	mov	DWORD PTR $T3[esp+256], eax

; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;

	mov	eax, DWORD PTR [esi+368]

; 2244 :       vectorOld.y = (vectorOld.y << nLogPel) >> nLogPelold;

	sar	edi, cl

; 1756 :   if (vx < workarea.nDxMin) return workarea.nDxMin;

	cmp	edx, eax
	jl	SHORT $LN284@recalculat

; 1757 :   else if (vx >= workarea.nDxMax) return workarea.nDxMax - 1;

	mov	eax, DWORD PTR [esi+376]
	cmp	edx, eax
	jl	SHORT $LN283@recalculat
	dec	eax
	jmp	SHORT $LN284@recalculat
$LN283@recalculat:

; 1758 :   else return vx;

	mov	eax, edx
$LN284@recalculat:

; 1774 :   v2.x = ClipMVx(workarea, v.x);

	mov	DWORD PTR $T16[esp+256], eax

; 1765 :   if (vy < workarea.nDyMin) return workarea.nDyMin;

	mov	eax, DWORD PTR $T8[esp+256]
	cmp	edi, eax
	jl	SHORT $LN290@recalculat

; 1766 :   else if (vy >= workarea.nDyMax) return workarea.nDyMax - 1;

	mov	eax, DWORD PTR [esi+380]
	cmp	edi, eax
	jl	SHORT $LN289@recalculat
	dec	eax
	jmp	SHORT $LN290@recalculat
$LN289@recalculat:

; 1767 :   else return vy;

	mov	eax, edi
$LN290@recalculat:

; 2245 : 
; 2246 :       workarea.predictor = ClipMV(workarea, vectorOld); // predictor

	mov	ecx, DWORD PTR $T3[esp+256]

; 2247 :       workarea.predictor.sad = (sad_t)((cumulated_sad_t)vectorOld.sad * (nBlkSizeX*nBlkSizeY) / (nBlkSizeXold*nBlkSizeYold)); // normalized to new block size

	push	DWORD PTR tv3331[esp+256]

; 1775 :   v2.y = ClipMVy(workarea, v.y);

	mov	DWORD PTR $T16[esp+264], eax

; 2245 : 
; 2246 :       workarea.predictor = ClipMV(workarea, vectorOld); // predictor

	movq	xmm0, QWORD PTR $T16[esp+260]

; 2247 :       workarea.predictor.sad = (sad_t)((cumulated_sad_t)vectorOld.sad * (nBlkSizeX*nBlkSizeY) / (nBlkSizeXold*nBlkSizeYold)); // normalized to new block size

	push	DWORD PTR tv3333[esp+260]
	movq	QWORD PTR [esi+116], xmm0
	mov	DWORD PTR [esi+124], ecx
	mov	eax, DWORD PTR [ebx+8]
	imul	eax, DWORD PTR [ebx+12]
	imul	ecx
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR [esi+124], eax

; 2248 : 
; 2249 : //			workarea.bestMV = workarea.predictor; // by pointer?
; 2250 :       workarea.bestMV.x = workarea.predictor.x;

	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR [esi+100], eax

; 2251 :       workarea.bestMV.y = workarea.predictor.y;

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+104], eax

; 2252 :       workarea.bestMV.sad = workarea.predictor.sad;

	mov	eax, DWORD PTR [esi+124]
	mov	DWORD PTR [esi+108], eax

; 2253 : 
; 2254 :       // update SAD
; 2255 : #ifdef ALLOW_DCT
; 2256 :       if (dctmode != 0) // DCT method (luma only - currently use normal spatial SAD chroma)

	mov	eax, DWORD PTR [ebx+216]
	test	eax, eax
	je	SHORT $LN42@recalculat

; 2257 :       {
; 2258 :         // make dct of source block
; 2259 :         if (dctmode <= 4) //don't do the slow dct conversion if SATD used

	cmp	eax, 4
	jg	SHORT $LN42@recalculat

; 2260 :         {
; 2261 :           workarea.DCT->DCTBytes2D(workarea.pSrc[0], nSrcPitch[0], &workarea.dctSrc[0], dctpitch);

	push	DWORD PTR [ebx+124]
	mov	ecx, DWORD PTR [esi+48]
	push	DWORD PTR [esi+404]
	push	DWORD PTR [ebx+168]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [esi+88]
	call	DWORD PTR [eax]
$LN42@recalculat:

; 2262 :         }
; 2263 :       }
; 2264 :       if (dctmode >= 3) // most use it and it should be fast anyway //if (dctmode == 3 || dctmode == 4) // check it

	cmp	DWORD PTR [ebx+216], 3
	jl	SHORT $LN43@recalculat

; 2265 :       {
; 2266 :         workarea.srcLuma = LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [ebx+168]
	mov	eax, DWORD PTR [ebx+84]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 8
	mov	DWORD PTR [esi+392], eax
$LN43@recalculat:

; 2270 :       sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	cmp	BYTE PTR [ebx+122], 0
	je	$LN64@recalculat

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]

; 2270 :       sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	mov	ecx, DWORD PTR [esi+120]
	mov	edi, DWORD PTR [esi+116]
	mov	DWORD PTR _nVy$1$[esp+256], ecx
	mov	DWORD PTR _nVx$1$[esp+256], edi

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	cmp	eax, 2
	jne	SHORT $LN307@recalculat
	mov	eax, DWORD PTR [ebx+164]
	mov	edx, ecx
	mov	DWORD PTR _this$1$[esp+256], eax
	mov	eax, DWORD PTR [ebx+60]
	mov	ecx, eax
	sar	edx, cl
	mov	ecx, DWORD PTR _this$1$[esp+256]
	mov	DWORD PTR tv3699[esp+256], eax
	mov	eax, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [ecx+52]
	mov	ecx, eax
	mov	DWORD PTR tv3689[esp+256], eax
	mov	eax, DWORD PTR [esi+12]
	mov	edx, edi
	sar	edx, cl
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	add	edx, edx

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN502@recalculat
$LN307@recalculat:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR _this$1$[esp+256], eax
	jne	SHORT $LN305@recalculat
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+60]
	mov	ecx, DWORD PTR [ebx+52]
	mov	DWORD PTR tv3699[esp+256], eax
	mov	eax, edi
	sar	eax, cl
	add	eax, DWORD PTR [esi+12]
	mov	DWORD PTR tv3689[esp+256], ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebx+60]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	DWORD PTR tv3728[esp+256], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR _nVy$1$[esp+256]
	sar	eax, cl
	add	eax, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR tv3728[esp+256]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN503@recalculat
$LN305@recalculat:
	mov	eax, DWORD PTR [ebx+60]
	mov	edx, ecx
	mov	ecx, eax
	mov	DWORD PTR tv3699[esp+256], eax
	mov	eax, DWORD PTR [esi+24]
	sar	edx, cl
	mov	ecx, DWORD PTR _this$1$[esp+256]
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	edx, edi
	mov	eax, DWORD PTR [ecx+52]
	mov	ecx, eax
	sar	edx, cl
	mov	DWORD PTR tv3689[esp+256], eax
	mov	eax, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	shl	edx, 2
	and	eax, 3

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN502@recalculat:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR _this$1$[esp+256]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$1$[esp+256]
	add	ecx, edi
	mov	edi, DWORD PTR _nVx$1$[esp+256]
	mov	eax, DWORD PTR [edx+4]
	imul	ebx, DWORD PTR [eax+12]
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+256]
$LN503@recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [ebx+20]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	DWORD PTR tv3728[esp+256], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	cmp	eax, 2
	jne	SHORT $LN334@recalculat
	mov	ecx, DWORD PTR tv3699[esp+256]
	mov	edx, DWORD PTR _nVy$1$[esp+256]
	mov	eax, DWORD PTR [esi+28]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3689[esp+256]
	sar	edi, cl
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edi+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1
	or	edx, eax

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR _this$1$[esp+256]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$1$[esp+256]
	add	eax, edi
	mov	DWORD PTR _nVx$1$[esp+256], eax
	mov	edi, DWORD PTR _nVx$1$[esp+256]
	mov	eax, DWORD PTR [edx+8]
	imul	ebx, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN504@recalculat
$LN334@recalculat:
	cmp	eax, 1
	jne	SHORT $LN332@recalculat
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [edx+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR tv3689[esp+256]
	mov	edx, DWORD PTR _nVy$1$[esp+256]
	sar	edi, cl
	add	edi, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	shl	edi, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [ebx+60]
	sar	edx, cl
	add	edx, DWORD PTR [esi+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax]
	add	edi, edx
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN333@recalculat
$LN332@recalculat:
	mov	ecx, DWORD PTR tv3699[esp+256]
	mov	edx, DWORD PTR _nVy$1$[esp+256]
	mov	eax, DWORD PTR [esi+28]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3689[esp+256]
	sar	edi, cl
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [esi+16]
	mov	edx, ebx
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edi+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3
	or	edx, eax

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR _this$1$[esp+256]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	edi, eax
	mov	edx, DWORD PTR _this$1$[esp+256]
	mov	ecx, DWORD PTR [edx+8]
	imul	ebx, DWORD PTR [ecx+12]
$LN504@recalculat:
	add	edi, ebx
	mov	ebx, DWORD PTR _this$1$[esp+256]
$LN333@recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2270 :       sad_t saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	push	DWORD PTR [ebx+188]
	mov	eax, DWORD PTR [ebx+100]
	push	edi
	push	DWORD PTR [ebx+176]
	push	DWORD PTR [esi+96]
	call	eax
	push	DWORD PTR [ebx+184]
	mov	ecx, DWORD PTR [ebx+100]
	mov	edi, eax
	push	DWORD PTR tv3728[esp+276]
	push	DWORD PTR [ebx+172]
	push	DWORD PTR [esi+92]
	call	ecx
	add	esp, 32					; 00000020H
	add	edi, eax
	mov	DWORD PTR _saduv$1$[esp+256], edi
	jmp	SHORT $LN65@recalculat
$LN64@recalculat:
	mov	DWORD PTR _saduv$1$[esp+256], 0
$LN65@recalculat:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebx+20]

; 2271 :         + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[2]) : 0;
; 2272 :       sad_t sad = LumaSAD(workarea, GetRefBlock(workarea, workarea.predictor.x, workarea.predictor.y));

	mov	edi, DWORD PTR [esi+120]
	mov	edx, DWORD PTR [esi+116]

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	cmp	eax, 2
	jne	SHORT $LN361@recalculat
	mov	eax, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	add	edx, edx

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN505@recalculat
$LN361@recalculat:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
	jne	SHORT $LN359@recalculat
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	add	eax, DWORD PTR [esi+116]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T6[esp+256], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T6[esp+256]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, edi
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN360@recalculat
$LN359@recalculat:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	shl	edx, 2
	and	eax, 3

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN505@recalculat:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	DWORD PTR $T7[esp+256], ecx
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR $T7[esp+256]
	add	ecx, edi
	imul	ebx, DWORD PTR [eax+12]
	add	ecx, ebx
	mov	ebx, DWORD PTR _this$1$[esp+256]
$LN360@recalculat:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [ebx+216], 0
	jne	SHORT $LN386@recalculat
	push	DWORD PTR [ebx+180]
	mov	eax, DWORD PTR [ebx+80]
	push	ecx
	push	DWORD PTR [ebx+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN387@recalculat
$LN386@recalculat:
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN387@recalculat:

; 2273 :       sad += saduv;

	add	eax, DWORD PTR _saduv$1$[esp+256]

; 2274 :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], eax

; 2275 :       workarea.nMinCost = sad;

	mov	DWORD PTR [esi+112], eax

; 2276 : 
; 2277 :       if (workarea.bestMV.sad > _thSAD)// if old interpolated vector is bad

	cmp	eax, DWORD PTR [ebx+328]
	jle	$LN21@recalculat

; 2278 :       {
; 2279 :         //				CheckMV(vectorOld1.x, vectorOld1.y);
; 2280 :         //				CheckMV(vectorOld2.x, vectorOld2.y);
; 2281 :         //				CheckMV(vectorOld3.x, vectorOld3.y);
; 2282 :         //				CheckMV(vectorOld4.x, vectorOld4.y);
; 2283 :                 // then, we refine, according to the search type
; 2284 :         if (searchType & ONETIME)

	test	BYTE PTR [ebx+224], 1
	je	SHORT $LN9@recalculat

; 2285 :         {
; 2286 :           for (int i = nSearchParam; i > 0; i /= 2)

	mov	edi, DWORD PTR [ebx+228]
	test	edi, edi
	jle	SHORT $LN9@recalculat
$LL10@recalculat:

; 2287 :           {
; 2288 :             OneTimeSearch(workarea, i);

	push	edi
	push	esi
	mov	ecx, ebx
	call	?OneTimeSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::OneTimeSearch
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	test	edi, edi
	jg	SHORT $LL10@recalculat
$LN9@recalculat:

; 2289 :           }
; 2290 :         }
; 2291 : 
; 2292 :         if (searchType & NSTEP)

	test	BYTE PTR [ebx+224], 2
	je	SHORT $LN46@recalculat

; 2293 :         {
; 2294 :           NStepSearch(workarea, nSearchParam);

	push	DWORD PTR [ebx+228]
	mov	ecx, ebx
	push	esi
	call	?NStepSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::NStepSearch
$LN46@recalculat:

; 2295 :         }
; 2296 : 
; 2297 :         if (searchType & LOGARITHMIC)

	test	BYTE PTR [ebx+224], 4
	je	SHORT $LN12@recalculat

; 2298 :         {
; 2299 :           for (int i = nSearchParam; i > 0; i /= 2)

	mov	edi, DWORD PTR [ebx+228]
	test	edi, edi
	jle	SHORT $LN12@recalculat
$LL13@recalculat:

; 2300 :           {
; 2301 :             DiamondSearch(workarea, i);

	push	edi
	push	esi
	mov	ecx, ebx
	call	?DiamondSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::DiamondSearch
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	test	edi, edi
	jg	SHORT $LL13@recalculat
$LN12@recalculat:

; 2302 :           }
; 2303 :         }
; 2304 : 
; 2305 :         if (searchType & EXHAUSTIVE)

	test	BYTE PTR [ebx+224], 8
	je	SHORT $LN15@recalculat

; 2306 :         {
; 2307 :           //       ExhaustiveSearch(nSearchParam);
; 2308 :           int mvx = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]

; 2309 :           int mvy = workarea.bestMV.y;
; 2310 :           for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	edi, 1
	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR _mvx$1$[esp+256], eax
	mov	DWORD PTR _mvy$1$[esp+256], ecx
	cmp	DWORD PTR [ebx+228], edi
	jl	SHORT $LN15@recalculat
$LL16@recalculat:

; 2311 :           {
; 2312 :             ExpandingSearch(workarea, i, 1, mvx, mvy);

	push	ecx
	push	eax
	push	1
	push	edi
	push	esi
	mov	ecx, ebx
	call	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch
	mov	eax, DWORD PTR _mvx$1$[esp+256]
	inc	edi
	mov	ecx, DWORD PTR _mvy$1$[esp+256]
	cmp	edi, DWORD PTR [ebx+228]
	jle	SHORT $LL16@recalculat
$LN15@recalculat:

; 2313 :           }
; 2314 :         }
; 2315 : 
; 2316 :         if (searchType & HEX2SEARCH)

	test	BYTE PTR [ebx+224], 16			; 00000010H
	je	SHORT $LN49@recalculat

; 2317 :         {
; 2318 :           Hex2Search(workarea, nSearchParam);

	push	DWORD PTR [ebx+228]
	mov	ecx, ebx
	push	esi
	call	?Hex2Search@PlaneOfBlocks@@AAEXAAVWorkingArea@1@H@Z ; PlaneOfBlocks::Hex2Search
$LN49@recalculat:

; 2319 :         }
; 2320 : 
; 2321 :         if (searchType & UMHSEARCH)

	test	BYTE PTR [ebx+224], 32			; 00000020H
	je	SHORT $LN50@recalculat

; 2322 :         {
; 2323 :           UMHSearch(workarea, nSearchParam, workarea.bestMV.x, workarea.bestMV.y);

	push	DWORD PTR [esi+104]
	mov	ecx, ebx
	push	DWORD PTR [esi+100]
	push	DWORD PTR [ebx+228]
	push	esi
	call	?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z ; PlaneOfBlocks::UMHSearch
$LN50@recalculat:

; 2324 :         }
; 2325 : 
; 2326 :         if (searchType & HSEARCH)

	test	BYTE PTR [ebx+224], 64			; 00000040H
	je	SHORT $LN18@recalculat

; 2327 :         {
; 2328 :           int mvx = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]

; 2329 :           int mvy = workarea.bestMV.y;
; 2330 :           for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	edi, 1
	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR _mvx$1$[esp+256], eax
	mov	DWORD PTR _mvy$1$[esp+256], ecx
	cmp	DWORD PTR [ebx+228], edi
	jl	SHORT $LN18@recalculat

; 2327 :         {
; 2328 :           int mvx = workarea.bestMV.x;

	dec	eax
	mov	DWORD PTR tv3573[esp+256], eax
	npad	3
$LL19@recalculat:

; 2331 :           {
; 2332 :             CheckMV(workarea, mvx - i, mvy);

	push	ecx
	push	eax
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 2333 :             CheckMV(workarea, mvx + i, mvy);

	push	DWORD PTR _mvy$1$[esp+256]
	mov	eax, DWORD PTR _mvx$1$[esp+260]
	mov	ecx, ebx
	add	eax, edi
	push	eax
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	mov	eax, DWORD PTR tv3573[esp+256]
	inc	edi
	mov	ecx, DWORD PTR _mvy$1$[esp+256]
	dec	eax
	mov	DWORD PTR tv3573[esp+256], eax
	cmp	edi, DWORD PTR [ebx+228]
	jle	SHORT $LL19@recalculat
$LN18@recalculat:

; 2334 :           }
; 2335 :         }
; 2336 : 
; 2337 :         if (searchType & VSEARCH)

	test	BYTE PTR [ebx+224], 128			; 00000080H
	je	SHORT $LN21@recalculat

; 2338 :         {
; 2339 :           int mvx = workarea.bestMV.x;

	mov	ecx, DWORD PTR [esi+100]

; 2340 :           int mvy = workarea.bestMV.y;
; 2341 :           for (int i = 1; i <= nSearchParam; i++)// region is same as exhaustive, but ordered by radius (from near to far)

	mov	edi, 1
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR _mvx$1$[esp+256], ecx
	mov	DWORD PTR _mvy$1$[esp+256], eax
	cmp	DWORD PTR [ebx+228], edi
	jl	SHORT $LN21@recalculat

; 2338 :         {
; 2339 :           int mvx = workarea.bestMV.x;

	dec	eax
	mov	DWORD PTR tv3571[esp+256], eax
	npad	4
$LL22@recalculat:

; 2342 :           {
; 2343 :             CheckMV(workarea, mvx, mvy - i);

	push	eax
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV

; 2344 :             CheckMV(workarea, mvx, mvy + i);

	mov	eax, DWORD PTR _mvy$1$[esp+256]
	mov	ecx, ebx
	add	eax, edi
	push	eax
	push	DWORD PTR _mvx$1$[esp+260]
	push	esi
	call	?CheckMV@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV
	mov	eax, DWORD PTR tv3571[esp+256]
	inc	edi
	mov	ecx, DWORD PTR _mvx$1$[esp+256]
	dec	eax
	mov	DWORD PTR tv3571[esp+256], eax
	cmp	edi, DWORD PTR [ebx+228]
	jle	SHORT $LL22@recalculat
$LN21@recalculat:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2350 :       vectors[workarea.blkIdx].x = workarea.bestMV.x;

	mov	ecx, DWORD PTR [ebx+108]

; 2353 : 
; 2354 :       if (outfilebuf != NULL) // write vector to outfile

	mov	edi, DWORD PTR _outfilebuf$1$[esp+256]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2350 :       vectors[workarea.blkIdx].x = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [ecx+edx*4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2351 :       vectors[workarea.blkIdx].y = workarea.bestMV.y;

	mov	ecx, DWORD PTR [ebx+108]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2351 :       vectors[workarea.blkIdx].y = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [ecx+edx*4+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2352 :       vectors[workarea.blkIdx].sad = workarea.bestMV.sad;

	mov	ecx, DWORD PTR [ebx+108]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2352 :       vectors[workarea.blkIdx].sad = workarea.bestMV.sad;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [ecx+edx*4+8], eax

; 2353 : 
; 2354 :       if (outfilebuf != NULL) // write vector to outfile

	test	edi, edi
	je	SHORT $LN53@recalculat

; 2355 :       {
; 2356 :         outfilebuf[workarea.blkx * 4 + 0] = workarea.bestMV.x;

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+100]
	mov	WORD PTR [edi+ecx*8], ax

; 2357 :         outfilebuf[workarea.blkx * 4 + 1] = workarea.bestMV.y;

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+104]
	mov	WORD PTR [edi+ecx*8+2], ax

; 2358 :         // todo: SAD as int when it is float
; 2359 :         outfilebuf[workarea.blkx * 4 + 2] = (workarea.bestMV.sad & 0x0000ffff); // low word

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+108]
	mov	WORD PTR [edi+ecx*8+4], ax

; 2360 :         outfilebuf[workarea.blkx * 4 + 3] = (workarea.bestMV.sad >> 16);     // high word, usually null

	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, WORD PTR [esi+110]
	mov	WORD PTR [edi+ecx*8+6], ax
$LN53@recalculat:

; 2361 :       }
; 2362 : 
; 2363 :       /* write the results */
; 2364 :       pBlkData[workarea.blkx*N_PER_BLOCK + 0] = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR _pBlkData$1$[esp+256]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [edx+ecx*4], eax

; 2365 :       pBlkData[workarea.blkx*N_PER_BLOCK + 1] = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 2366 :       pBlkData[workarea.blkx*N_PER_BLOCK + 2] = workarea.bestMV.sad;

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 2367 : 
; 2368 : 
; 2369 :       PROFILE_STOP(MOTION_PROFILE_ME);
; 2370 : 
; 2371 :       if (smallestPlane)

	cmp	BYTE PTR [ebx+120], 0
	je	$LN54@recalculat

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [esi+8]
	cmp	eax, 2
	jne	SHORT $LN425@recalculat
	mov	eax, DWORD PTR [ebx+164]
	add	edi, edi
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	edi, 1
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	add	eax, eax
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	eax, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN506@recalculat
$LN425@recalculat:
	cmp	eax, 1
	mov	eax, DWORD PTR [ebx+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jne	SHORT $LN423@recalculat
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN507@recalculat
$LN423@recalculat:
	mov	eax, DWORD PTR [esi+20]
	shl	edi, 2
	shl	eax, 2
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	eax, 2
$LN506@recalculat:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
$LN507@recalculat:
	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2375 :         workarea.sumLumaChange += (cumulated_sad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (cumulated_sad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [ebx+168]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	edi, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2375 :         workarea.sumLumaChange += (cumulated_sad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (cumulated_sad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [esi+88]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2375 :         workarea.sumLumaChange += (cumulated_sad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (cumulated_sad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	mov	eax, DWORD PTR [ebx+84]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	DWORD PTR tv3726[esp+264], edi
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2375 :         workarea.sumLumaChange += (cumulated_sad_t)LUMA(GetRefBlock(workarea, 0, 0), nRefPitch[0]) - (cumulated_sad_t)LUMA(workarea.pSrc[0], nSrcPitch[0]);

	call	eax
	mov	ebx, DWORD PTR [esi+72]
	mov	edi, DWORD PTR [esi+76]
	sub	ebx, eax
	mov	eax, DWORD PTR _this$1$[esp+264]
	sbb	edi, 0
	push	DWORD PTR [eax+180]
	mov	eax, DWORD PTR [eax+84]
	push	DWORD PTR tv3726[esp+268]
	call	eax
	add	esp, 16					; 00000010H
	xor	ecx, ecx
	add	eax, ebx
	mov	ebx, DWORD PTR _this$1$[esp+256]
	mov	DWORD PTR [esi+72], eax
	adc	ecx, edi
	mov	edi, DWORD PTR _outfilebuf$1$[esp+256]
	mov	DWORD PTR [esi+76], ecx
$LN54@recalculat:

; 2376 :       }
; 2377 : 
; 2378 :       if (iblkx < nBlkX - 1)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _iblkx$1$[esp+256]
	dec	eax
	cmp	ecx, eax
	jge	SHORT $LN5@recalculat

; 2379 :       {
; 2380 :         workarea.x[0] += nBlkSizeX_Ovr[0]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$1$[esp+256]
	add	DWORD PTR [esi+8], eax

; 2381 :         workarea.x[1] += nBlkSizeX_Ovr[1]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$3$[esp+256]
	add	DWORD PTR [esi+12], eax

; 2382 :         workarea.x[2] += nBlkSizeX_Ovr[2]*workarea.blkScanDir;

	mov	eax, DWORD PTR [esi+44]
	imul	eax, DWORD PTR _nBlkSizeX_Ovr$3$[esp+256]
	add	DWORD PTR [esi+16], eax
$LN5@recalculat:

; 2129 :       }
; 2130 :     }
; 2131 : 
; 2132 :     for (int iblkx = 0; iblkx < nBlkX; iblkx++)

	inc	ecx
	mov	DWORD PTR _iblkx$1$[esp+256], ecx
	cmp	ecx, DWORD PTR [ebx]
	jl	$LL7@recalculat
	mov	edx, DWORD PTR _pBlkData$1$[esp+256]
$LN6@recalculat:

; 2383 :       }
; 2384 :     }	// for workarea.blkx
; 2385 : 
; 2386 :     pBlkData += nBlkX*N_PER_BLOCK;

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pBlkData$1$[esp+256], edx

; 2387 :     if (outfilebuf != NULL) // write vector to outfile

	test	edi, edi
	je	SHORT $LN56@recalculat

; 2388 :     {
; 2389 :       outfilebuf += nBlkX * 4;// 4 short word per block

	lea	edi, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR _outfilebuf$1$[esp+256], edi
$LN56@recalculat:

; 2390 :     }
; 2391 : 
; 2392 :     workarea.y[0] += nBlkSizeY_Ovr[0];

	mov	eax, DWORD PTR _nBlkSizeY_Ovr$1$[esp+256]
	add	DWORD PTR [esi+20], eax

; 2393 :     workarea.y[1] += nBlkSizeY_Ovr[1];

	mov	eax, DWORD PTR _nBlkSizeY_Ovr$3$[esp+256]
	add	DWORD PTR [esi+24], eax

; 2394 :     workarea.y[2] += nBlkSizeY_Ovr[2];

	add	DWORD PTR [esi+28], eax
	inc	DWORD PTR [esi+36]
	mov	eax, DWORD PTR [esi+36]
	cmp	eax, DWORD PTR [esi+84]
	jl	$LL4@recalculat
$LN3@recalculat:
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+64]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2397 :   planeSAD += workarea.planeSAD;

	lea	ecx, DWORD PTR [ebx+264]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	DWORD PTR _ftor$15[esp+264], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	edx, DWORD PTR _ftor$15[esp+256]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR _ftor$15[esp+268], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	eax, DWORD PTR _val_new$26[esp+256]
	push	eax
	lea	eax, DWORD PTR _val_old$24[esp+260]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _ftor$15[esp+260], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	push	eax
	call	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+72]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2398 :   sumLumaChange += workarea.sumLumaChange;

	lea	ecx, DWORD PTR [ebx+272]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	DWORD PTR _ftor$14[esp+272], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	edx, DWORD PTR _ftor$14[esp+264]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR _ftor$14[esp+276], eax
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	eax, DWORD PTR _val_new$25[esp+264]
	push	eax
	lea	eax, DWORD PTR _val_old$23[esp+268]
; File c:\github\mvtools\sources\conc\aioadd.h

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR _ftor$15[esp+268], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	push	eax
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _ftor$14[esp+272], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 46   : 	exec_both (atom, ftor, val_old, val_new);

	call	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
	add	esp, 16					; 00000010H
; File c:\github\mvtools\sources\conc\aioadd.h

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR _ftor$14[esp+256], OFFSET ??_7?$AioAdd@_J@conc@@6B@
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2400 :   if (isse)

	cmp	BYTE PTR [ebx+121], 0
	je	SHORT $LN57@recalculat

; 2401 :   {
; 2402 : #ifndef _M_X64
; 2403 :     _mm_empty();

	emms
$LN57@recalculat:

; 2404 : #endif
; 2405 :   }
; 2406 : 
; 2407 : #ifdef ALLOW_DCT
; 2408 :   if (_dct_pool_ptr != 0)

	mov	ecx, DWORD PTR [ebx+128]
	test	ecx, ecx
	je	SHORT $LN58@recalculat

; 2409 :   {
; 2410 :     _dct_pool_ptr->return_obj(*(workarea.DCT));

	push	DWORD PTR [esi+48]
	call	?return_obj@?$ObjPool@VDCTClass@@@conc@@QAEXAAVDCTClass@@@Z ; conc::ObjPool<DCTClass>::return_obj

; 2411 :     workarea.DCT = 0;

	mov	DWORD PTR [esi+48], 0
$LN58@recalculat:

; 2412 :   }
; 2413 : #endif
; 2414 : 
; 2415 :   _workarea_pool.return_obj(workarea);

	push	esi
	lea	ecx, DWORD PTR [ebx+376]
	call	?return_obj@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAVWorkingArea@PlaneOfBlocks@@@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::return_obj

; 2416 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$recalculate_mv_slice@G@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ENDP ; PlaneOfBlocks::recalculate_mv_slice<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiosub.hpp
;	COMDAT ??0?$AioSub@H@conc@@QAE@H@Z
_TEXT	SEGMENT
_operand$dead$ = 8					; size = 4
??0?$AioSub@H@conc@@QAE@H@Z PROC			; conc::AioSub<int>::AioSub<int>, COMDAT
; _this$ = ecx

; 39   : {

	mov	DWORD PTR [ecx], OFFSET ??_7?$AioSub@H@conc@@6B@

; 40   : 	// Nothing
; 41   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 1
	ret	4
??0?$AioSub@H@conc@@QAE@H@Z ENDP			; conc::AioSub<int>::AioSub<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_new@HV?$AioSub@H@conc@@@AtomicIntOp@conc@@SAHAAV?$AtomicInt@H@1@AAV?$AioSub@H@1@@Z
_TEXT	SEGMENT
??$exec_new@HV?$AioSub@H@conc@@@AtomicIntOp@conc@@SAHAAV?$AtomicInt@H@1@AAV?$AioSub@H@1@@Z PROC ; conc::AtomicIntOp::exec_new<int,conc::AioSub<int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 68   : {

	push	ebx
	push	esi
	mov	ebx, edx
	mov	edx, ecx
	push	edi
$LL6@exec_new:

; 90   : 		val_cur = atom;

	mov	edi, DWORD PTR [edx]
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	mov	esi, edi
	sub	esi, DWORD PTR [ebx+4]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edi
	mov	ecx, esi
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edi
	jne	SHORT $LL6@exec_new

; 69   : 	assert (&atom != 0);
; 70   : 	assert (&ftor != 0);
; 71   : 
; 72   : 	T					val_new;
; 73   : 	T					val_old;
; 74   : 	exec_both (atom, ftor, val_old, val_new);
; 75   : 
; 76   : 	return (val_new);

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 77   : }

	ret	0
??$exec_new@HV?$AioSub@H@conc@@@AtomicIntOp@conc@@SAHAAV?$AtomicInt@H@1@AAV?$AioSub@H@1@@Z ENDP ; conc::AtomicIntOp::exec_new<int,conc::AioSub<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??$PseudoEPZSearch@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z
_TEXT	SEGMENT
_mvy$1$ = -168						; size = 4
_foundSAD$1$ = -168					; size = 4
tv3312 = -168						; size = 4
tv3269 = -168						; size = 4
tv3262 = -168						; size = 4
tv3253 = -168						; size = 4
_saduv$3$ = -168					; size = 4
_saduv$2$ = -168					; size = 4
_saduv$1$ = -168					; size = 4
_this$1$ = -164						; size = 4
$T1 = -160						; size = 4
$T2 = -160						; size = 4
_npred$1$ = -160					; size = 4
tv3279 = -160						; size = 4
tv3276 = -160						; size = 4
_nVx$1$ = -156						; size = 4
_this$1$ = -156						; size = 4
_this$1$ = -152						; size = 4
tv3277 = -152						; size = 4
tv3314 = -148						; size = 4
tv3278 = -148						; size = 4
tv3317 = -141						; size = 1
_nMinCostMany$ = -140					; size = 32
$T3 = -108						; size = 12
_bestMVMany$ = -96					; size = 96
_workarea$ = 8						; size = 4
??$PseudoEPZSearch@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z PROC ; PlaneOfBlocks::PseudoEPZSearch<unsigned char>, COMDAT
; _this$ = ecx

; 750  : {

	sub	esp, 168				; 000000a8H
	push	ebx
	push	ebp
	push	esi

; 751  :   typedef typename std::conditional < sizeof(pixel_t) == 1, sad_t, bigsad_t >::type safe_sad_t;
; 752  :   FetchPredictors<pixel_t>(workarea);

	mov	esi, DWORD PTR _workarea$[esp+176]
	push	edi
	mov	edi, ecx
	push	esi
	mov	DWORD PTR _this$1$[esp+188], edi
	call	??$FetchPredictors@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ; PlaneOfBlocks::FetchPredictors<unsigned char>

; 753  : 
; 754  :   sad_t sad;
; 755  :   sad_t saduv;
; 756  : #ifdef ALLOW_DCT
; 757  :   if (dctmode != 0) // DCT method (luma only - currently use normal spatial SAD chroma)

	mov	eax, DWORD PTR [edi+216]
	test	eax, eax
	je	SHORT $LN15@PseudoEPZS

; 758  :   {
; 759  :     // make dct of source block
; 760  :     if (dctmode <= 4) //don't do the slow dct conversion if SATD used

	cmp	eax, 4
	jg	SHORT $LN15@PseudoEPZS

; 761  :     {
; 762  :       workarea.DCT->DCTBytes2D(workarea.pSrc[0], nSrcPitch[0], &workarea.dctSrc[0], dctpitch);

	push	DWORD PTR [edi+124]
	mov	ecx, DWORD PTR [esi+48]
	push	DWORD PTR [esi+404]
	push	DWORD PTR [edi+168]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [esi+88]
	call	DWORD PTR [eax]
$LN15@PseudoEPZS:

; 763  :     }
; 764  :   }
; 765  :   if (dctmode >= 3) // most use it and it should be fast anyway //if (dctmode == 3 || dctmode == 4) // check it

	cmp	DWORD PTR [edi+216], 3
	jl	SHORT $LN16@PseudoEPZS

; 766  :   {
; 767  :     workarea.srcLuma = LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [edi+168]
	mov	eax, DWORD PTR [edi+84]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 8
	mov	DWORD PTR [esi+392], eax
$LN16@PseudoEPZS:

; 768  :   }
; 769  : #endif	// ALLOW_DCT
; 770  : 
; 771  :   // We treat zero alone
; 772  :   // Do we bias zero with not taking into account distorsion ?
; 773  :   workarea.bestMV.x = zeroMVfieldShifted.x;

	mov	eax, DWORD PTR [edi+204]
	mov	DWORD PTR [esi+100], eax

; 774  :   workarea.bestMV.y = zeroMVfieldShifted.y;

	mov	eax, DWORD PTR [edi+208]
	mov	DWORD PTR [esi+104], eax

; 775  :   saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, 0, 0), nRefPitch[1])

	cmp	BYTE PTR [edi+122], 0
	je	SHORT $LN35@PseudoEPZS

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebx, DWORD PTR [edi+164]
	mov	eax, DWORD PTR [edi+20]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ebp, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 775  :   saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, 0, 0), nRefPitch[1])

	push	DWORD PTR [edi+188]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [ebx+4]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ebx, DWORD PTR [esi+16]
	add	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+20]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 775  :   saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, 0, 0), nRefPitch[1])

	mov	eax, DWORD PTR [edi+100]
	push	ebx
	push	DWORD PTR [edi+176]
	push	DWORD PTR [esi+96]
	call	eax
	push	DWORD PTR [edi+184]
	mov	ecx, DWORD PTR [edi+100]
	mov	ebx, eax
	push	ebp
	push	DWORD PTR [edi+172]
	push	DWORD PTR [esi+92]
	call	ecx
	add	esp, 32					; 00000020H
	add	ebx, eax
	mov	DWORD PTR _saduv$1$[esp+184], ebx
	mov	ebp, ebx
	jmp	SHORT $LN36@PseudoEPZS
$LN35@PseudoEPZS:
	xor	ebp, ebp
$LN36@PseudoEPZS:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [edi+20]

; 776  :     + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, 0, 0), nRefPitch[2]) : 0;
; 777  :   sad = LumaSAD(workarea, GetRefBlock(workarea, 0, zeroMVfieldShifted.y));

	mov	ecx, DWORD PTR [edi+208]

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	cmp	eax, 2
	jne	SHORT $LN110@PseudoEPZS
	mov	eax, DWORD PTR [edi+164]
	mov	ebx, DWORD PTR [esi+8]
	add	ebx, ebx
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edi+52]
	mov	eax, edx
	shl	ebx, cl
	sar	eax, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edi+12]
	add	ebx, eax
	mov	eax, DWORD PTR [edi]
	add	ebx, DWORD PTR [eax+edx*8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN390@PseudoEPZS
$LN110@PseudoEPZS:
	cmp	eax, 1
	mov	eax, DWORD PTR [edi+164]
	jne	SHORT $LN108@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	ebx, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	ebx, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN109@PseudoEPZS
$LN108@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR [esi+8]
	shl	ebx, 2
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	ebx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edx, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edi+52]
	mov	eax, edx
	shl	ebx, cl
	sar	eax, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edi+12]
	add	edx, edx
	add	ebx, eax
	mov	eax, DWORD PTR [edi]
	add	ebx, DWORD PTR [eax+edx*8]
$LN390@PseudoEPZS:
	mov	edi, DWORD PTR _this$1$[esp+184]
$LN109@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [edi+216], 0
	jne	SHORT $LN135@PseudoEPZS
	push	DWORD PTR [edi+180]
	mov	eax, DWORD PTR [edi+80]
	push	ebx
	push	DWORD PTR [edi+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN391@PseudoEPZS
$LN135@PseudoEPZS:
	push	ebx
	push	esi
	mov	ecx, edi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN391@PseudoEPZS:
	mov	ecx, eax

; 778  :   sad += saduv;

	add	ecx, ebp

; 779  :   workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], ecx

; 780  :   workarea.nMinCost = sad + ((penaltyZero*(safe_sad_t)sad) >> 8); // v.1.11.0.2

	mov	eax, DWORD PTR [edi+240]
	imul	eax, ecx
	sar	eax, 8
	add	eax, ecx
	mov	DWORD PTR [esi+112], eax

; 781  : 
; 782  :   VECTOR bestMVMany[8];
; 783  :   int nMinCostMany[8];
; 784  : 
; 785  :   if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN17@PseudoEPZS

; 786  :   {
; 787  :     //  refine around zero
; 788  :     Refine(workarea);

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine

; 789  :     bestMVMany[0] = workarea.bestMV;    // save bestMV

	mov	eax, DWORD PTR [esi+108]
	movq	xmm0, QWORD PTR [esi+100]
	mov	DWORD PTR _bestMVMany$[esp+192], eax

; 790  :     nMinCostMany[0] = workarea.nMinCost;

	mov	eax, DWORD PTR [esi+112]
	movq	QWORD PTR _bestMVMany$[esp+184], xmm0
	mov	DWORD PTR _nMinCostMany$[esp+184], eax
$LN17@PseudoEPZS:

; 791  :   }
; 792  : 
; 793  :   // Global MV predictor  - added by Fizick
; 794  :   workarea.globalMVPredictor = ClipMV(workarea, workarea.globalMVPredictor);

	movq	xmm0, QWORD PTR [esi+52]
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, esp
	push	esi
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T3[esp+200]
	push	eax
	call	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [esi+52], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+60], eax

; 797  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y), nRefPitch[1])

	cmp	BYTE PTR [edi+122], 0
	je	$LN37@PseudoEPZS

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+20]

; 797  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y), nRefPitch[1])

	mov	ebx, DWORD PTR [esi+56]

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	cmp	eax, 2
	jne	SHORT $LN141@PseudoEPZS
	mov	eax, DWORD PTR [edi+164]
	mov	edx, ebx
	mov	DWORD PTR _this$1$[esp+184], eax
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, eax
	sar	edx, cl
	mov	DWORD PTR tv3279[esp+184], eax
	mov	eax, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, eax
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv3277[esp+184], eax
	mov	eax, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 1
	sar	edi, 1
	add	edx, edx
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	DWORD PTR tv3314[esp+184], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN392@PseudoEPZS
$LN141@PseudoEPZS:
	cmp	eax, 1
	mov	eax, DWORD PTR [edi+164]
	mov	DWORD PTR _this$1$[esp+184], eax
	jne	SHORT $LN139@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, eax
	mov	ebp, DWORD PTR [esi+52]
	sar	ebp, cl
	add	ebp, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv3277[esp+184], eax
	mov	eax, ebx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	shl	ebp, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+60]
	sar	eax, cl
	add	eax, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
	add	ebp, DWORD PTR [eax]
	mov	DWORD PTR tv3314[esp+184], ebp
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN140@PseudoEPZS
$LN139@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, ebx
	mov	eax, DWORD PTR [edi+60]
	mov	ecx, eax
	mov	DWORD PTR tv3279[esp+184], eax
	mov	eax, DWORD PTR [esi+24]
	sar	edx, cl
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, eax
	mov	DWORD PTR tv3277[esp+184], eax
	mov	eax, DWORD PTR [esi+12]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	edi, 2
	mov	eax, DWORD PTR [ebp]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	add	eax, ebx
	mov	DWORD PTR tv3314[esp+184], eax
$LN392@PseudoEPZS:
	mov	ecx, DWORD PTR tv3279[esp+184]
	mov	ebx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR _this$1$[esp+184]
$LN140@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [esi+52]
	cmp	eax, 2
	jne	SHORT $LN168@PseudoEPZS
	mov	eax, DWORD PTR [esi+28]
	sar	ebx, cl
	mov	ecx, DWORD PTR tv3277[esp+184]
	sar	edx, cl
	lea	ebx, DWORD PTR [ebx+eax*2]
	mov	eax, DWORD PTR [esi+16]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	add	edx, edx

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN393@PseudoEPZS
$LN168@PseudoEPZS:
	cmp	eax, 1
	jne	SHORT $LN166@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+52]
	sar	edx, cl
	add	edx, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	shl	edx, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+60]
	sar	ebx, cl
	add	ebx, DWORD PTR [esi+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax]
	add	edx, ebx
	add	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN167@PseudoEPZS
$LN166@PseudoEPZS:
	mov	eax, DWORD PTR [esi+28]
	sar	ebx, cl
	mov	ecx, DWORD PTR tv3277[esp+184]
	sar	edx, cl
	lea	ebx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [esi+16]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	shl	edx, 2
	and	eax, 3

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN393@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR _this$1$[esp+184]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [ebp+52]
	shl	edi, cl
	mov	edx, DWORD PTR [eax+edx*4]
	add	edx, edi
	mov	edi, DWORD PTR _this$1$[esp+184]
	add	edx, ebx
$LN167@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 797  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y), nRefPitch[1])

	push	DWORD PTR [edi+188]
	mov	eax, DWORD PTR [edi+100]
	push	edx
	push	DWORD PTR [edi+176]
	push	DWORD PTR [esi+96]
	call	eax
	push	DWORD PTR [edi+184]
	mov	ecx, DWORD PTR [edi+100]
	mov	ebx, eax
	push	DWORD PTR tv3314[esp+204]
	push	DWORD PTR [edi+172]
	push	DWORD PTR [esi+92]
	call	ecx
	add	esp, 32					; 00000020H
	add	ebx, eax
	mov	DWORD PTR _saduv$2$[esp+184], ebx
	jmp	SHORT $LN38@PseudoEPZS
$LN37@PseudoEPZS:
	mov	DWORD PTR _saduv$2$[esp+184], 0
$LN38@PseudoEPZS:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [edi+20]

; 798  :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y), nRefPitch[2]) : 0;
; 799  :     sad = LumaSAD(workarea, GetRefBlock(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y));

	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+52]

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	cmp	eax, 2
	jne	SHORT $LN195@PseudoEPZS
	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	add	edx, edx

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN394@PseudoEPZS
$LN195@PseudoEPZS:
	cmp	eax, 1
	mov	eax, DWORD PTR [edi+164]
	jne	SHORT $LN193@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	mov	DWORD PTR $T2[esp+184], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	add	eax, DWORD PTR [esi+52]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	shl	eax, cl
	mov	ecx, DWORD PTR $T2[esp+184]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN194@PseudoEPZS
$LN193@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	shl	edx, 2
	and	eax, 3

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN394@PseudoEPZS:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	mov	edi, DWORD PTR _this$1$[esp+184]
	add	ecx, ebx
$LN194@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [edi+216], 0
	jne	SHORT $LN220@PseudoEPZS
	push	DWORD PTR [edi+180]
	mov	eax, DWORD PTR [edi+80]
	push	ecx
	push	DWORD PTR [edi+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN395@PseudoEPZS
$LN220@PseudoEPZS:
	push	ecx
	push	esi
	mov	ecx, edi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN395@PseudoEPZS:
	mov	ecx, eax

; 800  :     sad += saduv;

	add	ecx, DWORD PTR _saduv$2$[esp+184]

; 801  :     sad_t cost = sad + ((pglobal*(bigsad_t)sad) >> 8);

	mov	eax, ecx
	imul	DWORD PTR [edi+244]
	mov	ebx, eax
	shrd	ebx, edx, 8
	add	ebx, ecx
	sar	edx, 8

; 802  : 
; 803  :     if (cost < workarea.nMinCost || tryMany)

	cmp	ebx, DWORD PTR [esi+112]
	jl	SHORT $LN19@PseudoEPZS
	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN20@PseudoEPZS
$LN19@PseudoEPZS:

; 804  :     {
; 805  :       workarea.bestMV.x = workarea.globalMVPredictor.x;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+100], eax

; 806  :       workarea.bestMV.y = workarea.globalMVPredictor.y;

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [esi+104], eax

; 807  :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], ecx

; 808  :       workarea.nMinCost = cost;

	mov	DWORD PTR [esi+112], ebx

; 809  :     }
; 810  :     if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN20@PseudoEPZS

; 811  :     {
; 812  :       // refine around global
; 813  :       Refine(workarea);    // reset bestMV

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine

; 814  :       bestMVMany[1] = workarea.bestMV;    // save bestMV

	mov	eax, DWORD PTR [esi+108]
	movq	xmm0, QWORD PTR [esi+100]
	mov	DWORD PTR _bestMVMany$[esp+204], eax

; 815  :       nMinCostMany[1] = workarea.nMinCost;

	mov	eax, DWORD PTR [esi+112]
	movq	QWORD PTR _bestMVMany$[esp+196], xmm0
	mov	DWORD PTR _nMinCostMany$[esp+188], eax
$LN20@PseudoEPZS:

; 822  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	cmp	BYTE PTR [edi+122], 0
	je	$LN39@PseudoEPZS

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+20]

; 822  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	mov	ebp, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR _nVx$1$[esp+184], ebp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	cmp	ecx, 2
	jne	SHORT $LN226@PseudoEPZS
	mov	ecx, DWORD PTR [edi+164]
	mov	edx, eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _this$1$[esp+184], ecx
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+60]
	sar	edx, cl
	mov	DWORD PTR tv3278[esp+184], ecx
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR _nVx$1$[esp+184]
	mov	ecx, eax
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv3276[esp+184], eax
	mov	eax, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 1
	sar	edi, 1
	add	edx, edx
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	DWORD PTR tv3312[esp+184], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN397@PseudoEPZS
$LN226@PseudoEPZS:
	cmp	ecx, 1
	mov	ecx, DWORD PTR [edi+164]
	mov	DWORD PTR _this$1$[esp+184], ecx
	jne	SHORT $LN224@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebx, eax
	mov	ecx, DWORD PTR [edi+52]
	mov	eax, ebp
	mov	DWORD PTR tv3276[esp+184], ecx
	mov	ecx, DWORD PTR [edi+60]
	sar	ebx, cl
	add	ebx, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv3278[esp+184], ecx
	mov	ecx, DWORD PTR [edi+52]
	sar	eax, cl
	add	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
	mov	DWORD PTR tv3312[esp+184], ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN225@PseudoEPZS
$LN224@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, eax
	mov	ecx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [esi+24]
	sar	edx, cl
	mov	DWORD PTR tv3278[esp+184], ecx
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR _nVx$1$[esp+184]
	mov	ecx, eax
	mov	DWORD PTR tv3276[esp+184], eax
	mov	eax, DWORD PTR [esi+12]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	edi, 2
	mov	eax, DWORD PTR [ebp]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	add	eax, ebx
	mov	DWORD PTR tv3312[esp+184], eax
$LN397@PseudoEPZS:
	mov	ebp, DWORD PTR _nVx$1$[esp+184]
	mov	edi, DWORD PTR _this$1$[esp+184]
$LN225@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [esi+120]
	cmp	eax, 2
	jne	SHORT $LN253@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR _this$1$[esp+184]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR tv3278[esp+184]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3276[esp+184]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+28]
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _nVx$1$[esp+184]
	mov	eax, DWORD PTR [esi+16]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	add	edx, edx
	sar	edi, 1
	and	eax, 1
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	add	edx, edi
	mov	ebp, edx
	mov	DWORD PTR _nVx$1$[esp+184], edx
	add	ebp, ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN398@PseudoEPZS
$LN253@PseudoEPZS:
	cmp	eax, 1
	jne	SHORT $LN251@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+52]
	sar	ebp, cl
	add	ebp, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	shl	ebp, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+60]
	sar	edx, cl
	add	edx, DWORD PTR [esi+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax]
	add	ebp, edx
	add	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN252@PseudoEPZS
$LN251@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR _this$1$[esp+184]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR tv3278[esp+184]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3276[esp+184]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+28]
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _nVx$1$[esp+184]
	mov	eax, DWORD PTR [esi+16]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
	mov	eax, edi
	shl	edx, 2
	and	eax, 3
	sar	edi, 2
	or	edx, eax

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	edi, cl
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	imul	ebx, DWORD PTR [ebp+12]
	lea	ebp, DWORD PTR [ebx+eax]
$LN398@PseudoEPZS:
	mov	edi, DWORD PTR _this$1$[esp+184]
$LN252@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 822  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	push	DWORD PTR [edi+184]
	mov	eax, DWORD PTR [edi+100]
	push	DWORD PTR tv3312[esp+188]
	push	DWORD PTR [edi+172]
	push	DWORD PTR [esi+92]
	call	eax
	push	DWORD PTR [edi+188]
	mov	ecx, DWORD PTR [edi+100]
	mov	ebx, eax
	push	ebp
	push	DWORD PTR [edi+176]
	push	DWORD PTR [esi+96]
	call	ecx
	add	esp, 32					; 00000020H
	add	ebx, eax
	mov	DWORD PTR _saduv$3$[esp+184], ebx
	jmp	SHORT $LN40@PseudoEPZS
$LN39@PseudoEPZS:
	mov	DWORD PTR _saduv$3$[esp+184], 0
$LN40@PseudoEPZS:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [edi+20]

; 823  :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[2]) : 0;
; 824  :     sad = LumaSAD(workarea, GetRefBlock(workarea, workarea.predictor.x, workarea.predictor.y));

	mov	ebx, DWORD PTR [esi+120]
	mov	ecx, DWORD PTR [esi+116]

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	cmp	eax, 2
	jne	SHORT $LN280@PseudoEPZS
	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ebx+eax*2]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN399@PseudoEPZS
$LN280@PseudoEPZS:
	cmp	eax, 1
	mov	eax, DWORD PTR [edi+164]
	jne	SHORT $LN278@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+184], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+184]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, ebx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN279@PseudoEPZS
$LN278@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN399@PseudoEPZS:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	mov	edi, DWORD PTR _this$1$[esp+184]
	add	ecx, ebx
$LN279@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [edi+216], 0
	jne	SHORT $LN305@PseudoEPZS
	push	DWORD PTR [edi+180]
	mov	eax, DWORD PTR [edi+80]
	push	ecx
	push	DWORD PTR [edi+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN400@PseudoEPZS
$LN305@PseudoEPZS:
	push	ecx
	push	esi
	mov	ecx, edi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN400@PseudoEPZS:
	mov	ecx, eax

; 825  :     sad += saduv;

	add	ecx, DWORD PTR _saduv$3$[esp+184]

; 826  :     cost = sad;
; 827  : 
; 828  :     if (cost < workarea.nMinCost || tryMany)

	cmp	ecx, DWORD PTR [esi+112]
	jl	SHORT $LN22@PseudoEPZS
	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN23@PseudoEPZS
$LN22@PseudoEPZS:

; 829  :     {
; 830  :       workarea.bestMV.x = workarea.predictor.x;

	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR [esi+100], eax

; 831  :       workarea.bestMV.y = workarea.predictor.y;

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+104], eax

; 832  :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], ecx

; 833  :       workarea.nMinCost = cost;

	mov	DWORD PTR [esi+112], ecx

; 834  :     }
; 835  :   }
; 836  : 
; 837  :   if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN23@PseudoEPZS

; 838  :   {
; 839  :     // refine around predictor
; 840  :     Refine(workarea);    // reset bestMV

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine

; 841  :     bestMVMany[2] = workarea.bestMV;    // save bestMV

	mov	eax, DWORD PTR [esi+108]
	movq	xmm0, QWORD PTR [esi+100]
	mov	DWORD PTR _bestMVMany$[esp+216], eax

; 842  :     nMinCostMany[2] = workarea.nMinCost;

	mov	eax, DWORD PTR [esi+112]
	movq	QWORD PTR _bestMVMany$[esp+208], xmm0
	mov	DWORD PTR _nMinCostMany$[esp+192], eax
$LN23@PseudoEPZS:

; 843  :   }
; 844  : 
; 845  :   // then all the other predictors
; 846  :   int npred = (temporal) ? 5 : 4;

	mov	cl, BYTE PTR [edi+260]
	lea	ebp, DWORD PTR [esi+128]
	xor	eax, eax
	mov	BYTE PTR tv3317[esp+184], cl
	test	cl, cl
	setne	al
	add	eax, 4

; 847  : 
; 848  :   for (int i = 0; i < npred; i++)

	xor	ebx, ebx
	mov	DWORD PTR _npred$1$[esp+184], eax
	lea	eax, DWORD PTR _bestMVMany$[esp+220]
	mov	DWORD PTR tv3253[esp+184], eax
$LL4@PseudoEPZS:

; 849  :   {
; 850  :     if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN24@PseudoEPZS

; 851  :     {
; 852  :       workarea.nMinCost = verybigSAD + 1;

	mov	eax, DWORD PTR [edi+156]
	inc	eax
	mov	DWORD PTR [esi+112], eax
$LN24@PseudoEPZS:

; 853  :     }
; 854  :     CheckMV0(workarea, workarea.predictors[i].x, workarea.predictors[i].y);

	push	DWORD PTR [ebp+4]
	mov	ecx, edi
	push	DWORD PTR [ebp]
	push	esi
	call	?CheckMV0@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV0

; 855  :     if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN389@PseudoEPZS

; 856  :     {
; 857  :       // refine around predictor
; 858  :       Refine(workarea);    // reset bestMV

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine

; 859  :       bestMVMany[i + 3] = workarea.bestMV;    // save bestMV

	mov	ecx, DWORD PTR tv3253[esp+184]
	movq	xmm0, QWORD PTR [esi+100]
	mov	eax, DWORD PTR [esi+108]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax

; 860  :       nMinCostMany[i + 3] = workarea.nMinCost;

	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR _nMinCostMany$[esp+ebx*4+196], eax
	jmp	SHORT $LN2@PseudoEPZS
$LN389@PseudoEPZS:
	mov	ecx, DWORD PTR tv3253[esp+184]
$LN2@PseudoEPZS:

; 847  : 
; 848  :   for (int i = 0; i < npred; i++)

	inc	ebx
	add	ecx, 12					; 0000000cH
	add	ebp, 12					; 0000000cH
	mov	DWORD PTR tv3253[esp+184], ecx
	cmp	ebx, DWORD PTR _npred$1$[esp+184]
	jl	SHORT $LL4@PseudoEPZS

; 861  :     }
; 862  :   }	// for i
; 863  : 
; 864  :   if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN26@PseudoEPZS

; 865  :   {
; 866  :     // select best of multi best
; 867  :     workarea.nMinCost = verybigSAD + 1;

	mov	eax, DWORD PTR [edi+156]
	lea	edx, DWORD PTR _bestMVMany$[esp+184]
	xor	ecx, ecx
	inc	eax
	cmp	BYTE PTR tv3317[esp+184], cl
	mov	DWORD PTR [esi+112], eax
	setne	cl
	add	ecx, 7
	mov	DWORD PTR tv3269[esp+184], ecx

; 868  :     for (int i = 0; i < npred + 3; i++)

	xor	ecx, ecx
	mov	ebp, DWORD PTR tv3269[esp+184]
$LL7@PseudoEPZS:

; 869  :     {
; 870  :       if (nMinCostMany[i] < workarea.nMinCost)

	mov	ebx, DWORD PTR _nMinCostMany$[esp+ecx*4+184]
	cmp	ebx, eax
	jge	SHORT $LN5@PseudoEPZS

; 871  :       {
; 872  :         workarea.bestMV = bestMVMany[i];

	movq	xmm0, QWORD PTR [edx]
	mov	eax, DWORD PTR [edx+8]
	movq	QWORD PTR [esi+100], xmm0
	mov	DWORD PTR [esi+108], eax
	mov	eax, ebx
$LN5@PseudoEPZS:

; 868  :     for (int i = 0; i < npred + 3; i++)

	inc	ecx
	add	edx, 12					; 0000000cH
	cmp	ecx, ebp
	jl	SHORT $LL7@PseudoEPZS
	mov	DWORD PTR [esi+112], eax

; 873  :         workarea.nMinCost = nMinCostMany[i];
; 874  :       }
; 875  :     }
; 876  :   }
; 877  :   else

	jmp	SHORT $LN27@PseudoEPZS
$LN26@PseudoEPZS:

; 878  :   {
; 879  :     // then, we refine, according to the search type
; 880  :     Refine(workarea);

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine
$LN27@PseudoEPZS:

; 889  :     && foundSAD > (badSAD + badSAD*badcount / BADCOUNT_LIMIT))

	mov	eax, DWORD PTR [esi+80]
	imul	eax, DWORD PTR [edi]
	mov	ebp, DWORD PTR [esi+108]
	mov	DWORD PTR _foundSAD$1$[esp+184], ebp
	inc	eax
	cmp	DWORD PTR [esi+40], eax
	jle	$LN12@PseudoEPZS
	mov	ecx, DWORD PTR [edi+248]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 93   : 	return (T (_val));

	lea	ebx, DWORD PTR [edi+256]
	mov	eax, DWORD PTR [ebx]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 889  :     && foundSAD > (badSAD + badSAD*badcount / BADCOUNT_LIMIT))

	imul	eax, ecx
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	add	eax, ecx
	cmp	ebp, eax
	jle	$LN12@PseudoEPZS
	npad	7
$LL320@PseudoEPZS:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [ebx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ebx], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL320@PseudoEPZS
; File c:\github\mvtools\sources\planeofblocks.cpp

; 909  :     if (badrange > 0) // UMH

	mov	edx, DWORD PTR [edi+252]
	test	edx, edx
	jle	SHORT $LN402@PseudoEPZS

; 910  :     {
; 911  : 
; 912  :       //			UMHSearch(badrange*nPel, workarea.bestMV.x, workarea.bestMV.y);
; 913  : 
; 914  :       //			if (workarea.bestMV.sad > foundSAD/2)
; 915  :       {
; 916  :         // rathe good is not found, lets try around zero
; 917  : //				UMHSearch(workarea, badSADRadius, abs(mvx0)%4 - 2, abs(mvy0)%4 - 2);
; 918  :         UMHSearch(workarea, badrange*nPel, 0, 0);

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, edi
	push	0
	imul	eax, edx
	push	0
	push	eax
	push	esi
	call	?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z ; PlaneOfBlocks::UMHSearch
	jmp	SHORT $LN373@PseudoEPZS
$LN402@PseudoEPZS:

; 919  :       }
; 920  :     }
; 921  : 
; 922  :     else if (badrange < 0) // ESA

	jns	SHORT $LN373@PseudoEPZS

; 923  :     {
; 924  :       /*
; 925  :             workarea.bestMV.x = mvx0; // restore  for comparing
; 926  :             workarea.bestMV.y = mvy0;
; 927  :             workarea.bestMV.sad = msad0;
; 928  :             workarea.nMinCost = mcost0;
; 929  : 
; 930  :             int mvx = workarea.bestMV.x; // store to not move the search center!
; 931  :             int mvy = workarea.bestMV.y;
; 932  :             int msad = workarea.bestMV.sad;
; 933  : 
; 934  :             for ( int i = 1; i < -badrange*nPel; i+=nPel )// at radius
; 935  :             {
; 936  :               ExpandingSearch(i, nPel, mvx, mvy);
; 937  :               if (workarea.bestMV.sad < foundSAD/4)
; 938  :               {
; 939  :                 break; // stop search
; 940  :               }
; 941  :             }
; 942  : 
; 943  :             if (workarea.bestMV.sad > foundSAD/2 && abs(mvx)+abs(mvy) > badSADRadius/2)
; 944  :             {
; 945  :               // rathe good is not found, lets try around zero
; 946  :               mvx = 0; // store to not move the search center!
; 947  :               mvy = 0;
; 948  :       */
; 949  :       for (int i = 1; i < -badrange*nPel; i += nPel)// at radius

	mov	ebx, DWORD PTR [edi+20]
	mov	ebp, 1
	mov	ecx, ebx
	imul	ecx, edx
	neg	ecx
	cmp	ecx, ebp
	jle	SHORT $LN373@PseudoEPZS
	mov	eax, DWORD PTR _foundSAD$1$[esp+184]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv3262[esp+184], eax
$LL10@PseudoEPZS:

; 950  :       {
; 951  :         ExpandingSearch(workarea, i, nPel, 0, 0);

	push	0
	push	0
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch

; 952  :         if (workarea.bestMV.sad < foundSAD / 4)

	mov	eax, DWORD PTR tv3262[esp+184]
	cmp	DWORD PTR [esi+108], eax
	jl	SHORT $LN373@PseudoEPZS

; 923  :     {
; 924  :       /*
; 925  :             workarea.bestMV.x = mvx0; // restore  for comparing
; 926  :             workarea.bestMV.y = mvy0;
; 927  :             workarea.bestMV.sad = msad0;
; 928  :             workarea.nMinCost = mcost0;
; 929  : 
; 930  :             int mvx = workarea.bestMV.x; // store to not move the search center!
; 931  :             int mvy = workarea.bestMV.y;
; 932  :             int msad = workarea.bestMV.sad;
; 933  : 
; 934  :             for ( int i = 1; i < -badrange*nPel; i+=nPel )// at radius
; 935  :             {
; 936  :               ExpandingSearch(i, nPel, mvx, mvy);
; 937  :               if (workarea.bestMV.sad < foundSAD/4)
; 938  :               {
; 939  :                 break; // stop search
; 940  :               }
; 941  :             }
; 942  : 
; 943  :             if (workarea.bestMV.sad > foundSAD/2 && abs(mvx)+abs(mvy) > badSADRadius/2)
; 944  :             {
; 945  :               // rathe good is not found, lets try around zero
; 946  :               mvx = 0; // store to not move the search center!
; 947  :               mvy = 0;
; 948  :       */
; 949  :       for (int i = 1; i < -badrange*nPel; i += nPel)// at radius

	mov	ebx, DWORD PTR [edi+20]
	add	ebp, ebx
	mov	eax, DWORD PTR [edi+252]
	imul	eax, ebx
	neg	eax
	cmp	ebp, eax
	jl	SHORT $LL10@PseudoEPZS
$LN373@PseudoEPZS:

; 953  :         {
; 954  :           break; // stop search if rathe good is found
; 955  :         }
; 956  :       }	// for i
; 957  :     }	// badrange < 0
; 958  : 
; 959  :     int mvx = workarea.bestMV.x; // refine in small area
; 960  :     int mvy = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+104]

; 961  :     for (int i = 1; i < nPel; i++)// small radius

	mov	ebx, 1
	mov	ebp, DWORD PTR [esi+100]
	mov	DWORD PTR _mvy$1$[esp+184], eax
	cmp	DWORD PTR [edi+20], ebx
	jle	SHORT $LN12@PseudoEPZS
$LL13@PseudoEPZS:

; 962  :     {
; 963  :       ExpandingSearch(workarea, i, 1, mvx, mvy);

	push	eax
	push	ebp
	push	1
	push	ebx
	push	esi
	mov	ecx, edi
	call	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch
	mov	eax, DWORD PTR _mvy$1$[esp+184]
	inc	ebx
	cmp	ebx, DWORD PTR [edi+20]
	jl	SHORT $LL13@PseudoEPZS
$LN12@PseudoEPZS:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 969  :   vectors[workarea.blkIdx].x = workarea.bestMV.x;

	mov	ecx, DWORD PTR [edi+108]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 969  :   vectors[workarea.blkIdx].x = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [ecx+edx*4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 970  :   vectors[workarea.blkIdx].y = workarea.bestMV.y;

	mov	ecx, DWORD PTR [edi+108]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 970  :   vectors[workarea.blkIdx].y = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [ecx+edx*4+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 971  :   vectors[workarea.blkIdx].sad = workarea.bestMV.sad;

	mov	ecx, DWORD PTR [edi+108]

; 974  : }

	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 971  :   vectors[workarea.blkIdx].sad = workarea.bestMV.sad;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [ecx+edx*4+8], eax

; 972  : 
; 973  :   workarea.planeSAD += workarea.bestMV.sad; // todo PF check int overflow

	mov	eax, DWORD PTR [esi+108]
	cdq
	add	DWORD PTR [esi+64], eax
	adc	DWORD PTR [esi+68], edx

; 974  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 168				; 000000a8H
	ret	4
??$PseudoEPZSearch@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ENDP ; PlaneOfBlocks::PseudoEPZSearch<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??$PseudoEPZSearch@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z
_TEXT	SEGMENT
_mvy$1$ = -168						; size = 4
_foundSAD$1$ = -168					; size = 4
tv3300 = -168						; size = 4
tv3256 = -168						; size = 4
tv3248 = -168						; size = 4
tv3239 = -168						; size = 4
_saduv$3$ = -168					; size = 4
_saduv$2$ = -168					; size = 4
_saduv$1$ = -168					; size = 4
_this$1$ = -164						; size = 4
$T1 = -160						; size = 4
$T2 = -160						; size = 4
_npred$1$ = -160					; size = 4
tv3267 = -160						; size = 4
tv3264 = -160						; size = 4
_nVx$1$ = -156						; size = 4
_this$1$ = -156						; size = 4
_this$1$ = -152						; size = 4
tv3265 = -152						; size = 4
tv3302 = -148						; size = 4
tv3266 = -148						; size = 4
tv3305 = -141						; size = 1
_nMinCostMany$ = -140					; size = 32
$T3 = -108						; size = 12
_bestMVMany$ = -96					; size = 96
_workarea$ = 8						; size = 4
??$PseudoEPZSearch@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z PROC ; PlaneOfBlocks::PseudoEPZSearch<unsigned short>, COMDAT
; _this$ = ecx

; 750  : {

	sub	esp, 168				; 000000a8H
	push	ebx
	push	ebp
	push	esi

; 751  :   typedef typename std::conditional < sizeof(pixel_t) == 1, sad_t, bigsad_t >::type safe_sad_t;
; 752  :   FetchPredictors<pixel_t>(workarea);

	mov	esi, DWORD PTR _workarea$[esp+176]
	push	edi
	mov	edi, ecx
	push	esi
	mov	DWORD PTR _this$1$[esp+188], edi
	call	??$FetchPredictors@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ; PlaneOfBlocks::FetchPredictors<unsigned short>

; 753  : 
; 754  :   sad_t sad;
; 755  :   sad_t saduv;
; 756  : #ifdef ALLOW_DCT
; 757  :   if (dctmode != 0) // DCT method (luma only - currently use normal spatial SAD chroma)

	mov	eax, DWORD PTR [edi+216]
	test	eax, eax
	je	SHORT $LN15@PseudoEPZS

; 758  :   {
; 759  :     // make dct of source block
; 760  :     if (dctmode <= 4) //don't do the slow dct conversion if SATD used

	cmp	eax, 4
	jg	SHORT $LN15@PseudoEPZS

; 761  :     {
; 762  :       workarea.DCT->DCTBytes2D(workarea.pSrc[0], nSrcPitch[0], &workarea.dctSrc[0], dctpitch);

	push	DWORD PTR [edi+124]
	mov	ecx, DWORD PTR [esi+48]
	push	DWORD PTR [esi+404]
	push	DWORD PTR [edi+168]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [esi+88]
	call	DWORD PTR [eax]
$LN15@PseudoEPZS:

; 763  :     }
; 764  :   }
; 765  :   if (dctmode >= 3) // most use it and it should be fast anyway //if (dctmode == 3 || dctmode == 4) // check it

	cmp	DWORD PTR [edi+216], 3
	jl	SHORT $LN16@PseudoEPZS

; 766  :   {
; 767  :     workarea.srcLuma = LUMA(workarea.pSrc[0], nSrcPitch[0]);

	push	DWORD PTR [edi+168]
	mov	eax, DWORD PTR [edi+84]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 8
	mov	DWORD PTR [esi+392], eax
$LN16@PseudoEPZS:

; 768  :   }
; 769  : #endif	// ALLOW_DCT
; 770  : 
; 771  :   // We treat zero alone
; 772  :   // Do we bias zero with not taking into account distorsion ?
; 773  :   workarea.bestMV.x = zeroMVfieldShifted.x;

	mov	eax, DWORD PTR [edi+204]
	mov	DWORD PTR [esi+100], eax

; 774  :   workarea.bestMV.y = zeroMVfieldShifted.y;

	mov	eax, DWORD PTR [edi+208]
	mov	DWORD PTR [esi+104], eax

; 775  :   saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, 0, 0), nRefPitch[1])

	cmp	BYTE PTR [edi+122], 0
	je	SHORT $LN35@PseudoEPZS

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebx, DWORD PTR [edi+164]
	mov	eax, DWORD PTR [edi+20]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ebp, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 775  :   saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, 0, 0), nRefPitch[1])

	push	DWORD PTR [edi+188]
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [ebx+4]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	edx, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ebx, DWORD PTR [esi+16]
	add	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+20]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edx+52]
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 775  :   saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, 0, 0), nRefPitch[1])

	mov	eax, DWORD PTR [edi+100]
	push	ebx
	push	DWORD PTR [edi+176]
	push	DWORD PTR [esi+96]
	call	eax
	push	DWORD PTR [edi+184]
	mov	ecx, DWORD PTR [edi+100]
	mov	ebx, eax
	push	ebp
	push	DWORD PTR [edi+172]
	push	DWORD PTR [esi+92]
	call	ecx
	add	esp, 32					; 00000020H
	add	ebx, eax
	mov	DWORD PTR _saduv$1$[esp+184], ebx
	mov	ebp, ebx
	jmp	SHORT $LN36@PseudoEPZS
$LN35@PseudoEPZS:
	xor	ebp, ebp
$LN36@PseudoEPZS:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [edi+20]

; 776  :     + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, 0, 0), nRefPitch[2]) : 0;
; 777  :   sad = LumaSAD(workarea, GetRefBlock(workarea, 0, zeroMVfieldShifted.y));

	mov	ecx, DWORD PTR [edi+208]

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	cmp	eax, 2
	jne	SHORT $LN110@PseudoEPZS
	mov	eax, DWORD PTR [edi+164]
	mov	ebx, DWORD PTR [esi+8]
	add	ebx, ebx
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edi+52]
	mov	eax, edx
	shl	ebx, cl
	sar	eax, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edi+12]
	add	ebx, eax
	mov	eax, DWORD PTR [edi]
	add	ebx, DWORD PTR [eax+edx*8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN390@PseudoEPZS
$LN110@PseudoEPZS:
	cmp	eax, 1
	mov	eax, DWORD PTR [edi+164]
	jne	SHORT $LN108@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	ebx, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	ebx, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN109@PseudoEPZS
$LN108@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edi, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR [esi+8]
	shl	ebx, 2
; File c:\github\mvtools\sources\mvplane.h

; 68   :       nX >>= NPELL2;

	sar	ebx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edx, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edi+52]
	mov	eax, edx
	shl	ebx, cl
	sar	eax, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edi+12]
	add	edx, edx
	add	ebx, eax
	mov	eax, DWORD PTR [edi]
	add	ebx, DWORD PTR [eax+edx*8]
$LN390@PseudoEPZS:
	mov	edi, DWORD PTR _this$1$[esp+184]
$LN109@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [edi+216], 0
	jne	SHORT $LN135@PseudoEPZS
	push	DWORD PTR [edi+180]
	mov	eax, DWORD PTR [edi+80]
	push	ebx
	push	DWORD PTR [edi+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN391@PseudoEPZS
$LN135@PseudoEPZS:
	push	ebx
	push	esi
	mov	ecx, edi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN391@PseudoEPZS:
	mov	ecx, eax

; 778  :   sad += saduv;

	add	ecx, ebp

; 779  :   workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], ecx

; 780  :   workarea.nMinCost = sad + ((penaltyZero*(safe_sad_t)sad) >> 8); // v.1.11.0.2

	mov	eax, ecx
	imul	DWORD PTR [edi+240]
	shrd	eax, edx, 8
	add	eax, ecx
	sar	edx, 8
	mov	DWORD PTR [esi+112], eax

; 781  : 
; 782  :   VECTOR bestMVMany[8];
; 783  :   int nMinCostMany[8];
; 784  : 
; 785  :   if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN17@PseudoEPZS

; 786  :   {
; 787  :     //  refine around zero
; 788  :     Refine(workarea);

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine

; 789  :     bestMVMany[0] = workarea.bestMV;    // save bestMV

	mov	eax, DWORD PTR [esi+108]
	movq	xmm0, QWORD PTR [esi+100]
	mov	DWORD PTR _bestMVMany$[esp+192], eax

; 790  :     nMinCostMany[0] = workarea.nMinCost;

	mov	eax, DWORD PTR [esi+112]
	movq	QWORD PTR _bestMVMany$[esp+184], xmm0
	mov	DWORD PTR _nMinCostMany$[esp+184], eax
$LN17@PseudoEPZS:

; 791  :   }
; 792  : 
; 793  :   // Global MV predictor  - added by Fizick
; 794  :   workarea.globalMVPredictor = ClipMV(workarea, workarea.globalMVPredictor);

	movq	xmm0, QWORD PTR [esi+52]
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, esp
	push	esi
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T3[esp+200]
	push	eax
	call	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [esi+52], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+60], eax

; 797  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y), nRefPitch[1])

	cmp	BYTE PTR [edi+122], 0
	je	$LN37@PseudoEPZS

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+20]

; 797  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y), nRefPitch[1])

	mov	ebx, DWORD PTR [esi+56]

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	cmp	eax, 2
	jne	SHORT $LN141@PseudoEPZS
	mov	eax, DWORD PTR [edi+164]
	mov	edx, ebx
	mov	DWORD PTR _this$1$[esp+184], eax
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+60]
	mov	ecx, eax
	sar	edx, cl
	mov	DWORD PTR tv3267[esp+184], eax
	mov	eax, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, eax
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv3265[esp+184], eax
	mov	eax, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 1
	sar	edi, 1
	add	edx, edx
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	DWORD PTR tv3302[esp+184], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN392@PseudoEPZS
$LN141@PseudoEPZS:
	cmp	eax, 1
	mov	eax, DWORD PTR [edi+164]
	mov	DWORD PTR _this$1$[esp+184], eax
	jne	SHORT $LN139@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+52]
	mov	ecx, eax
	mov	ebp, DWORD PTR [esi+52]
	sar	ebp, cl
	add	ebp, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv3265[esp+184], eax
	mov	eax, ebx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	shl	ebp, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+60]
	sar	eax, cl
	add	eax, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
	add	ebp, DWORD PTR [eax]
	mov	DWORD PTR tv3302[esp+184], ebp
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN140@PseudoEPZS
$LN139@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, ebx
	mov	eax, DWORD PTR [edi+60]
	mov	ecx, eax
	mov	DWORD PTR tv3267[esp+184], eax
	mov	eax, DWORD PTR [esi+24]
	sar	edx, cl
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, eax
	mov	DWORD PTR tv3265[esp+184], eax
	mov	eax, DWORD PTR [esi+12]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	edi, 2
	mov	eax, DWORD PTR [ebp]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	add	eax, ebx
	mov	DWORD PTR tv3302[esp+184], eax
$LN392@PseudoEPZS:
	mov	ecx, DWORD PTR tv3267[esp+184]
	mov	ebx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR _this$1$[esp+184]
$LN140@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [esi+52]
	cmp	eax, 2
	jne	SHORT $LN168@PseudoEPZS
	mov	eax, DWORD PTR [esi+28]
	sar	ebx, cl
	mov	ecx, DWORD PTR tv3265[esp+184]
	sar	edx, cl
	lea	ebx, DWORD PTR [ebx+eax*2]
	mov	eax, DWORD PTR [esi+16]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	add	edx, edx

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN393@PseudoEPZS
$LN168@PseudoEPZS:
	cmp	eax, 1
	jne	SHORT $LN166@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+52]
	sar	edx, cl
	add	edx, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	shl	edx, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+60]
	sar	ebx, cl
	add	ebx, DWORD PTR [esi+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax]
	add	edx, ebx
	add	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN167@PseudoEPZS
$LN166@PseudoEPZS:
	mov	eax, DWORD PTR [esi+28]
	sar	ebx, cl
	mov	ecx, DWORD PTR tv3265[esp+184]
	sar	edx, cl
	lea	ebx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [esi+16]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	shl	edx, 2
	and	eax, 3

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN393@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR _this$1$[esp+184]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [ebp+8]
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [ebp+52]
	shl	edi, cl
	mov	edx, DWORD PTR [eax+edx*4]
	add	edx, edi
	mov	edi, DWORD PTR _this$1$[esp+184]
	add	edx, ebx
$LN167@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 797  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y), nRefPitch[1])

	push	DWORD PTR [edi+188]
	mov	eax, DWORD PTR [edi+100]
	push	edx
	push	DWORD PTR [edi+176]
	push	DWORD PTR [esi+96]
	call	eax
	push	DWORD PTR [edi+184]
	mov	ecx, DWORD PTR [edi+100]
	mov	ebx, eax
	push	DWORD PTR tv3302[esp+204]
	push	DWORD PTR [edi+172]
	push	DWORD PTR [esi+92]
	call	ecx
	add	esp, 32					; 00000020H
	add	ebx, eax
	mov	DWORD PTR _saduv$2$[esp+184], ebx
	jmp	SHORT $LN38@PseudoEPZS
$LN37@PseudoEPZS:
	mov	DWORD PTR _saduv$2$[esp+184], 0
$LN38@PseudoEPZS:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [edi+20]

; 798  :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y), nRefPitch[2]) : 0;
; 799  :     sad = LumaSAD(workarea, GetRefBlock(workarea, workarea.globalMVPredictor.x, workarea.globalMVPredictor.y));

	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi+52]

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	cmp	eax, 2
	jne	SHORT $LN195@PseudoEPZS
	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	add	edx, edx

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN394@PseudoEPZS
$LN195@PseudoEPZS:
	cmp	eax, 1
	mov	eax, DWORD PTR [edi+164]
	jne	SHORT $LN193@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	mov	DWORD PTR $T2[esp+184], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	add	eax, DWORD PTR [esi+52]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	shl	eax, cl
	mov	ecx, DWORD PTR $T2[esp+184]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN194@PseudoEPZS
$LN193@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi
	shl	edx, 2
	and	eax, 3

; 68   :       nX >>= NPELL2;

	sar	edi, 2

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN394@PseudoEPZS:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	mov	edi, DWORD PTR _this$1$[esp+184]
	add	ecx, ebx
$LN194@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [edi+216], 0
	jne	SHORT $LN220@PseudoEPZS
	push	DWORD PTR [edi+180]
	mov	eax, DWORD PTR [edi+80]
	push	ecx
	push	DWORD PTR [edi+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN395@PseudoEPZS
$LN220@PseudoEPZS:
	push	ecx
	push	esi
	mov	ecx, edi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN395@PseudoEPZS:
	mov	ecx, eax

; 800  :     sad += saduv;

	add	ecx, DWORD PTR _saduv$2$[esp+184]

; 801  :     sad_t cost = sad + ((pglobal*(bigsad_t)sad) >> 8);

	mov	eax, ecx
	imul	DWORD PTR [edi+244]
	mov	ebx, eax
	shrd	ebx, edx, 8
	add	ebx, ecx
	sar	edx, 8

; 802  : 
; 803  :     if (cost < workarea.nMinCost || tryMany)

	cmp	ebx, DWORD PTR [esi+112]
	jl	SHORT $LN19@PseudoEPZS
	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN20@PseudoEPZS
$LN19@PseudoEPZS:

; 804  :     {
; 805  :       workarea.bestMV.x = workarea.globalMVPredictor.x;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+100], eax

; 806  :       workarea.bestMV.y = workarea.globalMVPredictor.y;

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [esi+104], eax

; 807  :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], ecx

; 808  :       workarea.nMinCost = cost;

	mov	DWORD PTR [esi+112], ebx

; 809  :     }
; 810  :     if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN20@PseudoEPZS

; 811  :     {
; 812  :       // refine around global
; 813  :       Refine(workarea);    // reset bestMV

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine

; 814  :       bestMVMany[1] = workarea.bestMV;    // save bestMV

	mov	eax, DWORD PTR [esi+108]
	movq	xmm0, QWORD PTR [esi+100]
	mov	DWORD PTR _bestMVMany$[esp+204], eax

; 815  :       nMinCostMany[1] = workarea.nMinCost;

	mov	eax, DWORD PTR [esi+112]
	movq	QWORD PTR _bestMVMany$[esp+196], xmm0
	mov	DWORD PTR _nMinCostMany$[esp+188], eax
$LN20@PseudoEPZS:

; 822  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	cmp	BYTE PTR [edi+122], 0
	je	$LN39@PseudoEPZS

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+20]

; 822  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	mov	ebp, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR _nVx$1$[esp+184], ebp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	cmp	ecx, 2
	jne	SHORT $LN226@PseudoEPZS
	mov	ecx, DWORD PTR [edi+164]
	mov	edx, eax
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _this$1$[esp+184], ecx
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+60]
	sar	edx, cl
	mov	DWORD PTR tv3266[esp+184], ecx
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR _nVx$1$[esp+184]
	mov	ecx, eax
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv3264[esp+184], eax
	mov	eax, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 1
	sar	edi, 1
	add	edx, edx
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	add	ecx, ebx
	mov	DWORD PTR tv3300[esp+184], ecx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	$LN397@PseudoEPZS
$LN226@PseudoEPZS:
	cmp	ecx, 1
	mov	ecx, DWORD PTR [edi+164]
	mov	DWORD PTR _this$1$[esp+184], ecx
	jne	SHORT $LN224@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	edx, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ebx, eax
	mov	ecx, DWORD PTR [edi+52]
	mov	eax, ebp
	mov	DWORD PTR tv3264[esp+184], ecx
	mov	ecx, DWORD PTR [edi+60]
	sar	ebx, cl
	add	ebx, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	DWORD PTR tv3266[esp+184], ecx
	mov	ecx, DWORD PTR [edi+52]
	sar	eax, cl
	add	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]
	mov	DWORD PTR tv3300[esp+184], ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN225@PseudoEPZS
$LN224@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ebp, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	mov	edx, eax
	mov	ecx, DWORD PTR [edi+60]
	mov	eax, DWORD PTR [esi+24]
	sar	edx, cl
	mov	DWORD PTR tv3266[esp+184], ecx
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edi+52]
	mov	edx, DWORD PTR _nVx$1$[esp+184]
	mov	ecx, eax
	mov	DWORD PTR tv3264[esp+184], eax
	mov	eax, DWORD PTR [esi+12]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1507 :   return (nPel == 2) ? pRefFrame->GetPlane(UPLANE)->GetAbsolutePointerPel <1>((workarea.x[1] << 1) + (nVx >> nLogxRatioUV), (workarea.y[1] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	and	eax, 3
	shl	edx, 2
	or	edx, eax
	sar	edi, 2
	mov	eax, DWORD PTR [ebp]
	shl	edi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	add	eax, ebx
	mov	DWORD PTR tv3300[esp+184], eax
$LN397@PseudoEPZS:
	mov	ebp, DWORD PTR _nVx$1$[esp+184]
	mov	edi, DWORD PTR _this$1$[esp+184]
$LN225@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [esi+120]
	cmp	eax, 2
	jne	SHORT $LN253@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR _this$1$[esp+184]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR tv3266[esp+184]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3264[esp+184]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+28]
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _nVx$1$[esp+184]
	mov	eax, DWORD PTR [esi+16]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edx+eax*2]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	mov	eax, edi
	add	edx, edx
	sar	edi, 1
	and	eax, 1
	shl	edi, cl
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	add	edx, edi
	mov	ebp, edx
	mov	DWORD PTR _nVx$1$[esp+184], edx
	add	ebp, ebx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN398@PseudoEPZS
$LN253@PseudoEPZS:
	cmp	eax, 1
	jne	SHORT $LN251@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+52]
	sar	ebp, cl
	add	ebp, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	shl	ebp, cl
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR [edi+60]
	sar	edx, cl
	add	edx, DWORD PTR [esi+28]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax]
	add	ebp, edx
	add	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	jmp	SHORT $LN252@PseudoEPZS
$LN251@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR _this$1$[esp+184]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	ecx, DWORD PTR tv3266[esp+184]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3264[esp+184]
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	ebp, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	mov	eax, DWORD PTR [esi+28]
	lea	ebx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _nVx$1$[esp+184]
	mov	eax, DWORD PTR [esi+16]
	sar	edx, cl
; File c:\github\mvtools\sources\mvplane.h

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1516 :   return (nPel == 2) ? pRefFrame->GetPlane(VPLANE)->GetAbsolutePointerPel <1>((workarea.x[2] << 1) + (nVx >> nLogxRatioUV), (workarea.y[2] << 1) + (nVy >> nLogyRatioUV)) :

	lea	edi, DWORD PTR [edx+eax*4]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
	mov	eax, edi
	shl	edx, 2
	and	eax, 3
	sar	edi, 2
	or	edx, eax

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	edi, cl
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, edi
	imul	ebx, DWORD PTR [ebp+12]
	lea	ebp, DWORD PTR [ebx+eax]
$LN398@PseudoEPZS:
	mov	edi, DWORD PTR _this$1$[esp+184]
$LN252@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 822  :     saduv = (chroma) ? SADCHROMA(workarea.pSrc[1], nSrcPitch[1], GetRefBlockU(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[1])

	push	DWORD PTR [edi+184]
	mov	eax, DWORD PTR [edi+100]
	push	DWORD PTR tv3300[esp+188]
	push	DWORD PTR [edi+172]
	push	DWORD PTR [esi+92]
	call	eax
	push	DWORD PTR [edi+188]
	mov	ecx, DWORD PTR [edi+100]
	mov	ebx, eax
	push	ebp
	push	DWORD PTR [edi+176]
	push	DWORD PTR [esi+96]
	call	ecx
	add	esp, 32					; 00000020H
	add	ebx, eax
	mov	DWORD PTR _saduv$3$[esp+184], ebx
	jmp	SHORT $LN40@PseudoEPZS
$LN39@PseudoEPZS:
	mov	DWORD PTR _saduv$3$[esp+184], 0
$LN40@PseudoEPZS:

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [edi+20]

; 823  :       + SADCHROMA(workarea.pSrc[2], nSrcPitch[2], GetRefBlockV(workarea, workarea.predictor.x, workarea.predictor.y), nRefPitch[2]) : 0;
; 824  :     sad = LumaSAD(workarea, GetRefBlock(workarea, workarea.predictor.x, workarea.predictor.y));

	mov	ebx, DWORD PTR [esi+120]
	mov	ecx, DWORD PTR [esi+116]

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	cmp	eax, 2
	jne	SHORT $LN280@PseudoEPZS
	mov	eax, DWORD PTR [edi+164]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ebx+eax*2]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	and	edx, 1
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	add	edx, edx
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edi, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 68   :       nX >>= NPELL2;

	sar	edi, 1
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN399@PseudoEPZS
$LN280@PseudoEPZS:
	cmp	eax, 1
	mov	eax, DWORD PTR [edi+164]
	jne	SHORT $LN278@PseudoEPZS
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+8]
	add	eax, ecx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [edx+52]
	shl	eax, cl
	mov	DWORD PTR $T1[esp+184], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR $T1[esp+184]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	add	eax, ebx
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	imul	eax, DWORD PTR [edx+12]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	jmp	SHORT $LN279@PseudoEPZS
$LN278@PseudoEPZS:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	ebp, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	mov	eax, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [esi+8]
	mov	edx, ebx
	and	edx, 3
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	shl	edx, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1498 :   return (nPel == 2) ? pRefFrame->GetPlane(YPLANE)->GetAbsolutePointerPel <1>((workarea.x[0] << 1) + nVx, (workarea.y[0] << 1) + nVy) :

	lea	edi, DWORD PTR [ecx+eax*4]
; File c:\github\mvtools\sources\mvplane.h

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 68   :       nX >>= NPELL2;

	sar	edi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN399@PseudoEPZS:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
	or	edx, eax
	mov	eax, DWORD PTR [ebp]
	imul	ebx, DWORD PTR [ebp+12]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, edi
	mov	edi, DWORD PTR _this$1$[esp+184]
	add	ecx, ebx
$LN279@PseudoEPZS:
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1629 :   return !dctmode ? SAD(workarea.pSrc[0], nSrcPitch[0], pRef0, nRefPitch[0]) : LumaSADx(workarea, pRef0);

	cmp	DWORD PTR [edi+216], 0
	jne	SHORT $LN305@PseudoEPZS
	push	DWORD PTR [edi+180]
	mov	eax, DWORD PTR [edi+80]
	push	ecx
	push	DWORD PTR [edi+168]
	push	DWORD PTR [esi+88]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN400@PseudoEPZS
$LN305@PseudoEPZS:
	push	ecx
	push	esi
	mov	ecx, edi
	call	?LumaSADx@PlaneOfBlocks@@AAEHAAVWorkingArea@1@PBE@Z ; PlaneOfBlocks::LumaSADx
$LN400@PseudoEPZS:
	mov	ecx, eax

; 825  :     sad += saduv;

	add	ecx, DWORD PTR _saduv$3$[esp+184]

; 826  :     cost = sad;
; 827  : 
; 828  :     if (cost < workarea.nMinCost || tryMany)

	cmp	ecx, DWORD PTR [esi+112]
	jl	SHORT $LN22@PseudoEPZS
	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN23@PseudoEPZS
$LN22@PseudoEPZS:

; 829  :     {
; 830  :       workarea.bestMV.x = workarea.predictor.x;

	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR [esi+100], eax

; 831  :       workarea.bestMV.y = workarea.predictor.y;

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [esi+104], eax

; 832  :       workarea.bestMV.sad = sad;

	mov	DWORD PTR [esi+108], ecx

; 833  :       workarea.nMinCost = cost;

	mov	DWORD PTR [esi+112], ecx

; 834  :     }
; 835  :   }
; 836  : 
; 837  :   if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN23@PseudoEPZS

; 838  :   {
; 839  :     // refine around predictor
; 840  :     Refine(workarea);    // reset bestMV

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine

; 841  :     bestMVMany[2] = workarea.bestMV;    // save bestMV

	mov	eax, DWORD PTR [esi+108]
	movq	xmm0, QWORD PTR [esi+100]
	mov	DWORD PTR _bestMVMany$[esp+216], eax

; 842  :     nMinCostMany[2] = workarea.nMinCost;

	mov	eax, DWORD PTR [esi+112]
	movq	QWORD PTR _bestMVMany$[esp+208], xmm0
	mov	DWORD PTR _nMinCostMany$[esp+192], eax
$LN23@PseudoEPZS:

; 843  :   }
; 844  : 
; 845  :   // then all the other predictors
; 846  :   int npred = (temporal) ? 5 : 4;

	mov	cl, BYTE PTR [edi+260]
	lea	ebp, DWORD PTR [esi+128]
	xor	eax, eax
	mov	BYTE PTR tv3305[esp+184], cl
	test	cl, cl
	setne	al
	add	eax, 4

; 847  : 
; 848  :   for (int i = 0; i < npred; i++)

	xor	ebx, ebx
	mov	DWORD PTR _npred$1$[esp+184], eax
	lea	eax, DWORD PTR _bestMVMany$[esp+220]
	mov	DWORD PTR tv3239[esp+184], eax
$LL4@PseudoEPZS:

; 849  :   {
; 850  :     if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN24@PseudoEPZS

; 851  :     {
; 852  :       workarea.nMinCost = verybigSAD + 1;

	mov	eax, DWORD PTR [edi+156]
	inc	eax
	mov	DWORD PTR [esi+112], eax
$LN24@PseudoEPZS:

; 853  :     }
; 854  :     CheckMV0(workarea, workarea.predictors[i].x, workarea.predictors[i].y);

	push	DWORD PTR [ebp+4]
	mov	ecx, edi
	push	DWORD PTR [ebp]
	push	esi
	call	?CheckMV0@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HH@Z ; PlaneOfBlocks::CheckMV0

; 855  :     if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN389@PseudoEPZS

; 856  :     {
; 857  :       // refine around predictor
; 858  :       Refine(workarea);    // reset bestMV

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine

; 859  :       bestMVMany[i + 3] = workarea.bestMV;    // save bestMV

	mov	ecx, DWORD PTR tv3239[esp+184]
	movq	xmm0, QWORD PTR [esi+100]
	mov	eax, DWORD PTR [esi+108]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax

; 860  :       nMinCostMany[i + 3] = workarea.nMinCost;

	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR _nMinCostMany$[esp+ebx*4+196], eax
	jmp	SHORT $LN2@PseudoEPZS
$LN389@PseudoEPZS:
	mov	ecx, DWORD PTR tv3239[esp+184]
$LN2@PseudoEPZS:

; 847  : 
; 848  :   for (int i = 0; i < npred; i++)

	inc	ebx
	add	ecx, 12					; 0000000cH
	add	ebp, 12					; 0000000cH
	mov	DWORD PTR tv3239[esp+184], ecx
	cmp	ebx, DWORD PTR _npred$1$[esp+184]
	jl	SHORT $LL4@PseudoEPZS

; 861  :     }
; 862  :   }	// for i
; 863  : 
; 864  :   if (tryMany)

	cmp	BYTE PTR [edi+261], 0
	je	SHORT $LN26@PseudoEPZS

; 865  :   {
; 866  :     // select best of multi best
; 867  :     workarea.nMinCost = verybigSAD + 1;

	mov	eax, DWORD PTR [edi+156]
	lea	edx, DWORD PTR _bestMVMany$[esp+184]
	xor	ecx, ecx
	inc	eax
	cmp	BYTE PTR tv3305[esp+184], cl
	mov	DWORD PTR [esi+112], eax
	setne	cl
	add	ecx, 7
	mov	DWORD PTR tv3256[esp+184], ecx

; 868  :     for (int i = 0; i < npred + 3; i++)

	xor	ecx, ecx
	mov	ebp, DWORD PTR tv3256[esp+184]
$LL7@PseudoEPZS:

; 869  :     {
; 870  :       if (nMinCostMany[i] < workarea.nMinCost)

	mov	ebx, DWORD PTR _nMinCostMany$[esp+ecx*4+184]
	cmp	ebx, eax
	jge	SHORT $LN5@PseudoEPZS

; 871  :       {
; 872  :         workarea.bestMV = bestMVMany[i];

	movq	xmm0, QWORD PTR [edx]
	mov	eax, DWORD PTR [edx+8]
	movq	QWORD PTR [esi+100], xmm0
	mov	DWORD PTR [esi+108], eax
	mov	eax, ebx
$LN5@PseudoEPZS:

; 868  :     for (int i = 0; i < npred + 3; i++)

	inc	ecx
	add	edx, 12					; 0000000cH
	cmp	ecx, ebp
	jl	SHORT $LL7@PseudoEPZS
	mov	DWORD PTR [esi+112], eax

; 873  :         workarea.nMinCost = nMinCostMany[i];
; 874  :       }
; 875  :     }
; 876  :   }
; 877  :   else

	jmp	SHORT $LN27@PseudoEPZS
$LN26@PseudoEPZS:

; 878  :   {
; 879  :     // then, we refine, according to the search type
; 880  :     Refine(workarea);

	push	esi
	mov	ecx, edi
	call	?Refine@PlaneOfBlocks@@AAEXAAVWorkingArea@1@@Z ; PlaneOfBlocks::Refine
$LN27@PseudoEPZS:

; 889  :     && foundSAD > (badSAD + badSAD*badcount / BADCOUNT_LIMIT))

	mov	eax, DWORD PTR [esi+80]
	imul	eax, DWORD PTR [edi]
	mov	ebp, DWORD PTR [esi+108]
	mov	DWORD PTR _foundSAD$1$[esp+184], ebp
	inc	eax
	cmp	DWORD PTR [esi+40], eax
	jle	$LN12@PseudoEPZS
	mov	ecx, DWORD PTR [edi+248]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 93   : 	return (T (_val));

	lea	ebx, DWORD PTR [edi+256]
	mov	eax, DWORD PTR [ebx]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 889  :     && foundSAD > (badSAD + badSAD*badcount / BADCOUNT_LIMIT))

	imul	eax, ecx
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	add	eax, ecx
	cmp	ebp, eax
	jle	$LN12@PseudoEPZS
	npad	4
$LL320@PseudoEPZS:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [ebx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ebx], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL320@PseudoEPZS
; File c:\github\mvtools\sources\planeofblocks.cpp

; 909  :     if (badrange > 0) // UMH

	mov	edx, DWORD PTR [edi+252]
	test	edx, edx
	jle	SHORT $LN402@PseudoEPZS

; 910  :     {
; 911  : 
; 912  :       //			UMHSearch(badrange*nPel, workarea.bestMV.x, workarea.bestMV.y);
; 913  : 
; 914  :       //			if (workarea.bestMV.sad > foundSAD/2)
; 915  :       {
; 916  :         // rathe good is not found, lets try around zero
; 917  : //				UMHSearch(workarea, badSADRadius, abs(mvx0)%4 - 2, abs(mvy0)%4 - 2);
; 918  :         UMHSearch(workarea, badrange*nPel, 0, 0);

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, edi
	push	0
	imul	eax, edx
	push	0
	push	eax
	push	esi
	call	?UMHSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHH@Z ; PlaneOfBlocks::UMHSearch
	jmp	SHORT $LN373@PseudoEPZS
$LN402@PseudoEPZS:

; 919  :       }
; 920  :     }
; 921  : 
; 922  :     else if (badrange < 0) // ESA

	jns	SHORT $LN373@PseudoEPZS

; 923  :     {
; 924  :       /*
; 925  :             workarea.bestMV.x = mvx0; // restore  for comparing
; 926  :             workarea.bestMV.y = mvy0;
; 927  :             workarea.bestMV.sad = msad0;
; 928  :             workarea.nMinCost = mcost0;
; 929  : 
; 930  :             int mvx = workarea.bestMV.x; // store to not move the search center!
; 931  :             int mvy = workarea.bestMV.y;
; 932  :             int msad = workarea.bestMV.sad;
; 933  : 
; 934  :             for ( int i = 1; i < -badrange*nPel; i+=nPel )// at radius
; 935  :             {
; 936  :               ExpandingSearch(i, nPel, mvx, mvy);
; 937  :               if (workarea.bestMV.sad < foundSAD/4)
; 938  :               {
; 939  :                 break; // stop search
; 940  :               }
; 941  :             }
; 942  : 
; 943  :             if (workarea.bestMV.sad > foundSAD/2 && abs(mvx)+abs(mvy) > badSADRadius/2)
; 944  :             {
; 945  :               // rathe good is not found, lets try around zero
; 946  :               mvx = 0; // store to not move the search center!
; 947  :               mvy = 0;
; 948  :       */
; 949  :       for (int i = 1; i < -badrange*nPel; i += nPel)// at radius

	mov	ebx, DWORD PTR [edi+20]
	mov	ebp, 1
	mov	ecx, ebx
	imul	ecx, edx
	neg	ecx
	cmp	ecx, ebp
	jle	SHORT $LN373@PseudoEPZS
	mov	eax, DWORD PTR _foundSAD$1$[esp+184]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv3248[esp+184], eax
$LL10@PseudoEPZS:

; 950  :       {
; 951  :         ExpandingSearch(workarea, i, nPel, 0, 0);

	push	0
	push	0
	push	ebx
	push	ebp
	push	esi
	mov	ecx, edi
	call	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch

; 952  :         if (workarea.bestMV.sad < foundSAD / 4)

	mov	eax, DWORD PTR tv3248[esp+184]
	cmp	DWORD PTR [esi+108], eax
	jl	SHORT $LN373@PseudoEPZS

; 923  :     {
; 924  :       /*
; 925  :             workarea.bestMV.x = mvx0; // restore  for comparing
; 926  :             workarea.bestMV.y = mvy0;
; 927  :             workarea.bestMV.sad = msad0;
; 928  :             workarea.nMinCost = mcost0;
; 929  : 
; 930  :             int mvx = workarea.bestMV.x; // store to not move the search center!
; 931  :             int mvy = workarea.bestMV.y;
; 932  :             int msad = workarea.bestMV.sad;
; 933  : 
; 934  :             for ( int i = 1; i < -badrange*nPel; i+=nPel )// at radius
; 935  :             {
; 936  :               ExpandingSearch(i, nPel, mvx, mvy);
; 937  :               if (workarea.bestMV.sad < foundSAD/4)
; 938  :               {
; 939  :                 break; // stop search
; 940  :               }
; 941  :             }
; 942  : 
; 943  :             if (workarea.bestMV.sad > foundSAD/2 && abs(mvx)+abs(mvy) > badSADRadius/2)
; 944  :             {
; 945  :               // rathe good is not found, lets try around zero
; 946  :               mvx = 0; // store to not move the search center!
; 947  :               mvy = 0;
; 948  :       */
; 949  :       for (int i = 1; i < -badrange*nPel; i += nPel)// at radius

	mov	ebx, DWORD PTR [edi+20]
	add	ebp, ebx
	mov	eax, DWORD PTR [edi+252]
	imul	eax, ebx
	neg	eax
	cmp	ebp, eax
	jl	SHORT $LL10@PseudoEPZS
$LN373@PseudoEPZS:

; 953  :         {
; 954  :           break; // stop search if rathe good is found
; 955  :         }
; 956  :       }	// for i
; 957  :     }	// badrange < 0
; 958  : 
; 959  :     int mvx = workarea.bestMV.x; // refine in small area
; 960  :     int mvy = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+104]

; 961  :     for (int i = 1; i < nPel; i++)// small radius

	mov	ebx, 1
	mov	ebp, DWORD PTR [esi+100]
	mov	DWORD PTR _mvy$1$[esp+184], eax
	cmp	DWORD PTR [edi+20], ebx
	jle	SHORT $LN12@PseudoEPZS
$LL13@PseudoEPZS:

; 962  :     {
; 963  :       ExpandingSearch(workarea, i, 1, mvx, mvy);

	push	eax
	push	ebp
	push	1
	push	ebx
	push	esi
	mov	ecx, edi
	call	?ExpandingSearch@PlaneOfBlocks@@AAEXAAVWorkingArea@1@HHHH@Z ; PlaneOfBlocks::ExpandingSearch
	mov	eax, DWORD PTR _mvy$1$[esp+184]
	inc	ebx
	cmp	ebx, DWORD PTR [edi+20]
	jl	SHORT $LL13@PseudoEPZS
$LN12@PseudoEPZS:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 969  :   vectors[workarea.blkIdx].x = workarea.bestMV.x;

	mov	ecx, DWORD PTR [edi+108]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 969  :   vectors[workarea.blkIdx].x = workarea.bestMV.x;

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [ecx+edx*4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 970  :   vectors[workarea.blkIdx].y = workarea.bestMV.y;

	mov	ecx, DWORD PTR [edi+108]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 970  :   vectors[workarea.blkIdx].y = workarea.bestMV.y;

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [ecx+edx*4+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+40]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 971  :   vectors[workarea.blkIdx].sad = workarea.bestMV.sad;

	mov	ecx, DWORD PTR [edi+108]

; 974  : }

	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 971  :   vectors[workarea.blkIdx].sad = workarea.bestMV.sad;

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [ecx+edx*4+8], eax

; 972  : 
; 973  :   workarea.planeSAD += workarea.bestMV.sad; // todo PF check int overflow

	mov	eax, DWORD PTR [esi+108]
	cdq
	add	DWORD PTR [esi+64], eax
	adc	DWORD PTR [esi+68], edx

; 974  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 168				; 000000a8H
	ret	4
??$PseudoEPZSearch@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ENDP ; PlaneOfBlocks::PseudoEPZSearch<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@PAVDCTClass@@@std@@YAPAPAVDCTClass@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVDCTClass@@@std@@YAPAPAVDCTClass@@PAPAV1@@Z PROC ; std::_Unfancy<DCTClass *>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@PAVDCTClass@@@std@@YAPAPAVDCTClass@@PAPAV1@@Z ENDP ; std::_Unfancy<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVDCTClass@@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAVDCTClass@@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@@Z PROC ; std::_Wrap_alloc<std::allocator<DCTClass *> >::destroy<DCTClass *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAVDCTClass@@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@@Z ENDP ; std::_Wrap_alloc<std::allocator<DCTClass *> >::destroy<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVDCTClass@@@std@@YAPBQAVDCTClass@@ABQAV1@@Z
_TEXT	SEGMENT
??$addressof@QAVDCTClass@@@std@@YAPBQAVDCTClass@@ABQAV1@@Z PROC ; std::addressof<DCTClass * const>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@QAVDCTClass@@@std@@YAPBQAVDCTClass@@ABQAV1@@Z ENDP ; std::addressof<DCTClass * const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVDCTClass@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVDCTClass@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	8
??$construct@PAVDCTClass@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVDCTClass@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVDCTClass@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * const &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	8
??$construct@PAVDCTClass@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAEXPAPAVDCTClass@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAEIV?$AllocAlign@E$0BA@@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAEIV?$AllocAlign@E$0BA@@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<unsigned char *,unsigned int,AllocAlign<unsigned char,16> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	edx
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,
; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	ret	0
??$_Uninitialized_default_fill_n@PAEIV?$AllocAlign@E$0BA@@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<unsigned char *,unsigned int,AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<VECTOR *,unsigned int,std::allocator<VECTOR> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ecx

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<VECTOR *,unsigned int,std::allocator<VECTOR> >

; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Uninitialized_default_fill_n@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<VECTOR *,unsigned int,std::allocator<VECTOR> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<DCTClass *> >,std::_Vector_val<std::_Simple_types<DCTClass *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVDCTClass@@@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEPAPAVDCTClass@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVDCTClass@@@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEPAPAVDCTClass@@PAPAV2@00@Z PROC ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Umove<DCTClass * *>, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[esp-4]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Ptr$[esp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	ret	12					; 0000000cH
??$_Umove@PAPAVDCTClass@@@?$vector@PAVDCTClass@@V?$allocator@PAVDCTClass@@@std@@@std@@IAEPAPAVDCTClass@@PAPAV2@00@Z ENDP ; std::vector<DCTClass *,std::allocator<DCTClass *> >::_Umove<DCTClass * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<AllocAlign<unsigned char,16> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<VECTOR> >,std::_Vector_val<std::_Simple_types<VECTOR> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAVDCTClass@@@std@@PAPAVDCTClass@@@std@@YAXPAPAVDCTClass@@0AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@PAVDCTClass@@@std@@PAPAVDCTClass@@@std@@YAXPAPAVDCTClass@@0AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<DCTClass *>,DCTClass * *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVDCTClass@@@std@@PAPAVDCTClass@@@std@@YAXPAPAVDCTClass@@0AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<DCTClass *>,DCTClass * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAE@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAE@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEPAEPAE00@Z PROC ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Umove<unsigned char *>, COMDAT
; _this$dead$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp]
	push	ecx
	push	DWORD PTR $T1[esp+4]
	push	ecx
	push	DWORD PTR __Ptr$[esp+12]
	mov	ecx, DWORD PTR __First$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
??$_Umove@PAE@?$vector@EV?$AllocAlign@E$0BA@@@@std@@IAEPAEPAE00@Z ENDP ; std::vector<unsigned char,AllocAlign<unsigned char,16> >::_Umove<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$AllocAlign@E$0BA@@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$AllocAlign@E$0BA@@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z PROC ; std::_Destroy_range<AllocAlign<unsigned char,16>,unsigned char *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$AllocAlign@E$0BA@@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z ENDP ; std::_Destroy_range<AllocAlign<unsigned char,16>,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@UVECTOR@@@std@@PAUVECTOR@@@std@@YAXPAUVECTOR@@0AAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@UVECTOR@@@std@@PAUVECTOR@@@std@@YAXPAUVECTOR@@0AAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<VECTOR>,VECTOR *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@UVECTOR@@@std@@PAUVECTOR@@@std@@YAXPAUVECTOR@@0AAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<VECTOR>,VECTOR *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$AllocAlign@E$0BA@@@@_Alloc_max_size@std@@SAIHABV?$AllocAlign@E$0BA@@@@Z
_TEXT	SEGMENT
??$_Fn@V?$AllocAlign@E$0BA@@@@_Alloc_max_size@std@@SAIHABV?$AllocAlign@E$0BA@@@@Z PROC ; std::_Alloc_max_size::_Fn<AllocAlign<unsigned char,16> >, COMDAT
; ___formal$dead$ = ecx
; __Al$dead$ = edx

; 519  : 		return (_Al.max_size());

	or	eax, -1

; 520  : 		}

	ret	0
??$_Fn@V?$AllocAlign@E$0BA@@@@_Alloc_max_size@std@@SAIHABV?$AllocAlign@E$0BA@@@@Z ENDP ; std::_Alloc_max_size::_Fn<AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAE@XZ ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::~ObjPool<PlaneOfBlocks::WorkingArea>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	384					; 00000180H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z ENDP ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
;	COMDAT ??_G?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 62   : {

	mov	DWORD PTR [esi], OFFSET ??_7?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@

; 63   : 	clear_all ();

	call	?clear_all@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::clear_all
; File c:\github\mvtools\sources\conc\mutex.hpp

; 46   : 	::DeleteCriticalSection (&_crit_sec);

	lea	eax, DWORD PTR [esi+296]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
	test	BYTE PTR ___flags$[esp], 1
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [esi+8], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi+16], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	je	SHORT $LN16@scalar
	push	320					; 00000140H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN16@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@UAEPAXI@Z ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.h
;	COMDAT ??1?$AioAdd@_J@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$AioAdd@_J@conc@@UAE@XZ PROC			; conc::AioAdd<__int64>::~AioAdd<__int64>, COMDAT
; _this$ = ecx

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$AioAdd@_J@conc@@6B@
	ret	0
??1?$AioAdd@_J@conc@@UAE@XZ ENDP			; conc::AioAdd<__int64>::~AioAdd<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?access@?$MTSlicer_Access@VPlaneOfBlocks@@V1@@@SAPAVPlaneOfBlocks@@PAV2@@Z
_TEXT	SEGMENT
?access@?$MTSlicer_Access@VPlaneOfBlocks@@V1@@@SAPAVPlaneOfBlocks@@PAV2@@Z PROC ; MTSlicer_Access<PlaneOfBlocks,PlaneOfBlocks>::access, COMDAT
; _ptr$ = ecx

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	eax, ecx
	ret	0
?access@?$MTSlicer_Access@VPlaneOfBlocks@@V1@@@SAPAVPlaneOfBlocks@@PAV2@@Z ENDP ; MTSlicer_Access<PlaneOfBlocks,PlaneOfBlocks>::access
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<DCTClass *> >::_Vector_val<std::_Simple_types<DCTClass *> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVDCTClass@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<DCTClass *> >::_Vector_val<std::_Simple_types<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<DCTClass *> >::_Wrap_alloc<std::allocator<DCTClass *> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<DCTClass *> >::_Wrap_alloc<std::allocator<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::_Wrap_alloc<AllocAlign<unsigned char,16> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::_Wrap_alloc<AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<VECTOR> >::_Vector_val<std::_Simple_types<VECTOR> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@UVECTOR@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<VECTOR> >::_Vector_val<std::_Simple_types<VECTOR> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<VECTOR> >::_Wrap_alloc<std::allocator<VECTOR> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<VECTOR> >::_Wrap_alloc<std::allocator<VECTOR> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEABUVECTOR@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEABUVECTOR@@I@Z PROC ; std::vector<VECTOR,std::allocator<VECTOR> >::operator[], COMDAT
; _this$ = ecx

; 1215 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1216 : 		if (size() <= _Pos)
; 1217 : 			{	// report error
; 1218 : 			_DEBUG_ERROR("vector subscript out of range");
; 1219 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1220 : 			}
; 1221 : 
; 1222 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1223 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1224 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1225 : 
; 1226 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 1227 : 		}

	ret	4
??A?$vector@UVECTOR@@V?$allocator@UVECTOR@@@std@@@std@@QBEABUVECTOR@@I@Z ENDP ; std::vector<VECTOR,std::allocator<VECTOR> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.h
;	COMDAT ??_G?$AioAdd@_J@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$AioAdd@_J@conc@@UAEPAXI@Z PROC			; conc::AioAdd<__int64>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$AioAdd@_J@conc@@6B@
	je	SHORT $LN7@scalar
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$AioAdd@_J@conc@@UAEPAXI@Z ENDP			; conc::AioAdd<__int64>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVDCTClass@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVDCTClass@@@std@@QAE@XZ PROC		; std::allocator<DCTClass *>::allocator<DCTClass *>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@PAVDCTClass@@@std@@QAE@XZ ENDP		; std::allocator<DCTClass *>::allocator<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\allocalign.h
;	COMDAT ??0?$AllocAlign@E$0BA@@@QAE@XZ
_TEXT	SEGMENT
??0?$AllocAlign@E$0BA@@@QAE@XZ PROC			; AllocAlign<unsigned char,16>::AllocAlign<unsigned char,16>, COMDAT
; _this$ = ecx

; 54   : 						AllocAlign () {}

	mov	eax, ecx
	ret	0
??0?$AllocAlign@E$0BA@@@QAE@XZ ENDP			; AllocAlign<unsigned char,16>::AllocAlign<unsigned char,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UVECTOR@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UVECTOR@@@std@@QAE@XZ PROC		; std::allocator<VECTOR>::allocator<VECTOR>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@UVECTOR@@@std@@QAE@XZ ENDP		; std::allocator<VECTOR>::allocator<VECTOR>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objfactoryinterface.hpp
;	COMDAT ?create@?$ObjFactoryInterface@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ
_TEXT	SEGMENT
?create@?$ObjFactoryInterface@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ PROC ; conc::ObjFactoryInterface<DCTClass>::create, COMDAT
; _this$ = ecx

; 54   : {

	mov	eax, DWORD PTR [ecx]

; 55   : 	return (do_create ());

	jmp	DWORD PTR [eax+4]
?create@?$ObjFactoryInterface@VDCTClass@@@conc@@QAEPAVDCTClass@@XZ ENDP ; conc::ObjFactoryInterface<DCTClass>::create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?redirect_task@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z
_TEXT	SEGMENT
_dispatcher_ptr$ = 8					; size = 4
_data_ptr$ = 12						; size = 4
?redirect_task@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z PROC ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::redirect_task, COMDAT

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	edx, DWORD PTR _data_ptr$[esp-4]

; 278  : 	assert (proc_ptr != 0);
; 279  : 
; 280  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	push	edx
	mov	eax, DWORD PTR [edx+4]

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	ecx, DWORD PTR [edx]

; 268  : 	TaskData *		td_ptr   = reinterpret_cast <TaskData *> (data_ptr);
; 269  : 	assert (td_ptr != 0);
; 270  : 	assert (td_ptr->_glob_data_ptr != 0);
; 271  : 	assert (td_ptr->_slicer_ptr != 0);
; 272  : 
; 273  : 	T *				this_ptr =
; 274  : 		MTSlicer_Access <T, GD>::access (td_ptr->_glob_data_ptr);
; 275  : 	assert (this_ptr != 0);
; 276  : 
; 277  : 	ProcPtr			proc_ptr = td_ptr->_slicer_ptr->_proc_ptr;

	mov	eax, DWORD PTR [eax+8]

; 278  : 	assert (proc_ptr != 0);
; 279  : 
; 280  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	call	eax

; 281  : }

	ret	0
?redirect_task@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ENDP ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::redirect_task
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\allocalign.hpp
;	COMDAT ?max_size@?$AllocAlign@E$0BA@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$AllocAlign@E$0BA@@@QBEIXZ PROC		; AllocAlign<unsigned char,16>::max_size, COMDAT
; _this$dead$ = ecx

; 104  : 	CHECK_COMPILE_TIME (Unsigned, (static_cast <size_type> (-1) > 0));
; 105  : 
; 106  : 	return (static_cast <size_type> (-1) / sizeof (T));

	or	eax, -1

; 107  : }

	ret	0
?max_size@?$AllocAlign@E$0BA@@@QBEIXZ ENDP		; AllocAlign<unsigned char,16>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objfactoryinterface.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\objfactoryinterface.hpp
;	COMDAT ?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ PROC ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::create, COMDAT
; _this$ = ecx

; 54   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, OFFSET ??_7WorkingAreaFactory@PlaneOfBlocks@@6B@
	jne	SHORT $LN4@create
; File c:\github\mvtools\sources\planeofblocks.cpp

; 2523 :   return (new WorkingArea(

	push	456					; 000001c8H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+32]
	push	ecx
	push	DWORD PTR [esi+24]
	push	ecx
	push	DWORD PTR [esi+16]
	mov	ecx, eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	call	??0WorkingArea@PlaneOfBlocks@@QAE@HHHHHHHHH@Z ; PlaneOfBlocks::WorkingArea::WorkingArea
	pop	esi
; File c:\github\mvtools\sources\conc\objfactoryinterface.hpp

; 56   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@create:

; 55   : 	return (do_create ());

	call	edx

; 56   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ$0:
	push	456					; 000001c8H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?create@?$ObjFactoryInterface@VWorkingArea@PlaneOfBlocks@@@conc@@QAEPAVWorkingArea@PlaneOfBlocks@@XZ ENDP ; conc::ObjFactoryInterface<PlaneOfBlocks::WorkingArea>::create
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?cleanup@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ
_TEXT	SEGMENT
?cleanup@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::cleanup, COMDAT
; _this$ = ecx

; 226  : {

	push	esi
	mov	esi, ecx

; 227  : 	const int		count_free = delete_obj_stack  (_stack_free, false);

	push	0
	lea	eax, DWORD PTR [esi+16]
	push	eax
	call	?delete_obj_stack@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@AAEHAAV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::delete_obj_stack

; 228  : 	const int		count_all  = delete_obj_stack  (_stack_all,  true);

	push	1
	lea	eax, DWORD PTR [esi+40]
	mov	ecx, esi
	push	eax
	call	?delete_obj_stack@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@AAEHAAV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::delete_obj_stack
	pop	esi

; 229  : 
; 230  : 	// False would mean that some cells are still out, in use.
; 231  : 	assert (count_free == count_all);
; 232  : }

	ret	0
?cleanup@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ ENDP ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::cleanup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicptr.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ??0?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::CellPool<PlaneOfBlocks::WorkingArea *>, COMDAT
; _this$ = ecx

; 49   : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	xorps	xmm0, xmm0
	push	256					; 00000100H
	push	0
	mov	DWORD PTR _this$[esp+20], edi
	mov	DWORD PTR [edi], OFFSET ??_7?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
	lea	esi, DWORD PTR [edi+32]
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 41   : {

	mov	DWORD PTR [edi+8], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 41   : {

	mov	DWORD PTR [edi+16], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	movq	QWORD PTR [edi+24], xmm0
	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+28]

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+24], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+28], 0

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+24], 0
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 45   : ,	_zone_list ()

	push	esi
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+28], 0
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 45   : ,	_zone_list ()

	call	_memset
	add	esp, 12					; 0000000cH
	mov	ecx, 64					; 00000040H
	mov	eax, esi
$LL19@CellPool:
; File c:\github\mvtools\sources\conc\atomicptr.hpp

; 43   : :	_ptr ()

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+4]
	sub	ecx, 1
	jne	SHORT $LL19@CellPool
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 63   : :	_val (val)

	mov	DWORD PTR [edi+288], ecx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 48   : ,	_alloc_mutex ()

	lea	eax, DWORD PTR [edi+296]
	xorps	xmm0, xmm0
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 63   : :	_val (val)

	mov	DWORD PTR [edi+292], ecx
; File c:\github\mvtools\sources\conc\mutex.hpp

; 37   : :	_crit_sec ()

	movups	XMMWORD PTR [eax], xmm0

; 38   : {
; 39   : 	::InitializeCriticalSection (&_crit_sec);

	push	eax
	movq	QWORD PTR [eax+16], xmm0
	call	DWORD PTR __imp__InitializeCriticalSection@4
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 63   : :	_val (val)

	mov	ecx, 64					; 00000040H
$LL4@CellPool:
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [esi], eax
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 52   : 	for (int zone_index = 0; zone_index < MAX_NBR_ZONES; ++zone_index)

	add	esi, 4
	sub	ecx, 1
	jne	SHORT $LL4@CellPool

; 53   : 	{
; 54   : 		_zone_list [zone_index] = 0;
; 55   : 	}
; 56   : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ecx
	ret	0
??0?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::CellPool<PlaneOfBlocks::WorkingArea *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?clear_all@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ
_TEXT	SEGMENT
?clear_all@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::clear_all, COMDAT
; _this$ = ecx

; 72   : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
$LL2@clear_all:

; 73   : #if !defined (NDEBUG)
; 74   : 	size_t nbr_total_cells = compute_total_size_for_zones (_nbr_zones);
; 75   : 	
; 76   : 	assert (_nbr_avail_cells == nbr_total_cells);
; 77   : #endif
; 78   : 	
; 79   : 	while (_cell_stack.pop () != 0)

	lea	ecx, DWORD PTR [ebp+8]
	call	?pop@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::pop
	test	eax, eax
	jne	SHORT $LL2@clear_all

; 84   : 	for (int zone_index = 0; zone_index < _nbr_zones; ++zone_index)

	xor	edi, edi
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 93   : 	return (T (_val));

	lea	ebx, DWORD PTR [ebp+292]
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 84   : 	for (int zone_index = 0; zone_index < _nbr_zones; ++zone_index)

	cmp	DWORD PTR [ebx], edi
	jle	SHORT $LN5@clear_all
	lea	esi, DWORD PTR [ebp+32]
$LL6@clear_all:

; 85   : 	{
; 86   : 		AtomicPtr <CellType> &	zone_ptr_ref = _zone_list [zone_index];
; 87   : 		CellType *		zone_ptr = zone_ptr_ref;

	mov	eax, DWORD PTR [esi]

; 88   : 		if (zone_ptr != 0)

	test	eax, eax
	je	SHORT $LN4@clear_all

; 89   : 		{
; 90   : 			delete [] zone_ptr;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [esi], eax
$LN4@clear_all:
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 84   : 	for (int zone_index = 0; zone_index < _nbr_zones; ++zone_index)

	inc	edi
	add	esi, 4
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL6@clear_all
$LN5@clear_all:
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [ebx], eax
	xor	ecx, ecx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 95   : 	_nbr_avail_cells = 0;

	lea	eax, DWORD PTR [ebp+288]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xchg	DWORD PTR [eax], ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 96   : }

	ret	0
?clear_all@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXXZ ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::clear_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?expand_to@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXI@Z
_TEXT	SEGMENT
_total_size$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
_nbr_cells$ = 8						; size = 4
?expand_to@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXI@Z PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::expand_to, COMDAT
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 107  : 	size_t			total_size = 0;
; 108  : 	int				zone_index = 0;

	xor	ebx, ebx
	mov	DWORD PTR _this$1$[esp+20], ecx
	mov	esi, 64					; 00000040H
	mov	DWORD PTR _total_size$1$[esp+20], 0
	push	edi

; 109  : 	while (total_size < nbr_cells && zone_index < MAX_NBR_ZONES)

	cmp	DWORD PTR _nbr_cells$[ebp], ebx
	jbe	SHORT $LN3@expand_to

; 104  : 	assert (nbr_cells > 0);
; 105  : 
; 106  : 	size_t			cur_size = BASE_SIZE;

	lea	edi, DWORD PTR [ecx+32]
$LL2@expand_to:

; 109  : 	while (total_size < nbr_cells && zone_index < MAX_NBR_ZONES)

	cmp	ebx, 64					; 00000040H
	jge	SHORT $LN3@expand_to

; 110  : 	{
; 111  : 		AtomicPtr <CellType> &	zone_ptr_ref = _zone_list [zone_index];
; 112  : 		CellType *		zone_ptr = zone_ptr_ref;

	mov	eax, DWORD PTR [edi]

; 113  : 		if (zone_ptr == 0)

	test	eax, eax
	jne	SHORT $LN4@expand_to

; 114  : 		{
; 115  : 			allocate_zone (zone_index, cur_size, zone_ptr_ref);

	push	edi
	push	esi
	push	ecx
	call	?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::allocate_zone
	mov	ecx, DWORD PTR _this$1$[esp+24]
$LN4@expand_to:

; 116  : 		}
; 117  : 
; 118  : 		total_size += cur_size;

	mov	eax, DWORD PTR _total_size$1$[esp+24]

; 119  : 		cur_size = compute_grown_size (cur_size);
; 120  : 		++ zone_index;

	inc	ebx
	add	eax, esi
	add	edi, 4

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	esi, DWORD PTR [esi+esi*2]

; 116  : 		}
; 117  : 
; 118  : 		total_size += cur_size;

	mov	DWORD PTR _total_size$1$[esp+24], eax

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	shr	esi, 1

; 109  : 	while (total_size < nbr_cells && zone_index < MAX_NBR_ZONES)

	cmp	eax, DWORD PTR _nbr_cells$[ebp]
	jb	SHORT $LL2@expand_to
$LN3@expand_to:

; 121  : 	}
; 122  : 
; 123  : 	AioMax <int>	ftor (zone_index);
; 124  : 	AtomicIntOp::exec (_nbr_zones, ftor);

	lea	esi, DWORD PTR [ecx+292]
	npad	4
$LL22@expand_to:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	edx, ebx
	mov	ecx, edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	ecx, ebx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL22@expand_to
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 125  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?expand_to@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXI@Z ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::expand_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?take_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z
_TEXT	SEGMENT
_zone_index$1$ = -12					; size = 4
_total_size$2$ = -8					; size = 4
_this$1$ = -4						; size = 4
_autogrow_flag$dead$ = 8				; size = 1
?take_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::take_cell, COMDAT
; _this$ = ecx

; 132  : {

	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
	push	edi

; 133  : 	CellType *		cell_ptr = 0;
; 134  : 	
; 135  : 	const int		nbr_zones = _nbr_zones;

	mov	esi, DWORD PTR [ebx+292]
	lea	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _this$1$[esp+32], ebx
$LL4@take_cell:

; 136  : 
; 137  : 	do
; 138  : 	{
; 139  : 		cell_ptr = _cell_stack.pop ();

	mov	ecx, eax
	call	?pop@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::pop
	mov	ebp, eax

; 140  : 
; 141  : 		if ((cell_ptr == 0) && autogrow_flag && (nbr_zones < MAX_NBR_ZONES))

	test	ebp, ebp
	jne	SHORT $LN58@take_cell
	cmp	esi, 64					; 00000040H
	jge	SHORT $LN61@take_cell

; 229  : 	size_t			cur_size = BASE_SIZE;

	lea	ecx, DWORD PTR [eax+64]

; 230  : 	size_t			total_size = 0;

	xor	edx, edx

; 142  : 		{
; 143  : 			const size_t	new_size = compute_total_size_for_zones (nbr_zones + 1);

	lea	eax, DWORD PTR [esi+1]

; 230  : 	size_t			total_size = 0;

	mov	DWORD PTR _total_size$2$[esp+32], edx
	xor	edi, edi

; 231  : 	int				zone_index = 0;
; 232  : 	while (zone_index < nbr_zones)

	mov	DWORD PTR _zone_index$1$[esp+32], edx
	xor	ebx, ebx
	cmp	eax, 2
	jl	SHORT $LC53@take_cell
	lea	edx, DWORD PTR [esi-1]
	shr	edx, 1
	inc	edx
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR _zone_index$1$[esp+32], eax
	npad	2
$LL54@take_cell:

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	eax, DWORD PTR [ecx+ecx*2]

; 234  : 		total_size += cur_size;

	add	edi, ecx

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	shr	eax, 1

; 234  : 		total_size += cur_size;

	add	ebx, eax

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	ecx, DWORD PTR [eax+eax*2]
	shr	ecx, 1
	sub	edx, 1
	jne	SHORT $LL54@take_cell
	mov	edx, DWORD PTR _total_size$2$[esp+32]
	lea	eax, DWORD PTR [esi+1]
$LC53@take_cell:

; 232  : 	while (zone_index < nbr_zones)

	cmp	DWORD PTR _zone_index$1$[esp+32], eax
	lea	eax, DWORD PTR [ebx+edi]

; 144  : 			expand_to (new_size);

	mov	ebx, DWORD PTR _this$1$[esp+32]

; 232  : 	while (zone_index < nbr_zones)

	cmovl	edx, ecx

; 144  : 			expand_to (new_size);

	mov	ecx, ebx
	add	eax, edx
	push	eax
	call	?expand_to@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXI@Z ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::expand_to

; 145  : 		}
; 146  : 	}
; 147  : 	while ((cell_ptr == 0) && autogrow_flag && (nbr_zones < MAX_NBR_ZONES));

	cmp	esi, 64					; 00000040H
$LN61@take_cell:
	lea	eax, DWORD PTR [ebx+8]
	jl	SHORT $LL4@take_cell

; 152  : 	}
; 153  : 
; 154  : 	return (cell_ptr);

	mov	eax, ebp

; 155  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN58@take_cell:

; 148  : 
; 149  : 	if (cell_ptr != 0)
; 150  : 	{
; 151  : 		-- _nbr_avail_cells;

	lea	esi, DWORD PTR [ebx+288]
	npad	4
$LL28@take_cell:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	lea	ecx, DWORD PTR [edx-1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL28@take_cell
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 155  : }

	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
?take_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::take_cell
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?return_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z
_TEXT	SEGMENT
_cell$ = 8						; size = 4
?return_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::return_cell, COMDAT
; _this$ = ecx

; 162  : {

	push	ecx
	push	esi

; 163  : 	assert (&cell != 0);
; 164  : 
; 165  : 	_cell_stack.push (cell);

	push	DWORD PTR _cell$[esp+4]
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+8]
	call	?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push

; 166  : 
; 167  : 	++ _nbr_avail_cells;

	add	esi, 288				; 00000120H
$LL14@return_cel:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL14@return_cel
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 168  : }

	pop	esi
	pop	ecx
	ret	4
?return_cell@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::return_cell
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
;	COMDAT ??0?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ PROC ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::LockFreeStack<PlaneOfBlocks::WorkingArea *>, COMDAT
; _this$ = ecx

; 41   : {

	mov	DWORD PTR [ecx], OFFSET ??_7?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@6B@
	xorps	xmm0, xmm0
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 41   : {

	mov	DWORD PTR [ecx+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	movq	QWORD PTR [ecx+16], xmm0
	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+20]
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 43   : }

	mov	eax, ecx
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [ecx+16], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [ecx+20], 0

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [ecx+16], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [ecx+20], 0
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 43   : }

	ret	0
??0?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ENDP ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::LockFreeStack<PlaneOfBlocks::WorkingArea *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
;	COMDAT ?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z
_TEXT	SEGMENT
tv88 = -24						; size = 4
_this$1$ = -20						; size = 4
_comp$1 = -16						; size = 8
_newx$2 = -8						; size = 8
_cell$ = 8						; size = 4
?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z PROC ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push, COMDAT
; _this$ = ecx

; 49   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH
	mov	eax, ecx
	push	ebx
	push	esi
	push	edi
	lea	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _this$1$[esp+40], eax
	mov	DWORD PTR tv88[esp+40], ecx
	npad	7
$LL4@push:

; 50   : 	assert (&cell != 0);
; 51   : 
; 52   : 	CellType *		head_ptr;
; 53   : 	ptrdiff_t		count;
; 54   : 	do
; 55   : 	{
; 56   : 		head_ptr = _head_ptr.get_ptr ();

	mov	edx, DWORD PTR [ecx]

; 57   : 		count    = _head_ptr.get_val ();

	mov	esi, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	mov	eax, edx
	mov	ecx, DWORD PTR _cell$[ebp]
	xchg	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 112  : 	newx._content._ptr = new_ptr;

	mov	DWORD PTR _newx$2[esp+40], ecx
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 60   : 	while (! _head_ptr.cas2 (&cell, count + 1, head_ptr, count));

	lea	eax, DWORD PTR [esi+1]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 113  : 	newx._content._val = new_val;

	mov	DWORD PTR _newx$2[esp+44], eax

; 114  : 
; 115  : 	Combi				comp;
; 116  : 	comp._content._ptr = comp_ptr;

	mov	DWORD PTR _comp$1[esp+40], edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, DWORD PTR _comp$1[esp+40]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 117  : 	comp._content._val = comp_val;

	mov	DWORD PTR _comp$1[esp+44], esi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	edx, DWORD PTR _comp$1[esp+44]
	mov	ebx, DWORD PTR _newx$2[esp+40]
	mov	ecx, DWORD PTR _newx$2[esp+44]
	mov	esi, DWORD PTR tv88[esp+40]
	lock	 cmpxchg8b QWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 122  : 	return (old._storage == comp._storage);

	cmp	eax, DWORD PTR _comp$1[esp+40]
	mov	esi, DWORD PTR _comp$1[esp+44]
	mov	eax, DWORD PTR _this$1$[esp+40]
	mov	ecx, DWORD PTR tv88[esp+40]
	jne	SHORT $LL4@push
	cmp	edx, esi
	jne	SHORT $LL4@push
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 61   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ENDP ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
;	COMDAT ?pop@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ
_TEXT	SEGMENT
tv164 = -24						; size = 4
_this$1$ = -20						; size = 4
_comp$1 = -16						; size = 8
_newx$2 = -8						; size = 8
?pop@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ PROC ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::pop, COMDAT
; _this$ = ecx

; 68   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	lea	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR _this$1$[esp+36], ecx
	push	edi
	mov	DWORD PTR tv164[esp+40], eax
$LL4@pop:

; 69   : 	CellType *		cell_ptr;
; 70   : 	bool				cont_flag = true;
; 71   : 	do
; 72   : 	{
; 73   : 		cell_ptr = _head_ptr.get_ptr ();

	mov	esi, DWORD PTR [eax]

; 74   : 
; 75   : 		if (cell_ptr == 0)

	test	esi, esi
	je	SHORT $LN39@pop

; 76   : 		{
; 77   : 			cont_flag = false;	// Empty stack.
; 78   : 		}
; 79   : 
; 80   : 		else
; 81   : 		{
; 82   : 			const ptrdiff_t	count = _head_ptr.get_val ();

	mov	ecx, DWORD PTR [ecx+20]

; 83   : 			if (cell_ptr != 0)
; 84   : 			{
; 85   : 				CellType *		next_ptr = cell_ptr->_next_ptr;

	mov	eax, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 112  : 	newx._content._ptr = new_ptr;

	mov	DWORD PTR _newx$2[esp+40], eax
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 86   : 				if (_head_ptr.cas2 (next_ptr, count + 1, cell_ptr, count))

	lea	eax, DWORD PTR [ecx+1]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 113  : 	newx._content._val = new_val;

	mov	DWORD PTR _newx$2[esp+44], eax

; 114  : 
; 115  : 	Combi				comp;
; 116  : 	comp._content._ptr = comp_ptr;

	mov	DWORD PTR _comp$1[esp+40], esi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, DWORD PTR _comp$1[esp+40]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 117  : 	comp._content._val = comp_val;

	mov	DWORD PTR _comp$1[esp+44], ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	edx, DWORD PTR _comp$1[esp+44]
	mov	ebx, DWORD PTR _newx$2[esp+40]
	mov	ecx, DWORD PTR _newx$2[esp+44]
	mov	edi, DWORD PTR tv164[esp+40]
	lock	 cmpxchg8b QWORD PTR [edi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 122  : 	return (old._storage == comp._storage);

	cmp	eax, DWORD PTR _comp$1[esp+40]
	mov	eax, edi
	mov	ecx, DWORD PTR _this$1$[esp+40]
	jne	SHORT $LL4@pop
	cmp	edx, DWORD PTR _comp$1[esp+44]
	jne	SHORT $LL4@pop
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [esi], eax
$LN39@pop:
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 97   : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?pop@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ENDP ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::pop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@VTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@VTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@J@Z PROC ; conc::Array<MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::TaskData,64>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	shl	eax, 4
	add	eax, ecx

; 56   : }

	ret	4
??A?$Array@VTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@J@Z ENDP ; conc::Array<MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::TaskData,64>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?take_cell@?$CellPool@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@_N@Z
_TEXT	SEGMENT
_zone_index$1$ = -12					; size = 4
_total_size$2$ = -8					; size = 4
_this$1$ = -4						; size = 4
_autogrow_flag$dead$ = 8				; size = 1
?take_cell@?$CellPool@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@_N@Z PROC ; conc::CellPool<DCTClass *>::take_cell, COMDAT
; _this$ = ecx

; 132  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
	push	edi

; 133  : 	CellType *		cell_ptr = 0;
; 134  : 	
; 135  : 	const int		nbr_zones = _nbr_zones;

	mov	esi, DWORD PTR [ebx+292]
	lea	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _this$1$[esp+32], ebx
	npad	4
$LL4@take_cell:

; 136  : 
; 137  : 	do
; 138  : 	{
; 139  : 		cell_ptr = _cell_stack.pop ();

	mov	ecx, eax
	call	?pop@?$LockFreeStack@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ; conc::LockFreeStack<DCTClass *>::pop
	mov	ebp, eax

; 140  : 
; 141  : 		if ((cell_ptr == 0) && autogrow_flag && (nbr_zones < MAX_NBR_ZONES))

	test	ebp, ebp
	jne	SHORT $LN58@take_cell
	cmp	esi, 64					; 00000040H
	jge	SHORT $LN61@take_cell

; 229  : 	size_t			cur_size = BASE_SIZE;

	lea	ecx, DWORD PTR [eax+64]

; 230  : 	size_t			total_size = 0;

	xor	edx, edx

; 142  : 		{
; 143  : 			const size_t	new_size = compute_total_size_for_zones (nbr_zones + 1);

	lea	eax, DWORD PTR [esi+1]

; 230  : 	size_t			total_size = 0;

	mov	DWORD PTR _total_size$2$[esp+32], edx
	xor	edi, edi

; 231  : 	int				zone_index = 0;
; 232  : 	while (zone_index < nbr_zones)

	mov	DWORD PTR _zone_index$1$[esp+32], edx
	xor	ebx, ebx
	cmp	eax, 2
	jl	SHORT $LC53@take_cell
	lea	edx, DWORD PTR [esi-1]
	shr	edx, 1
	inc	edx
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR _zone_index$1$[esp+32], eax
$LL54@take_cell:

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	eax, DWORD PTR [ecx+ecx*2]

; 234  : 		total_size += cur_size;

	add	edi, ecx

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	shr	eax, 1

; 234  : 		total_size += cur_size;

	add	ebx, eax

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	ecx, DWORD PTR [eax+eax*2]
	shr	ecx, 1
	sub	edx, 1
	jne	SHORT $LL54@take_cell
	mov	edx, DWORD PTR _total_size$2$[esp+32]
	lea	eax, DWORD PTR [esi+1]
$LC53@take_cell:

; 232  : 	while (zone_index < nbr_zones)

	cmp	DWORD PTR _zone_index$1$[esp+32], eax
	lea	eax, DWORD PTR [ebx+edi]

; 144  : 			expand_to (new_size);

	mov	ebx, DWORD PTR _this$1$[esp+32]

; 232  : 	while (zone_index < nbr_zones)

	cmovl	edx, ecx

; 144  : 			expand_to (new_size);

	mov	ecx, ebx
	add	eax, edx
	push	eax
	call	?expand_to@?$CellPool@PAVDCTClass@@@conc@@QAEXI@Z ; conc::CellPool<DCTClass *>::expand_to

; 145  : 		}
; 146  : 	}
; 147  : 	while ((cell_ptr == 0) && autogrow_flag && (nbr_zones < MAX_NBR_ZONES));

	cmp	esi, 64					; 00000040H
$LN61@take_cell:
	lea	eax, DWORD PTR [ebx+8]
	jl	SHORT $LL4@take_cell

; 154  : 	return (cell_ptr);

	mov	eax, ebp

; 155  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN58@take_cell:

; 148  : 
; 149  : 	if (cell_ptr != 0)
; 150  : 	{
; 151  : 		-- _nbr_avail_cells;

	lea	esi, DWORD PTR [ebx+288]
$LL28@take_cell:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	lea	ecx, DWORD PTR [edx-1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL28@take_cell
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 154  : 	return (cell_ptr);

	pop	edi
	mov	eax, ebp

; 155  : }

	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?take_cell@?$CellPool@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@_N@Z ENDP ; conc::CellPool<DCTClass *>::take_cell
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.hpp
;	COMDAT ??0?$AioAdd@_J@conc@@QAE@_J@Z
_TEXT	SEGMENT
_operand$ = 8						; size = 8
??0?$AioAdd@_J@conc@@QAE@_J@Z PROC			; conc::AioAdd<__int64>::AioAdd<__int64>, COMDAT
; _this$ = ecx

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR _operand$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _operand$[esp]
	mov	DWORD PTR [ecx+12], eax

; 40   : 	// Nothing
; 41   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$AioAdd@_J@conc@@6B@
	ret	8
??0?$AioAdd@_J@conc@@QAE@_J@Z ENDP			; conc::AioAdd<__int64>::AioAdd<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@@Z
_TEXT	SEGMENT
_val_new$ = -16						; size = 8
_val_old$ = -8						; size = 8
??$exec@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@@Z PROC ; conc::AtomicIntOp::exec<__int64,conc::AioAdd<__int64> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 40   : {

	sub	esp, 20					; 00000014H

; 41   : 	assert (&atom != 0);
; 42   : 	assert (&ftor != 0);
; 43   : 
; 44   : 	T					val_new;
; 45   : 	T					val_old;
; 46   : 	exec_both (atom, ftor, val_old, val_new);

	lea	eax, DWORD PTR _val_new$[esp+20]
	push	eax
	lea	eax, DWORD PTR _val_old$[esp+24]
	push	eax
	call	??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >

; 47   : }

	add	esp, 28					; 0000001cH
	ret	0
??$exec@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@@Z ENDP ; conc::AtomicIntOp::exec<__int64,conc::AioAdd<__int64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_both@HV?$AioSub@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioSub@H@1@AAH2@Z
_TEXT	SEGMENT
_val_old$ = 8						; size = 4
_val_new$ = 12						; size = 4
??$exec_both@HV?$AioSub@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioSub@H@1@AAH2@Z PROC ; conc::AtomicIntOp::exec_both<int,conc::AioSub<int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 83   : {

	push	ebx
	mov	ebx, DWORD PTR _val_new$[esp]
	push	ebp
	mov	ebp, DWORD PTR _val_old$[esp+4]
	push	esi
	push	edi
	mov	edi, edx
	npad	2
$LL4@exec_both:

; 84   : 	assert (&atom != 0);
; 85   : 	assert (&ftor != 0);
; 86   : 
; 87   : 	T					val_cur;
; 88   : 	do
; 89   : 	{
; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	mov	edx, esi
	sub	edx, DWORD PTR [edi+4]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	DWORD PTR [ebx], edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 92   : 		val_old = atom.cas (val_new, val_cur);

	mov	DWORD PTR [ebp], eax

; 93   : 	}
; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL4@exec_both

; 95   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$exec_both@HV?$AioSub@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioSub@H@1@AAH2@Z ENDP ; conc::AtomicIntOp::exec_both<int,conc::AioSub<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??$FetchPredictors@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = -12						; size = 12
$T3 = -12						; size = 12
_workarea$ = 8						; size = 4
??$FetchPredictors@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z PROC ; PlaneOfBlocks::FetchPredictors<unsigned char>, COMDAT
; _this$ = ecx

; 590  : {

	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 591  :   // Left (or right) predictor
; 592  :   if ((workarea.blkScanDir == 1 && workarea.blkx > 0) || (workarea.blkScanDir == -1 && workarea.blkx < nBlkX - 1))

	mov	edi, DWORD PTR _workarea$[esp+16]
	mov	esi, ecx
	mov	ecx, DWORD PTR [edi+44]
	cmp	ecx, 1
	jne	SHORT $LN5@FetchPredi
	cmp	DWORD PTR [edi+32], 0
	jg	SHORT $LN4@FetchPredi
$LN5@FetchPredi:
	cmp	ecx, -1
	jne	SHORT $LN2@FetchPredi
	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	DWORD PTR [edi+32], eax
	jge	SHORT $LN2@FetchPredi
$LN4@FetchPredi:

; 594  :     workarea.predictors[1] = ClipMV(workarea, vectors[workarea.blkIdx - workarea.blkScanDir]);

	mov	eax, DWORD PTR [edi+40]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 594  :     workarea.predictors[1] = ClipMV(workarea, vectors[workarea.blkIdx - workarea.blkScanDir]);

	movq	xmm0, QWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 594  :     workarea.predictors[1] = ClipMV(workarea, vectors[workarea.blkIdx - workarea.blkScanDir]);

	mov	eax, DWORD PTR [eax+8]

; 595  :   }
; 596  :   else

	jmp	SHORT $LN94@FetchPredi
$LN2@FetchPredi:

; 597  :   {
; 598  :     workarea.predictors[1] = ClipMV(workarea, zeroMVfieldShifted); // v1.11.1 - values instead of pointer

	movq	xmm0, QWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+212]
$LN94@FetchPredi:
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	edi
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T3[esp+36]
	push	eax
	call	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV

; 604  :     workarea.predictors[2] = ClipMV(workarea, vectors[workarea.blkIdx - nBlkX]);

	sub	esp, 12					; 0000000cH
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [edi+140], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+148], eax
	mov	eax, DWORD PTR [edi+36]
	cmp	eax, DWORD PTR [edi+80]
	jle	SHORT $LN6@FetchPredi
	mov	eax, DWORD PTR [edi+40]
	sub	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 604  :     workarea.predictors[2] = ClipMV(workarea, vectors[workarea.blkIdx - nBlkX]);

	movq	xmm0, QWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 604  :     workarea.predictors[2] = ClipMV(workarea, vectors[workarea.blkIdx - nBlkX]);

	mov	eax, DWORD PTR [eax+8]

; 605  :   }
; 606  :   else

	jmp	SHORT $LN95@FetchPredi
$LN6@FetchPredi:

; 607  :   {
; 608  :     workarea.predictors[2] = ClipMV(workarea, zeroMVfieldShifted);

	movq	xmm0, QWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+212]
$LN95@FetchPredi:
	mov	ecx, esp
	push	edi
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T2[esp+36]
	push	eax
	call	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [edi+152], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+160], eax

; 609  :   }
; 610  : 
; 611  :   // bottom-right pridictor (from coarse level)
; 612  :   if ((workarea.blky < workarea.blky_end - 1) && ((workarea.blkScanDir == 1 && workarea.blkx < nBlkX - 1) || (workarea.blkScanDir == -1 && workarea.blkx > 0)))

	mov	eax, DWORD PTR [edi+84]
	mov	edx, DWORD PTR [edi+36]
	dec	eax
	cmp	edx, eax
	jge	SHORT $LN8@FetchPredi
	mov	ecx, DWORD PTR [edi+44]
	cmp	ecx, 1
	jne	SHORT $LN11@FetchPredi
	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	DWORD PTR [edi+32], eax
	jl	SHORT $LN10@FetchPredi
$LN11@FetchPredi:
	cmp	ecx, -1
	jne	SHORT $LN8@FetchPredi
	cmp	DWORD PTR [edi+32], 0
	jle	SHORT $LN8@FetchPredi
$LN10@FetchPredi:

; 614  :     workarea.predictors[3] = ClipMV(workarea, vectors[workarea.blkIdx + nBlkX + workarea.blkScanDir]);

	mov	eax, DWORD PTR [edi+40]
	add	eax, ecx
	add	eax, DWORD PTR [esi]
$LN97@FetchPredi:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 614  :     workarea.predictors[3] = ClipMV(workarea, vectors[workarea.blkIdx + nBlkX + workarea.blkScanDir]);

	movq	xmm0, QWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 614  :     workarea.predictors[3] = ClipMV(workarea, vectors[workarea.blkIdx + nBlkX + workarea.blkScanDir]);

	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN96@FetchPredi
$LN8@FetchPredi:

; 615  :   }
; 616  :   // Up-right predictor
; 617  :   else if ((workarea.blky > workarea.blky_beg) && ((workarea.blkScanDir == 1 && workarea.blkx < nBlkX - 1) || (workarea.blkScanDir == -1 && workarea.blkx > 0)))

	cmp	edx, DWORD PTR [edi+80]
	jle	SHORT $LN12@FetchPredi
	mov	ecx, DWORD PTR [edi+44]
	cmp	ecx, 1
	jne	SHORT $LN15@FetchPredi
	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	DWORD PTR [edi+32], eax
	jl	SHORT $LN14@FetchPredi
$LN15@FetchPredi:
	cmp	ecx, -1
	jne	SHORT $LN12@FetchPredi
	cmp	DWORD PTR [edi+32], 0
	jle	SHORT $LN12@FetchPredi
$LN14@FetchPredi:

; 618  :   {
; 619  :     workarea.predictors[3] = ClipMV(workarea, vectors[workarea.blkIdx - nBlkX + workarea.blkScanDir]);

	mov	eax, DWORD PTR [edi+40]
	sub	eax, DWORD PTR [esi]
	add	eax, ecx

; 620  :   }
; 621  :   else

	jmp	SHORT $LN97@FetchPredi
$LN12@FetchPredi:

; 622  :   {
; 623  :     workarea.predictors[3] = ClipMV(workarea, zeroMVfieldShifted);

	movq	xmm0, QWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+212]
$LN96@FetchPredi:
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	edi
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T1[esp+36]
	push	eax
	call	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [edi+164], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+172], eax

; 624  :   }
; 625  : 
; 626  :   // Median predictor
; 627  :   if (workarea.blky > workarea.blky_beg) // replaced 1 by 0 - Fizick

	mov	eax, DWORD PTR [edi+36]
	cmp	eax, DWORD PTR [edi+80]
	jle	$LN16@FetchPredi

; 628  :   {
; 629  :     workarea.predictors[0].x = Median(workarea.predictors[1].x, workarea.predictors[2].x, workarea.predictors[3].x);

	mov	eax, DWORD PTR [edi+152]
	mov	edx, DWORD PTR [edi+140]
	mov	ecx, DWORD PTR [edi+164]

; 1785 :   if (a < b)

	cmp	edx, eax
	jge	SHORT $LN65@FetchPredi

; 1786 :   {
; 1787 :     if (b < c) return b;

	cmp	eax, ecx
	jl	SHORT $LN73@FetchPredi

; 1788 :     else if (a < c) return c;

	mov	eax, edx
	cmp	edx, ecx

; 1789 :     else return a;

	jmp	SHORT $LN98@FetchPredi
$LN65@FetchPredi:

; 1790 :   }
; 1791 :   else {
; 1792 :     if (a < c) return a;

	cmp	edx, ecx
	jge	SHORT $LN71@FetchPredi
	mov	eax, edx
	jmp	SHORT $LN73@FetchPredi
$LN71@FetchPredi:

; 1793 :     else if (b < c) return c;

	cmp	eax, ecx
$LN98@FetchPredi:
	cmovl	eax, ecx
$LN73@FetchPredi:

; 630  :     workarea.predictors[0].y = Median(workarea.predictors[1].y, workarea.predictors[2].y, workarea.predictors[3].y);

	mov	edx, DWORD PTR [edi+144]
	mov	ecx, DWORD PTR [edi+168]
	mov	DWORD PTR [edi+128], eax
	mov	eax, DWORD PTR [edi+156]

; 1785 :   if (a < b)

	cmp	edx, eax
	jge	SHORT $LN77@FetchPredi

; 1786 :   {
; 1787 :     if (b < c) return b;

	cmp	eax, ecx
	jl	SHORT $LN85@FetchPredi

; 1788 :     else if (a < c) return c;

	mov	eax, edx
	cmp	edx, ecx

; 1789 :     else return a;

	jmp	SHORT $LN99@FetchPredi
$LN77@FetchPredi:

; 1790 :   }
; 1791 :   else {
; 1792 :     if (a < c) return a;

	cmp	edx, ecx
	jge	SHORT $LN83@FetchPredi
	mov	eax, edx
	jmp	SHORT $LN85@FetchPredi
$LN83@FetchPredi:

; 1793 :     else if (b < c) return c;

	cmp	eax, ecx
$LN99@FetchPredi:
	cmovl	eax, ecx
$LN85@FetchPredi:

; 630  :     workarea.predictors[0].y = Median(workarea.predictors[1].y, workarea.predictors[2].y, workarea.predictors[3].y);

	mov	DWORD PTR [edi+132], eax
	mov	ecx, 172				; 000000acH
	mov	eax, DWORD PTR [edi+160]
	mov	edx, 160				; 000000a0H
	cmp	eax, DWORD PTR [edi+172]
	mov	eax, DWORD PTR [edi+148]
	cmovl	edx, ecx
	mov	ecx, 148				; 00000094H
	cmp	eax, DWORD PTR [edx+edi]
	cmovl	ecx, edx

; 631  :     //		workarea.predictors[0].sad = Median(workarea.predictors[1].sad, workarea.predictors[2].sad, workarea.predictors[3].sad);
; 632  :         // but it is not true median vector (x and y may be mixed) and not its sad ?!
; 633  :         // we really do not know SAD, here is more safe estimation especially for phaseshift method - v1.6.0
; 634  :     workarea.predictors[0].sad = std::max(workarea.predictors[1].sad, std::max(workarea.predictors[2].sad, workarea.predictors[3].sad));

	mov	eax, DWORD PTR [ecx+edi]

; 635  :   }
; 636  :   else

	jmp	SHORT $LN100@FetchPredi
$LN16@FetchPredi:

; 637  :   {
; 638  :     //		workarea.predictors[0].x = (workarea.predictors[1].x + workarea.predictors[2].x + workarea.predictors[3].x);
; 639  :     //		workarea.predictors[0].y = (workarea.predictors[1].y + workarea.predictors[2].y + workarea.predictors[3].y);
; 640  :     //		workarea.predictors[0].sad = (workarea.predictors[1].sad + workarea.predictors[2].sad + workarea.predictors[3].sad);
; 641  :         // but for top line we have only left workarea.predictor[1] - v1.6.0
; 642  :     workarea.predictors[0].x = workarea.predictors[1].x;

	mov	eax, DWORD PTR [edi+140]
	mov	DWORD PTR [edi+128], eax

; 643  :     workarea.predictors[0].y = workarea.predictors[1].y;

	mov	eax, DWORD PTR [edi+144]
	mov	DWORD PTR [edi+132], eax

; 644  :     workarea.predictors[0].sad = workarea.predictors[1].sad;

	mov	eax, DWORD PTR [edi+148]
$LN100@FetchPredi:
	mov	DWORD PTR [edi+136], eax

; 645  :   }
; 646  : 
; 647  :   // if there are no other planes, predictor is the median
; 648  :   if (smallestPlane)

	cmp	BYTE PTR [esi+120], 0
	je	SHORT $LN18@FetchPredi

; 649  :   {
; 650  :     workarea.predictor = workarea.predictors[0];

	movq	xmm0, QWORD PTR [edi+128]
	movq	QWORD PTR [edi+116], xmm0
	mov	eax, DWORD PTR [edi+136]
	mov	DWORD PTR [edi+124], eax
$LN18@FetchPredi:

; 651  :   }
; 652  :   /*
; 653  :     else
; 654  :     {
; 655  :       if ( workarea.predictors[0].sad < workarea.predictor.sad )// disabled by Fizick (hierarchy only!)
; 656  :       {
; 657  :         workarea.predictors[4] = workarea.predictor;
; 658  :         workarea.predictor = workarea.predictors[0];
; 659  :         workarea.predictors[0] = workarea.predictors[4];
; 660  :       }
; 661  :     }
; 662  :   */
; 663  :   //	if ( workarea.predictor.sad > LSAD ) { workarea.nLambda = 0; } // generalized (was LSAD=400) by Fizick
; 664  :   typedef typename std::conditional < sizeof(pixel_t) == 1, sad_t, bigsad_t >::type safe_sad_t;
; 665  :   workarea.nLambda = workarea.nLambda*(safe_sad_t)LSAD / ((safe_sad_t)LSAD + (workarea.predictor.sad >> 1))*LSAD / ((safe_sad_t)LSAD + (workarea.predictor.sad >> 1));

	mov	ecx, DWORD PTR [esi+232]
	mov	eax, DWORD PTR [edi+384]
	mov	esi, DWORD PTR [edi+124]
	imul	eax, ecx
	sar	esi, 1
	add	esi, ecx
	cdq
	idiv	esi
	imul	eax, ecx
	cdq
	idiv	esi
	mov	DWORD PTR [edi+384], eax

; 666  :   // replaced hard threshold by soft in v1.10.2 by Fizick (a liitle complex expression to avoid overflow)
; 667  :   //	int a = LSAD/(LSAD + (workarea.predictor.sad>>1));
; 668  :   //	workarea.nLambda = workarea.nLambda*a*a;
; 669  : }

	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
??$FetchPredictors@E@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ENDP ; PlaneOfBlocks::FetchPredictors<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\planeofblocks.cpp
;	COMDAT ??$FetchPredictors@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = -12						; size = 12
$T3 = -12						; size = 12
_workarea$ = 8						; size = 4
??$FetchPredictors@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z PROC ; PlaneOfBlocks::FetchPredictors<unsigned short>, COMDAT
; _this$ = ecx

; 590  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 591  :   // Left (or right) predictor
; 592  :   if ((workarea.blkScanDir == 1 && workarea.blkx > 0) || (workarea.blkScanDir == -1 && workarea.blkx < nBlkX - 1))

	mov	ebp, DWORD PTR _workarea$[esp+16]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [ebp+44]
	cmp	ecx, 1
	jne	SHORT $LN5@FetchPredi
	cmp	DWORD PTR [ebp+32], 0
	jg	SHORT $LN4@FetchPredi
$LN5@FetchPredi:
	cmp	ecx, -1
	jne	SHORT $LN2@FetchPredi
	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	DWORD PTR [ebp+32], eax
	jge	SHORT $LN2@FetchPredi
$LN4@FetchPredi:

; 594  :     workarea.predictors[1] = ClipMV(workarea, vectors[workarea.blkIdx - workarea.blkScanDir]);

	mov	eax, DWORD PTR [ebp+40]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 594  :     workarea.predictors[1] = ClipMV(workarea, vectors[workarea.blkIdx - workarea.blkScanDir]);

	movq	xmm0, QWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 594  :     workarea.predictors[1] = ClipMV(workarea, vectors[workarea.blkIdx - workarea.blkScanDir]);

	mov	eax, DWORD PTR [eax+8]

; 595  :   }
; 596  :   else

	jmp	SHORT $LN94@FetchPredi
$LN2@FetchPredi:

; 597  :   {
; 598  :     workarea.predictors[1] = ClipMV(workarea, zeroMVfieldShifted); // v1.11.1 - values instead of pointer

	movq	xmm0, QWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+212]
$LN94@FetchPredi:
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	ebp
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T3[esp+44]
	push	eax
	call	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV

; 604  :     workarea.predictors[2] = ClipMV(workarea, vectors[workarea.blkIdx - nBlkX]);

	sub	esp, 12					; 0000000cH
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ebp+140], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ebp+148], eax
	mov	eax, DWORD PTR [ebp+36]
	cmp	eax, DWORD PTR [ebp+80]
	jle	SHORT $LN6@FetchPredi
	mov	eax, DWORD PTR [ebp+40]
	sub	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 604  :     workarea.predictors[2] = ClipMV(workarea, vectors[workarea.blkIdx - nBlkX]);

	movq	xmm0, QWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 604  :     workarea.predictors[2] = ClipMV(workarea, vectors[workarea.blkIdx - nBlkX]);

	mov	eax, DWORD PTR [eax+8]

; 605  :   }
; 606  :   else

	jmp	SHORT $LN95@FetchPredi
$LN6@FetchPredi:

; 607  :   {
; 608  :     workarea.predictors[2] = ClipMV(workarea, zeroMVfieldShifted);

	movq	xmm0, QWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+212]
$LN95@FetchPredi:
	mov	ecx, esp
	push	ebp
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T2[esp+44]
	push	eax
	call	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ebp+152], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ebp+160], eax

; 609  :   }
; 610  : 
; 611  :   // bottom-right pridictor (from coarse level)
; 612  :   if ((workarea.blky < workarea.blky_end - 1) && ((workarea.blkScanDir == 1 && workarea.blkx < nBlkX - 1) || (workarea.blkScanDir == -1 && workarea.blkx > 0)))

	mov	eax, DWORD PTR [ebp+84]
	mov	edx, DWORD PTR [ebp+36]
	dec	eax
	cmp	edx, eax
	jge	SHORT $LN8@FetchPredi
	mov	ecx, DWORD PTR [ebp+44]
	cmp	ecx, 1
	jne	SHORT $LN11@FetchPredi
	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	DWORD PTR [ebp+32], eax
	jl	SHORT $LN10@FetchPredi
$LN11@FetchPredi:
	cmp	ecx, -1
	jne	SHORT $LN8@FetchPredi
	cmp	DWORD PTR [ebp+32], 0
	jle	SHORT $LN8@FetchPredi
$LN10@FetchPredi:

; 614  :     workarea.predictors[3] = ClipMV(workarea, vectors[workarea.blkIdx + nBlkX + workarea.blkScanDir]);

	mov	eax, DWORD PTR [ebp+40]
	add	eax, ecx
	add	eax, DWORD PTR [esi]
$LN97@FetchPredi:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+108]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 614  :     workarea.predictors[3] = ClipMV(workarea, vectors[workarea.blkIdx + nBlkX + workarea.blkScanDir]);

	movq	xmm0, QWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	eax, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 614  :     workarea.predictors[3] = ClipMV(workarea, vectors[workarea.blkIdx + nBlkX + workarea.blkScanDir]);

	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN96@FetchPredi
$LN8@FetchPredi:

; 615  :   }
; 616  :   // Up-right predictor
; 617  :   else if ((workarea.blky > workarea.blky_beg) && ((workarea.blkScanDir == 1 && workarea.blkx < nBlkX - 1) || (workarea.blkScanDir == -1 && workarea.blkx > 0)))

	cmp	edx, DWORD PTR [ebp+80]
	jle	SHORT $LN12@FetchPredi
	mov	ecx, DWORD PTR [ebp+44]
	cmp	ecx, 1
	jne	SHORT $LN15@FetchPredi
	mov	eax, DWORD PTR [esi]
	dec	eax
	cmp	DWORD PTR [ebp+32], eax
	jl	SHORT $LN14@FetchPredi
$LN15@FetchPredi:
	cmp	ecx, -1
	jne	SHORT $LN12@FetchPredi
	cmp	DWORD PTR [ebp+32], 0
	jle	SHORT $LN12@FetchPredi
$LN14@FetchPredi:

; 618  :   {
; 619  :     workarea.predictors[3] = ClipMV(workarea, vectors[workarea.blkIdx - nBlkX + workarea.blkScanDir]);

	mov	eax, DWORD PTR [ebp+40]
	sub	eax, DWORD PTR [esi]
	add	eax, ecx

; 620  :   }
; 621  :   else

	jmp	SHORT $LN97@FetchPredi
$LN12@FetchPredi:

; 622  :   {
; 623  :     workarea.predictors[3] = ClipMV(workarea, zeroMVfieldShifted);

	movq	xmm0, QWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+212]
$LN96@FetchPredi:
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	ebp
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T1[esp+44]
	push	eax
	call	?ClipMV@PlaneOfBlocks@@AAE?AUVECTOR@@AAVWorkingArea@1@U2@@Z ; PlaneOfBlocks::ClipMV
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ebp+164], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ebp+172], eax

; 624  :   }
; 625  : 
; 626  :   // Median predictor
; 627  :   if (workarea.blky > workarea.blky_beg) // replaced 1 by 0 - Fizick

	mov	eax, DWORD PTR [ebp+36]
	cmp	eax, DWORD PTR [ebp+80]
	jle	$LN16@FetchPredi

; 628  :   {
; 629  :     workarea.predictors[0].x = Median(workarea.predictors[1].x, workarea.predictors[2].x, workarea.predictors[3].x);

	mov	eax, DWORD PTR [ebp+152]
	mov	edx, DWORD PTR [ebp+140]
	mov	ecx, DWORD PTR [ebp+164]

; 1785 :   if (a < b)

	cmp	edx, eax
	jge	SHORT $LN65@FetchPredi

; 1786 :   {
; 1787 :     if (b < c) return b;

	cmp	eax, ecx
	jl	SHORT $LN73@FetchPredi

; 1788 :     else if (a < c) return c;

	mov	eax, edx
	cmp	edx, ecx

; 1789 :     else return a;

	jmp	SHORT $LN98@FetchPredi
$LN65@FetchPredi:

; 1790 :   }
; 1791 :   else {
; 1792 :     if (a < c) return a;

	cmp	edx, ecx
	jge	SHORT $LN71@FetchPredi
	mov	eax, edx
	jmp	SHORT $LN73@FetchPredi
$LN71@FetchPredi:

; 1793 :     else if (b < c) return c;

	cmp	eax, ecx
$LN98@FetchPredi:
	cmovl	eax, ecx
$LN73@FetchPredi:

; 630  :     workarea.predictors[0].y = Median(workarea.predictors[1].y, workarea.predictors[2].y, workarea.predictors[3].y);

	mov	edx, DWORD PTR [ebp+144]
	mov	ecx, DWORD PTR [ebp+168]
	mov	DWORD PTR [ebp+128], eax
	mov	eax, DWORD PTR [ebp+156]

; 1785 :   if (a < b)

	cmp	edx, eax
	jge	SHORT $LN77@FetchPredi

; 1786 :   {
; 1787 :     if (b < c) return b;

	cmp	eax, ecx
	jl	SHORT $LN85@FetchPredi

; 1788 :     else if (a < c) return c;

	mov	eax, edx
	cmp	edx, ecx

; 1789 :     else return a;

	jmp	SHORT $LN99@FetchPredi
$LN77@FetchPredi:

; 1790 :   }
; 1791 :   else {
; 1792 :     if (a < c) return a;

	cmp	edx, ecx
	jge	SHORT $LN83@FetchPredi
	mov	eax, edx
	jmp	SHORT $LN85@FetchPredi
$LN83@FetchPredi:

; 1793 :     else if (b < c) return c;

	cmp	eax, ecx
$LN99@FetchPredi:
	cmovl	eax, ecx
$LN85@FetchPredi:

; 630  :     workarea.predictors[0].y = Median(workarea.predictors[1].y, workarea.predictors[2].y, workarea.predictors[3].y);

	mov	DWORD PTR [ebp+132], eax
	mov	ecx, 172				; 000000acH
	mov	eax, DWORD PTR [ebp+160]
	mov	edx, 160				; 000000a0H
	cmp	eax, DWORD PTR [ebp+172]
	mov	eax, DWORD PTR [ebp+148]
	cmovl	edx, ecx
	mov	ecx, 148				; 00000094H
	cmp	eax, DWORD PTR [edx+ebp]
	cmovl	ecx, edx

; 631  :     //		workarea.predictors[0].sad = Median(workarea.predictors[1].sad, workarea.predictors[2].sad, workarea.predictors[3].sad);
; 632  :         // but it is not true median vector (x and y may be mixed) and not its sad ?!
; 633  :         // we really do not know SAD, here is more safe estimation especially for phaseshift method - v1.6.0
; 634  :     workarea.predictors[0].sad = std::max(workarea.predictors[1].sad, std::max(workarea.predictors[2].sad, workarea.predictors[3].sad));

	mov	eax, DWORD PTR [ecx+ebp]

; 635  :   }
; 636  :   else

	jmp	SHORT $LN100@FetchPredi
$LN16@FetchPredi:

; 637  :   {
; 638  :     //		workarea.predictors[0].x = (workarea.predictors[1].x + workarea.predictors[2].x + workarea.predictors[3].x);
; 639  :     //		workarea.predictors[0].y = (workarea.predictors[1].y + workarea.predictors[2].y + workarea.predictors[3].y);
; 640  :     //		workarea.predictors[0].sad = (workarea.predictors[1].sad + workarea.predictors[2].sad + workarea.predictors[3].sad);
; 641  :         // but for top line we have only left workarea.predictor[1] - v1.6.0
; 642  :     workarea.predictors[0].x = workarea.predictors[1].x;

	mov	eax, DWORD PTR [ebp+140]
	mov	DWORD PTR [ebp+128], eax

; 643  :     workarea.predictors[0].y = workarea.predictors[1].y;

	mov	eax, DWORD PTR [ebp+144]
	mov	DWORD PTR [ebp+132], eax

; 644  :     workarea.predictors[0].sad = workarea.predictors[1].sad;

	mov	eax, DWORD PTR [ebp+148]
$LN100@FetchPredi:
	mov	DWORD PTR [ebp+136], eax

; 645  :   }
; 646  : 
; 647  :   // if there are no other planes, predictor is the median
; 648  :   if (smallestPlane)

	cmp	BYTE PTR [esi+120], 0
	je	SHORT $LN18@FetchPredi

; 649  :   {
; 650  :     workarea.predictor = workarea.predictors[0];

	movq	xmm0, QWORD PTR [ebp+128]
	movq	QWORD PTR [ebp+116], xmm0
	mov	eax, DWORD PTR [ebp+136]
	mov	DWORD PTR [ebp+124], eax
$LN18@FetchPredi:

; 651  :   }
; 652  :   /*
; 653  :     else
; 654  :     {
; 655  :       if ( workarea.predictors[0].sad < workarea.predictor.sad )// disabled by Fizick (hierarchy only!)
; 656  :       {
; 657  :         workarea.predictors[4] = workarea.predictor;
; 658  :         workarea.predictor = workarea.predictors[0];
; 659  :         workarea.predictors[0] = workarea.predictors[4];
; 660  :       }
; 661  :     }
; 662  :   */
; 663  :   //	if ( workarea.predictor.sad > LSAD ) { workarea.nLambda = 0; } // generalized (was LSAD=400) by Fizick
; 664  :   typedef typename std::conditional < sizeof(pixel_t) == 1, sad_t, bigsad_t >::type safe_sad_t;
; 665  :   workarea.nLambda = workarea.nLambda*(safe_sad_t)LSAD / ((safe_sad_t)LSAD + (workarea.predictor.sad >> 1))*LSAD / ((safe_sad_t)LSAD + (workarea.predictor.sad >> 1));

	mov	ecx, DWORD PTR [esi+232]
	mov	eax, ecx
	cdq
	mov	ebx, eax
	mov	edi, edx
	mov	eax, DWORD PTR [ebp+124]
	sar	eax, 1
	cdq
	mov	ebp, eax
	mov	esi, edx
	mov	eax, DWORD PTR _workarea$[esp+24]
	add	ebp, ebx
	adc	esi, edi
	push	esi
	mov	eax, DWORD PTR [eax+384]
	imul	ecx
	push	ebp
	push	edx
	push	eax
	call	__alldiv
	push	edi
	push	ebx
	push	edx
	push	eax
	call	__allmul
	push	esi
	push	ebp
	push	edx
	push	eax
	call	__alldiv
	mov	ecx, DWORD PTR _workarea$[esp+24]

; 666  :   // replaced hard threshold by soft in v1.10.2 by Fizick (a liitle complex expression to avoid overflow)
; 667  :   //	int a = LSAD/(LSAD + (workarea.predictor.sad>>1));
; 668  :   //	workarea.nLambda = workarea.nLambda*a*a;
; 669  : }

	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+384], eax
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
??$FetchPredictors@G@PlaneOfBlocks@@AAEXAAVWorkingArea@0@@Z ENDP ; PlaneOfBlocks::FetchPredictors<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVDCTClass@@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@@Z
_TEXT	SEGMENT
??$destroy@PAVDCTClass@@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@@Z PROC ; std::allocator_traits<std::allocator<DCTClass *> >::destroy<DCTClass *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAVDCTClass@@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@@Z ENDP ; std::allocator_traits<std::allocator<DCTClass *> >::destroy<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVDCTClass@@@std@@YAAAPAVDCTClass@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@AAPAVDCTClass@@@std@@YAAAPAVDCTClass@@AAPAV1@@Z PROC ; std::forward<DCTClass * &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAPAVDCTClass@@@std@@YAAAPAVDCTClass@@AAPAV1@@Z ENDP ; std::forward<DCTClass * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVDCTClass@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@AAPAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVDCTClass@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@PAVDCTClass@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVDCTClass@@@std@@YAABQAVDCTClass@@ABQAV1@@Z
_TEXT	SEGMENT
??$forward@ABQAVDCTClass@@@std@@YAABQAVDCTClass@@ABQAV1@@Z PROC ; std::forward<DCTClass * const &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@ABQAVDCTClass@@@std@@YAABQAVDCTClass@@ABQAV1@@Z ENDP ; std::forward<DCTClass * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVDCTClass@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@ABQAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVDCTClass@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@PAVDCTClass@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDCTClass@@@std@@@std@@SAXAAV?$allocator@PAVDCTClass@@@1@PAPAVDCTClass@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<DCTClass *> >::construct<DCTClass *,DCTClass * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAEIV?$AllocAlign@E$0BA@@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAEIV?$AllocAlign@E$0BA@@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<unsigned char *,unsigned int,AllocAlign<unsigned char,16> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	edx
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 472  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAEIV?$AllocAlign@E$0BA@@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<unsigned char *,unsigned int,AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<VECTOR *,unsigned int,std::allocator<VECTOR> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	test	edx, edx
	je	SHORT $LN3@Uninitiali
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN2@Uninitiali
	xorps	xmm0, xmm0
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], 0
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	ecx, 12					; 0000000cH
	sub	edx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAUVECTOR@@IV?$allocator@UVECTOR@@@std@@@std@@YAXPAUVECTOR@@IAAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<VECTOR *,unsigned int,std::allocator<VECTOR> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVDCTClass@@PAPAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAVDCTClass@@PAPAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z PROC ; std::_Uninitialized_move<DCTClass * *,DCTClass * *,std::allocator<DCTClass *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 319  : 	}

	ret	0
??$_Uninitialized_move@PAPAVDCTClass@@PAPAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<DCTClass * *,DCTClass * *,std::allocator<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAVDCTClass@@@std@@PAPAVDCTClass@@@std@@YAXPAPAVDCTClass@@0AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@PAVDCTClass@@@std@@PAPAVDCTClass@@@std@@YAXPAPAVDCTClass@@0AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<DCTClass *>,DCTClass * *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@PAVDCTClass@@@std@@PAPAVDCTClass@@@std@@YAXPAPAVDCTClass@@0AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<DCTClass *>,DCTClass * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
	push	DWORD PTR $T1[esp+4]
	push	ecx
	push	DWORD PTR __Dest$[esp+12]
	call	??$_Uninitialized_move_al_unchecked1@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Uninitialized_move@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$AllocAlign@E$0BA@@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$AllocAlign@E$0BA@@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<AllocAlign<unsigned char,16>,unsigned char *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1100 : 	for (; _First != _Last; ++_First)
; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	ret	0
??$_Destroy_range1@V?$AllocAlign@E$0BA@@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<AllocAlign<unsigned char,16>,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@UVECTOR@@@std@@PAUVECTOR@@@std@@YAXPAUVECTOR@@0AAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@UVECTOR@@@std@@PAUVECTOR@@@std@@YAXPAUVECTOR@@0AAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<VECTOR>,VECTOR *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@UVECTOR@@@std@@PAUVECTOR@@@std@@YAXPAUVECTOR@@0AAU?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<VECTOR>,VECTOR *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??0?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@$0EA@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@$0EA@@conc@@QAE@XZ PROC ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>, COMDAT
; _this$ = ecx
	mov	edx, 64					; 00000040H
	mov	eax, ecx
	npad	9
$LL4@Array:

; 43   : :	_ptr ()

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+4]
	sub	edx, 1
	jne	SHORT $LL4@Array
	mov	eax, ecx
	ret	0
??0?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@$0EA@@conc@@QAE@XZ ENDP ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??F?$AtomicInt@I@conc@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$AtomicInt@I@conc@@QAEAAV01@XZ PROC			; conc::AtomicInt<unsigned int>::operator--, COMDAT
; _this$ = ecx

; 162  : {

	push	esi
$LL12@operator:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	lea	edx, DWORD PTR [esi-1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL12@operator
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 164  : }

	mov	eax, ecx
	pop	esi
	ret	0
??F?$AtomicInt@I@conc@@QAEAAV01@XZ ENDP			; conc::AtomicInt<unsigned int>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?delete_obj_stack@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@AAEHAAV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z
_TEXT	SEGMENT
_ptr_stack$ = 8						; size = 4
_destroy_flag$ = 12					; size = 1
?delete_obj_stack@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@AAEHAAV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z PROC ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::delete_obj_stack, COMDAT
; _this$ = ecx

; 246  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 247  : 	assert (&ptr_stack != 0);
; 248  : 
; 249  : 	PtrStack::CellType *		cell_ptr = 0;
; 250  : 	int				count = 0;

	xor	edi, edi
	npad	2
$LL4@delete_obj:

; 251  : 	do
; 252  : 	{
; 253  : 		cell_ptr = ptr_stack.pop ();

	mov	ecx, DWORD PTR _ptr_stack$[ebp]
	call	?pop@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::pop
	mov	esi, eax

; 254  : 		if (cell_ptr != 0)

	test	esi, esi
	je	SHORT $LN45@delete_obj

; 255  : 		{
; 256  : 			if (destroy_flag)

	cmp	BYTE PTR _destroy_flag$[ebp], 0
	je	SHORT $LN6@delete_obj

; 257  : 			{
; 258  : 				ObjType * &		obj_ptr = cell_ptr->_val;
; 259  : 				delete obj_ptr;

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN8@delete_obj
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN8@delete_obj:

; 260  : 				obj_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN6@delete_obj:
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 165  : 	_cell_stack.push (cell);

	push	esi
	lea	ecx, DWORD PTR [ebx+72]
	call	?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push

; 166  : 
; 167  : 	++ _nbr_avail_cells;

	lea	esi, DWORD PTR [ebx+352]
$LL23@delete_obj:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL23@delete_obj
; File c:\github\mvtools\sources\conc\objpool.hpp

; 264  : 			++ count;

	inc	edi

; 265  : 		}
; 266  : 	}
; 267  : 	while (cell_ptr != 0);

	jmp	SHORT $LL4@delete_obj
$LN45@delete_obj:

; 268  : 
; 269  : 	return (count);

	mov	eax, edi

; 270  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?delete_obj_stack@?$ObjPool@VWorkingArea@PlaneOfBlocks@@@conc@@AAEHAAV?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@2@_N@Z ENDP ; conc::ObjPool<PlaneOfBlocks::WorkingArea>::delete_obj_stack
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\critsec.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicptr.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z
_TEXT	SEGMENT
_lock$ = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_zone_index$dead$ = 8					; size = 4
tv278 = 12						; size = 4
$T2 = 12						; size = 4
_cur_size$ = 12						; size = 4
_zone_ptr_ref$ = 16					; size = 4
?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::allocate_zone, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	eax, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], eax

; 183  : 	assert (zone_index >= 0);
; 184  : 	assert (zone_index < MAX_NBR_ZONES);
; 185  : 
; 186  : 	CritSec			lock (_alloc_mutex);

	lea	esi, DWORD PTR [eax+296]
; File c:\github\mvtools\sources\conc\mutex.hpp

; 53   : 	::EnterCriticalSection (&_crit_sec);

	push	esi
; File c:\github\mvtools\sources\conc\critsec.hpp

; 41   : :	_mutex (mutex)

	mov	DWORD PTR _lock$[ebp], esi
; File c:\github\mvtools\sources\conc\mutex.hpp

; 53   : 	::EnterCriticalSection (&_crit_sec);

	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 188  : 	CellType *		zone_ptr = new CellType [cur_size];

	mov	ebx, DWORD PTR _cur_size$[ebp]
	xor	ecx, ecx
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi
	test	edi, edi
	je	SHORT $LN8@allocate_z
	mov	eax, ebx
	mov	ecx, edi
	test	ebx, ebx
	je	SHORT $LN9@allocate_z
	npad	7
$LL17@allocate_z:
; File c:\github\mvtools\sources\conc\atomicptr.hpp

; 43   : :	_ptr ()

	mov	DWORD PTR [ecx], 0
	lea	ecx, DWORD PTR [ecx+8]
	sub	eax, 1
	jne	SHORT $LL17@allocate_z
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 188  : 	CellType *		zone_ptr = new CellType [cur_size];

	jmp	SHORT $LN9@allocate_z
$LN8@allocate_z:
	xor	edi, edi
$LN9@allocate_z:
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, DWORD PTR _zone_ptr_ref$[ebp]
	mov	edx, edi
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 190  : 	if (zone_ptr_ref.cas (zone_ptr, 0) != (CellType *)0)

	test	eax, eax
	je	SHORT $LN5@allocate_z

; 191  : 	{
; 192  : 		// CAS has failed, meaning that another thread is allocating this zone.
; 193  : 		delete [] zone_ptr;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 194  : 
; 195  : 		// Note: because of the mutex, this part shouldn't be accessed.
; 196  : 	}
; 197  : 
; 198  : 	else

	jmp	SHORT $LN3@allocate_z
$LN5@allocate_z:

; 201  : 		for (size_t pos = 0; pos < cur_size; ++pos)

	test	ebx, ebx
	je	SHORT $LN3@allocate_z
	mov	esi, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR [esi+8]
	add	esi, 288				; 00000120H
	mov	DWORD PTR tv278[ebp], eax
	npad	1
$LL4@allocate_z:

; 202  : 		{
; 203  : 			CellType &		cell = zone_ptr [pos];
; 204  : 			_cell_stack.push (cell);

	push	edi
	mov	ecx, eax
	call	?push@?$LockFreeStack@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAEXAAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@@Z ; conc::LockFreeStack<PlaneOfBlocks::WorkingArea *>::push
$LL41@allocate_z:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL41@allocate_z
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 201  : 		for (size_t pos = 0; pos < cur_size; ++pos)

	mov	eax, DWORD PTR tv278[ebp]
	add	edi, 8
	sub	ebx, 1
	jne	SHORT $LL4@allocate_z
	mov	esi, DWORD PTR _lock$[ebp]
$LN3@allocate_z:
; File c:\github\mvtools\sources\conc\mutex.hpp

; 60   : 	::LeaveCriticalSection (&_crit_sec);

	push	esi
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 209  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z$0:
	lea	ecx, DWORD PTR _lock$[ebp]
	jmp	??1CritSec@conc@@QAE@XZ			; conc::CritSec::~CritSec
__ehhandler$?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?allocate_zone@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@2@@Z ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::allocate_zone
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?compute_grown_size@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@CAII@Z
_TEXT	SEGMENT
?compute_grown_size@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@CAII@Z PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::compute_grown_size, COMDAT
; _prev_size$ = ecx

; 216  : 	assert (prev_size >= BASE_SIZE);
; 217  : 
; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	eax, DWORD PTR [ecx+ecx*2]
	shr	eax, 1

; 219  : }

	ret	0
?compute_grown_size@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@CAII@Z ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::compute_grown_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?compute_total_size_for_zones@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@CAIH@Z
_TEXT	SEGMENT
?compute_total_size_for_zones@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@CAIH@Z PROC ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::compute_total_size_for_zones, COMDAT
; _nbr_zones$ = ecx

; 225  : {

	push	ebx
	push	ebp
	push	esi
	xor	edx, edx
	xor	esi, esi
	push	edi
	mov	edi, ecx

; 226  : 	assert (nbr_zones >= 0);
; 227  : 	assert (nbr_zones <= MAX_NBR_ZONES);
; 228  : 
; 229  : 	size_t			cur_size = BASE_SIZE;
; 230  : 	size_t			total_size = 0;

	xor	ebx, ebx

; 231  : 	int				zone_index = 0;
; 232  : 	while (zone_index < nbr_zones)

	xor	ebp, ebp
	lea	eax, DWORD PTR [edx+64]
	cmp	edi, 2
	jl	SHORT $LC13@compute_to
	lea	ecx, DWORD PTR [edi-2]
	shr	ecx, 1
	inc	ecx
	lea	ebp, DWORD PTR [ecx+ecx]
	npad	1
$LL14@compute_to:

; 233  : 	{
; 234  : 		total_size += cur_size;

	add	edx, eax

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	eax, DWORD PTR [eax+eax*2]
	shr	eax, 1

; 233  : 	{
; 234  : 		total_size += cur_size;

	add	esi, eax

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	eax, DWORD PTR [eax+eax*2]
	shr	eax, 1
	sub	ecx, 1
	jne	SHORT $LL14@compute_to
$LC13@compute_to:

; 231  : 	int				zone_index = 0;
; 232  : 	while (zone_index < nbr_zones)

	cmp	ebp, edi
	pop	edi
	cmovl	ebx, eax
	lea	eax, DWORD PTR [esi+edx]
	pop	esi
	pop	ebp
	add	eax, ebx
	pop	ebx

; 235  : 		cur_size = compute_grown_size (cur_size);
; 236  : 		++ zone_index;
; 237  : 	}
; 238  : 
; 239  : 	return (total_size);
; 240  : }

	ret	0
?compute_total_size_for_zones@?$CellPool@PAVWorkingArea@PlaneOfBlocks@@@conc@@CAIH@Z ENDP ; conc::CellPool<PlaneOfBlocks::WorkingArea *>::compute_total_size_for_zones
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??0?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE@XZ PROC ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >, COMDAT
; _this$ = ecx

; 43   : :	_ptr ()

	mov	DWORD PTR [ecx], 0

; 45   : 	assert (is_ptr_aligned_nz ((const void *) (&_ptr), sizeof (_ptr)));
; 46   : }

	mov	eax, ecx
	ret	0
??0?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE@XZ ENDP ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??4?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEAAV01@PAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@1@@Z
_TEXT	SEGMENT
_other_ptr$ = 8						; size = 4
??4?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEAAV01@PAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@1@@Z PROC ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::operator=, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	mov	eax, DWORD PTR _other_ptr$[esp-4]
	xchg	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\conc\atomicptr.hpp

; 64   : 	return (*this);

	mov	eax, ecx

; 65   : }

	ret	4
??4?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEAAV01@PAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@1@@Z ENDP ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??B?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@1@XZ
_TEXT	SEGMENT
??B?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@1@XZ PROC ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::operator conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> *, COMDAT
; _this$ = ecx

; 72   : 	return (read_ptr ());

	mov	eax, DWORD PTR [ecx]

; 73   : }

	ret	0
??B?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@1@XZ ENDP ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::operator conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@$0EA@@conc@@QAEAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@1@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@$0EA@@conc@@QAEAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@1@J@Z PROC ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 56   : }

	ret	4
??A?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@$0EA@@conc@@QAEAAV?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@1@J@Z ENDP ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >,64>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ??0?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE@XZ PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >, COMDAT
; _this$ = ecx

; 41   : {

	mov	DWORD PTR [ecx], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@6B@
	xorps	xmm0, xmm0
	movq	QWORD PTR [ecx+8], xmm0
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]

; 42   : 	conc_CHECK_CT (DataSize, sizeof (RealContent) == sizeof (DataType));
; 43   : 
; 44   : 	set (0, 0);
; 45   : }

	mov	eax, ecx

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [ecx+8], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [ecx+12], 0

; 42   : 	conc_CHECK_CT (DataSize, sizeof (RealContent) == sizeof (DataType));
; 43   : 
; 44   : 	set (0, 0);
; 45   : }

	ret	0
??0?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE@XZ ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?set@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEXPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@H@Z
_TEXT	SEGMENT
_ptr$dead$ = 8						; size = 4
_val$dead$ = 12						; size = 4
?set@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEXPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@H@Z PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::set, COMDAT
; _this$ = ecx

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [ecx+8], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [ecx+12], 0

; 53   : }

	ret	8
?set@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEXPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@H@Z ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?get_ptr@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ
_TEXT	SEGMENT
?get_ptr@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::get_ptr, COMDAT
; _this$ = ecx

; 81   : 	return (_data._content._ptr);

	mov	eax, DWORD PTR [ecx+8]

; 82   : }

	ret	0
?get_ptr@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::get_ptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?get_val@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEHXZ
_TEXT	SEGMENT
?get_val@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEHXZ PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::get_val, COMDAT
; _this$ = ecx

; 89   : 	return (_data._content._val);

	mov	eax, DWORD PTR [ecx+12]

; 90   : }

	ret	0
?get_val@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QBEHXZ ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::get_val
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?cas2@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE_NPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@H0H@Z
_TEXT	SEGMENT
_comp$ = -16						; size = 8
_newx$ = -8						; size = 8
_new_ptr$ = 8						; size = 4
_new_val$ = 12						; size = 4
_comp_ptr$ = 16						; size = 4
_comp_val$ = 20						; size = 4
?cas2@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE_NPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@H0H@Z PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas2, COMDAT
; _this$ = ecx

; 110  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H

; 111  : 	Combi				newx;
; 112  : 	newx._content._ptr = new_ptr;

	mov	eax, DWORD PTR _new_ptr$[ebp]
	mov	DWORD PTR _newx$[esp+16], eax

; 113  : 	newx._content._val = new_val;

	mov	eax, DWORD PTR _new_val$[ebp]
	mov	DWORD PTR _newx$[esp+20], eax

; 114  : 
; 115  : 	Combi				comp;
; 116  : 	comp._content._ptr = comp_ptr;

	mov	eax, DWORD PTR _comp_ptr$[ebp]
	mov	DWORD PTR _comp$[esp+16], eax

; 117  : 	comp._content._val = comp_val;

	mov	eax, DWORD PTR _comp_val$[ebp]
	push	ebx
	mov	DWORD PTR _comp$[esp+24], eax
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, DWORD PTR _comp$[esp+20]
	mov	edx, DWORD PTR _comp$[esp+24]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 110  : {

	push	esi

; 149  : 	old._storage = Interlocked::cas (

	lea	esi, DWORD PTR [ecx+8]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	ebx, DWORD PTR _newx$[esp+24]
	mov	ecx, DWORD PTR _newx$[esp+28]
	lock	 cmpxchg8b QWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 122  : 	return (old._storage == comp._storage);

	cmp	eax, DWORD PTR _comp$[esp+24]
	jne	SHORT $LN3@cas2
	cmp	edx, DWORD PTR _comp$[esp+28]
	jne	SHORT $LN3@cas2
	mov	al, 1

; 123  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@cas2:
	pop	esi
	xor	al, al
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?cas2@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAE_NPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@H0H@Z ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?compute_total_size_for_zones@?$CellPool@PAVDCTClass@@@conc@@CAIH@Z
_TEXT	SEGMENT
?compute_total_size_for_zones@?$CellPool@PAVDCTClass@@@conc@@CAIH@Z PROC ; conc::CellPool<DCTClass *>::compute_total_size_for_zones, COMDAT
; _nbr_zones$ = ecx

; 225  : {

	push	ebx
	push	ebp
	push	esi
	xor	edx, edx
	xor	esi, esi
	push	edi
	mov	edi, ecx

; 226  : 	assert (nbr_zones >= 0);
; 227  : 	assert (nbr_zones <= MAX_NBR_ZONES);
; 228  : 
; 229  : 	size_t			cur_size = BASE_SIZE;
; 230  : 	size_t			total_size = 0;

	xor	ebx, ebx

; 231  : 	int				zone_index = 0;
; 232  : 	while (zone_index < nbr_zones)

	xor	ebp, ebp
	lea	eax, DWORD PTR [edx+64]
	cmp	edi, 2
	jl	SHORT $LC13@compute_to
	lea	ecx, DWORD PTR [edi-2]
	shr	ecx, 1
	inc	ecx
	lea	ebp, DWORD PTR [ecx+ecx]
	npad	1
$LL14@compute_to:

; 233  : 	{
; 234  : 		total_size += cur_size;

	add	edx, eax

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	eax, DWORD PTR [eax+eax*2]
	shr	eax, 1

; 233  : 	{
; 234  : 		total_size += cur_size;

	add	esi, eax

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	eax, DWORD PTR [eax+eax*2]
	shr	eax, 1
	sub	ecx, 1
	jne	SHORT $LL14@compute_to
$LC13@compute_to:

; 231  : 	int				zone_index = 0;
; 232  : 	while (zone_index < nbr_zones)

	cmp	ebp, edi
	pop	edi
	cmovl	ebx, eax
	lea	eax, DWORD PTR [esi+edx]
	pop	esi
	pop	ebp
	add	eax, ebx
	pop	ebx

; 235  : 		cur_size = compute_grown_size (cur_size);
; 236  : 		++ zone_index;
; 237  : 	}
; 238  : 
; 239  : 	return (total_size);
; 240  : }

	ret	0
?compute_total_size_for_zones@?$CellPool@PAVDCTClass@@@conc@@CAIH@Z ENDP ; conc::CellPool<DCTClass *>::compute_total_size_for_zones
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiosub.hpp
;	COMDAT ??R?$AioSub@H@conc@@QBEHH@Z
_TEXT	SEGMENT
_old_val$ = 8						; size = 4
??R?$AioSub@H@conc@@QBEHH@Z PROC			; conc::AioSub<int>::operator(), COMDAT
; _this$ = ecx

; 48   : 	return (old_val - _operand);

	mov	eax, DWORD PTR _old_val$[esp-4]
	sub	eax, DWORD PTR [ecx+4]

; 49   : }

	ret	4
??R?$AioSub@H@conc@@QBEHH@Z ENDP			; conc::AioSub<int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@E@std@@YAPAEPAE@Z
_TEXT	SEGMENT
??$_Unfancy@E@std@@YAPAEPAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@E@std@@YAPAEPAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@UVECTOR@@@std@@YAPAUVECTOR@@PAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@UVECTOR@@@std@@YAPAUVECTOR@@PAU1@@Z PROC	; std::_Unfancy<VECTOR>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@UVECTOR@@@std@@YAPAUVECTOR@@PAU1@@Z ENDP	; std::_Unfancy<VECTOR>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z
_TEXT	SEGMENT
_atom$1$ = -8						; size = 4
_ftor$1$ = -4						; size = 4
_val_old$ = 8						; size = 4
_val_new$ = 12						; size = 4
??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z PROC ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 83   : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	eax, ecx
	mov	DWORD PTR _ftor$1$[esp+20], edx
	push	edi
	mov	DWORD PTR _atom$1$[esp+24], eax
$LL4@exec_both:

; 84   : 	assert (&atom != 0);
; 85   : 	assert (&ftor != 0);
; 86   : 
; 87   : 	T					val_cur;
; 88   : 	do
; 89   : 	{
; 90   : 		val_cur = atom;

	mov	edi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	add	ecx, edi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	edx, DWORD PTR _val_new$[esp+20]
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	adc	eax, ebp
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	DWORD PTR [edx], ecx
	mov	ecx, edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	edx, ebp
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	DWORD PTR [ecx+4], eax
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, edi
	mov	ebx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR _atom$1$[esp+24]
	lock	 cmpxchg8b QWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 92   : 		val_old = atom.cas (val_new, val_cur);

	mov	esi, DWORD PTR _val_old$[esp+20]

; 93   : 	}
; 94   : 	while (val_old != val_cur);

	cmp	eax, edi
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _atom$1$[esp+24]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR _ftor$1$[esp+24]
	jne	SHORT $LL4@exec_both
	cmp	DWORD PTR [esi+4], ebp
	jne	SHORT $LL4@exec_both

; 95   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$exec_both@_JV?$AioAdd@_J@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@_J@1@AAV?$AioAdd@_J@1@AA_J2@Z ENDP ; conc::AtomicIntOp::exec_both<__int64,conc::AioAdd<__int64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVDCTClass@@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAVDCTClass@@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@@Z PROC ; std::allocator<DCTClass *>::destroy<DCTClass *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAVDCTClass@@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@@Z ENDP ; std::allocator<DCTClass *>::destroy<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVDCTClass@@AAPAV1@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVDCTClass@@AAPAV1@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@AAPAV2@@Z PROC ; std::allocator<DCTClass *>::construct<DCTClass *,DCTClass * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	ret	8
??$construct@PAVDCTClass@@AAPAV1@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@AAPAV2@@Z ENDP ; std::allocator<DCTClass *>::construct<DCTClass *,DCTClass * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVDCTClass@@ABQAV1@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVDCTClass@@ABQAV1@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@ABQAV2@@Z PROC ; std::allocator<DCTClass *>::construct<DCTClass *,DCTClass * const &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	ret	8
??$construct@PAVDCTClass@@ABQAV1@@?$allocator@PAVDCTClass@@@std@@QAEXPAPAVDCTClass@@ABQAV2@@Z ENDP ; std::allocator<DCTClass *>::construct<DCTClass *,DCTClass * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UVECTOR@@$$V@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEXPAUVECTOR@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@UVECTOR@@$$V@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEXPAUVECTOR@@@Z PROC ; std::_Wrap_alloc<std::allocator<VECTOR> >::construct<VECTOR>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN7@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
$LN7@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	4
??$construct@UVECTOR@@$$V@?$_Wrap_alloc@V?$allocator@UVECTOR@@@std@@@std@@QAEXPAUVECTOR@@@Z ENDP ; std::_Wrap_alloc<std::allocator<VECTOR> >::construct<VECTOR>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVDCTClass@@@std@@YAPAPAVDCTClass@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unchecked@PAPAVDCTClass@@@std@@YAPAPAVDCTClass@@PAPAV1@@Z PROC ; std::_Unchecked<DCTClass * *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAPAVDCTClass@@@std@@YAPAPAVDCTClass@@PAPAV1@@Z ENDP ; std::_Unchecked<DCTClass * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAPAVDCTClass@@PAPAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAPAVDCTClass@@PAPAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<DCTClass * *,DCTClass * *,std::allocator<DCTClass *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 306  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked@PAPAVDCTClass@@PAPAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<DCTClass * *,DCTClass * *,std::allocator<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVDCTClass@@PAPAV1@@std@@YAAAPAPAVDCTClass@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
??$_Rechecked@PAPAVDCTClass@@PAPAV1@@std@@YAAAPAPAVDCTClass@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<DCTClass * *,DCTClass * *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAPAVDCTClass@@PAPAV1@@std@@YAAAPAPAVDCTClass@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<DCTClass * *,DCTClass * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ecx

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
	push	DWORD PTR $T1[esp+8]
	push	ecx
	push	DWORD PTR __Dest$[esp+12]
	call	??$_Uninitialized_move_al_unchecked1@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Uninitialized_move_al_unchecked@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@E@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAE@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@E@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAE@Z PROC ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::destroy<unsigned char>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@E@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAE@Z ENDP ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::destroy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??0?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ PROC ; conc::LockFreeCell<PlaneOfBlocks::WorkingArea *>::LockFreeCell<PlaneOfBlocks::WorkingArea *>, COMDAT
; _this$ = ecx

; 43   : :	_ptr ()

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@QAE@XZ ENDP ; conc::LockFreeCell<PlaneOfBlocks::WorkingArea *>::LockFreeCell<PlaneOfBlocks::WorkingArea *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??Z?$AtomicInt@I@conc@@QAEAAV01@ABI@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??Z?$AtomicInt@I@conc@@QAEAAV01@ABI@Z PROC		; conc::AtomicInt<unsigned int>::operator-=, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR _other$[esp-4]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 129  : {

	push	esi
	push	edi
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 38   : :	_operand (operand)

	mov	edi, DWORD PTR [eax]
$LL10@operator:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	mov	edx, esi
	sub	edx, edi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL10@operator
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 135  : 	return (*this);

	pop	edi
	mov	eax, ecx

; 136  : }

	pop	esi
	ret	4
??Z?$AtomicInt@I@conc@@QAEAAV01@ABI@Z ENDP		; conc::AtomicInt<unsigned int>::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ?cas@?$AtomicInt@_J@conc@@QAE_J_J0@Z
_TEXT	SEGMENT
_other$ = 8						; size = 8
_comp$ = 16						; size = 8
?cas@?$AtomicInt@_J@conc@@QAE_J_J0@Z PROC		; conc::AtomicInt<__int64>::cas, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, DWORD PTR _comp$[esp-4]
	mov	edx, DWORD PTR _comp$[esp]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 108  : {

	push	ebx
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	ecx, DWORD PTR _other$[esp+8]
	mov	ebx, DWORD PTR _other$[esp+4]
	lock	 cmpxchg8b QWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 110  : }

	pop	esi
	pop	ebx
	ret	16					; 00000010H
?cas@?$AtomicInt@_J@conc@@QAE_J_J0@Z ENDP		; conc::AtomicInt<__int64>::cas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ?cas@?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@PAV32@0@Z
_TEXT	SEGMENT
_other_ptr$ = 8						; size = 4
_comp_ptr$dead$ = 12					; size = 4
?cas@?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@PAV32@0@Z PROC ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	edx, DWORD PTR _other_ptr$[esp-4]
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicptr.hpp

; 114  : }

	ret	8
?cas@?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@QAEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@PAV32@0@Z ENDP ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ?read_ptr@?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@ABEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ
_TEXT	SEGMENT
?read_ptr@?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@ABEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ PROC ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::read_ptr, COMDAT
; _this$ = ecx

; 129  : 	return (static_cast <T *> (_ptr));

	mov	eax, DWORD PTR [ecx]

; 130  : }

	ret	0
?read_ptr@?$AtomicPtr@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@ABEPAV?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@2@XZ ENDP ; conc::AtomicPtr<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::read_ptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?cas_combi@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@CAXAATCombi@12@0ABT312@1@Z
_TEXT	SEGMENT
_excg$ = 8						; size = 4
_comp$ = 12						; size = 4
?cas_combi@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@CAXAATCombi@12@0ABT312@1@Z PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas_combi, COMDAT
; _old$ = ecx
; _dest$ = edx

; 137  : {

	push	ebx
	push	ebp
	push	esi

; 138  : #if (conc_WORD_SIZE == 64)
; 139  : 
; 140  : 	Interlocked::cas (
; 141  : 		old._storage,
; 142  : 		dest._storage,
; 143  : 		excg._storage,
; 144  : 		comp._storage
; 145  : 	);
; 146  : 
; 147  : #else		// conc_WORD_SIZE
; 148  : 
; 149  : 	old._storage = Interlocked::cas (

	mov	esi, DWORD PTR _comp$[esp+8]
	mov	ebp, ecx
	push	edi
	mov	edi, edx
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	esi, DWORD PTR _excg$[esp+12]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	ebx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	lock	 cmpxchg8b QWORD PTR [edi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 156  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], edx
	pop	ebp
	pop	ebx
	ret	0
?cas_combi@?$AtomicPtrIntPair@V?$LockFreeCell@PAVWorkingArea@PlaneOfBlocks@@@conc@@@conc@@CAXAATCombi@12@0ABT312@1@Z ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<PlaneOfBlocks::WorkingArea *> >::cas_combi
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.hpp
;	COMDAT ??R?$AioAdd@_J@conc@@QBE_J_J@Z
_TEXT	SEGMENT
_old_val$ = 8						; size = 8
??R?$AioAdd@_J@conc@@QBE_J_J@Z PROC			; conc::AioAdd<__int64>::operator(), COMDAT
; _this$ = ecx

; 48   : 	return (old_val + _operand);

	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR _old_val$[esp-4]
	mov	edx, DWORD PTR [ecx+12]
	adc	edx, DWORD PTR _old_val$[esp]

; 49   : }

	ret	8
??R?$AioAdd@_J@conc@@QBE_J_J@Z ENDP			; conc::AioAdd<__int64>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UVECTOR@@$$V@?$allocator_traits@V?$allocator@UVECTOR@@@std@@@std@@SAXAAV?$allocator@UVECTOR@@@1@PAUVECTOR@@@Z
_TEXT	SEGMENT
??$construct@UVECTOR@@$$V@?$allocator_traits@V?$allocator@UVECTOR@@@std@@@std@@SAXAAV?$allocator@UVECTOR@@@1@PAUVECTOR@@@Z PROC ; std::allocator_traits<std::allocator<VECTOR> >::construct<VECTOR>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN5@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], 0
$LN5@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@UVECTOR@@$$V@?$allocator_traits@V?$allocator@UVECTOR@@@std@@@std@@SAXAAV?$allocator@UVECTOR@@@1@PAUVECTOR@@@Z ENDP ; std::allocator_traits<std::allocator<VECTOR> >::construct<VECTOR>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@PAVDCTClass@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVDCTClass@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@PAVDCTClass@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVDCTClass@@0@Z PROC ; std::_Ptr_move_cat<DCTClass *,DCTClass *>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	mov	eax, ecx

; 811  : 	}

	ret	0
??$_Ptr_move_cat@PAVDCTClass@@PAV1@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVDCTClass@@0@Z ENDP ; std::_Ptr_move_cat<DCTClass *,DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAVDCTClass@@PAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@PAVDCTClass@@PAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<DCTClass *,DCTClass *,std::allocator<DCTClass *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 294  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked1@PAVDCTClass@@PAV1@V?$allocator@PAVDCTClass@@@std@@@std@@YAPAPAVDCTClass@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDCTClass@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<DCTClass *,DCTClass *,std::allocator<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z PROC ; std::_Ptr_move_cat<unsigned char,unsigned char>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	mov	eax, ecx

; 811  : 	}

	ret	0
??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ENDP ; std::_Ptr_move_cat<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	xor	eax, eax
	mov	ebx, edx
	xor	esi, esi
	sub	ebx, edi
	cmp	edi, edx
	cmova	ebx, eax

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Dest$[esp+8]
	test	ebx, ebx
	je	SHORT $LN3@Uninitiali
	sub	edi, eax
	npad	4
$LL4@Uninitiali:
; File c:\github\mvtools\sources\allocalign.hpp

; 116  : 	new (ptr) T (t);

	test	eax, eax
	je	SHORT $LN2@Uninitiali
	mov	cl, BYTE PTR [edi+eax]
	mov	BYTE PTR [eax], cl
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	inc	esi
	inc	eax
	cmp	esi, ebx
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	edi
	pop	esi
	pop	ebx

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);
; 285  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked1@PAEPAEV?$AllocAlign@E$0BA@@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<unsigned char *,unsigned char *,AllocAlign<unsigned char,16> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	mov	eax, ecx
	ret	4
??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@E@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAE@Z
_TEXT	SEGMENT
??$destroy@E@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAE@Z PROC ; std::allocator_traits<AllocAlign<unsigned char,16> >::destroy<unsigned char>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 643  : 		_Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Unwrap_alloc_t<_Alloc>, _Ty *>());
; 644  : 		}

	ret	0
??$destroy@E@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAE@Z ENDP ; std::allocator_traits<AllocAlign<unsigned char,16> >::destroy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiosub.h
;	COMDAT ??1?$AioSub@I@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$AioSub@I@conc@@UAE@XZ PROC				; conc::AioSub<unsigned int>::~AioSub<unsigned int>, COMDAT
; _this$ = ecx

; 50   : 	virtual			~AioSub () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$AioSub@I@conc@@6B@
	ret	0
??1?$AioSub@I@conc@@UAE@XZ ENDP				; conc::AioSub<unsigned int>::~AioSub<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiosub.h
;	COMDAT ??_G?$AioSub@I@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$AioSub@I@conc@@UAEPAXI@Z PROC			; conc::AioSub<unsigned int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 50   : 	virtual			~AioSub () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$AioSub@I@conc@@6B@
	je	SHORT $LN7@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$AioSub@I@conc@@UAEPAXI@Z ENDP			; conc::AioSub<unsigned int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAE@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
??$move@AAE@std@@YA$$QAEAAE@Z PROC			; std::move<unsigned char &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAE@std@@YA$$QAEAAE@Z ENDP			; std::move<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiosub.hpp
;	COMDAT ??0?$AioSub@I@conc@@QAE@I@Z
_TEXT	SEGMENT
_operand$ = 8						; size = 4
??0?$AioSub@I@conc@@QAE@I@Z PROC			; conc::AioSub<unsigned int>::AioSub<unsigned int>, COMDAT
; _this$ = ecx

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR _operand$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 40   : 	// Nothing
; 41   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$AioSub@I@conc@@6B@
	ret	4
??0?$AioSub@I@conc@@QAE@I@Z ENDP			; conc::AioSub<unsigned int>::AioSub<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec@IV?$AioSub@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioSub@I@1@@Z
_TEXT	SEGMENT
??$exec@IV?$AioSub@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioSub@I@1@@Z PROC ; conc::AtomicIntOp::exec<unsigned int,conc::AioSub<unsigned int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 40   : {

	push	esi
	push	edi
$LL6@exec:

; 90   : 		val_cur = atom;

	mov	edi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	mov	esi, edi
	sub	esi, DWORD PTR [edx+4]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edi
	lock	 cmpxchg DWORD PTR [ecx], esi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edi
	jne	SHORT $LL6@exec

; 41   : 	assert (&atom != 0);
; 42   : 	assert (&ftor != 0);
; 43   : 
; 44   : 	T					val_new;
; 45   : 	T					val_old;
; 46   : 	exec_both (atom, ftor, val_old, val_new);
; 47   : }

	pop	edi
	pop	esi
	ret	0
??$exec@IV?$AioSub@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioSub@I@1@@Z ENDP ; conc::AtomicIntOp::exec<unsigned int,conc::AioSub<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UVECTOR@@$$V@?$allocator@UVECTOR@@@std@@QAEXPAUVECTOR@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@UVECTOR@@$$V@?$allocator@UVECTOR@@@std@@QAEXPAUVECTOR@@@Z PROC ; std::allocator<VECTOR>::construct<VECTOR>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
$LN3@construct:

; 738  : 		}

	ret	4
??$construct@UVECTOR@@$$V@?$allocator@UVECTOR@@@std@@QAEXPAUVECTOR@@@Z ENDP ; std::allocator<VECTOR>::construct<VECTOR>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVDCTClass@@PAPAV1@@std@@YAPAPAVDCTClass@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAPAVDCTClass@@PAPAV1@@std@@YAPAPAVDCTClass@@PAPAV1@00@Z PROC ; std::_Copy_memmove<DCTClass * *,DCTClass * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2301 : 	{	// implement copy-like function as memmove

	push	esi

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;
; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	ret	0
??$_Copy_memmove@PAPAVDCTClass@@PAPAV1@@std@@YAPAPAVDCTClass@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<DCTClass * *,DCTClass * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@EE@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAE$$QAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@EE@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAE$$QAE@Z PROC ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::construct<unsigned char,unsigned char>, COMDAT
; _this$dead$ = ecx
; File c:\github\mvtools\sources\allocalign.hpp

; 116  : 	new (ptr) T (t);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN18@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx], al
$LN18@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	8
??$construct@EE@?$_Wrap_alloc@V?$AllocAlign@E$0BA@@@@std@@QAEXPAE$$QAE@Z ENDP ; std::_Wrap_alloc<AllocAlign<unsigned char,16> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy1@E@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAEU?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy1@E@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAEU?$integral_constant@_N$0A@@1@@Z PROC ; std::allocator_traits<AllocAlign<unsigned char,16> >::_Destroy1<unsigned char>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 637  : 		_Al.destroy(_Ptr);
; 638  : 		}

	ret	0
??$_Destroy1@E@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAEU?$integral_constant@_N$0A@@1@@Z ENDP ; std::allocator_traits<AllocAlign<unsigned char,16> >::_Destroy1<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\allocalign.hpp
;	COMDAT ?destroy@?$AllocAlign@E$0BA@@@QAEXPAE@Z
_TEXT	SEGMENT
_ptr$dead$ = 8						; size = 4
?destroy@?$AllocAlign@E$0BA@@@QAEXPAE@Z PROC		; AllocAlign<unsigned char,16>::destroy, COMDAT
; _this$dead$ = ecx

; 124  : 	assert (ptr != 0);
; 125  : 
; 126  : 	ptr->~T ();
; 127  : }

	ret	4
?destroy@?$AllocAlign@E$0BA@@@QAEXPAE@Z ENDP		; AllocAlign<unsigned char,16>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aiosub.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_both@IV?$AioSub@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioSub@I@1@AAI2@Z
_TEXT	SEGMENT
_val_old$ = 8						; size = 4
_val_new$ = 12						; size = 4
??$exec_both@IV?$AioSub@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioSub@I@1@AAI2@Z PROC ; conc::AtomicIntOp::exec_both<unsigned int,conc::AioSub<unsigned int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 83   : {

	push	ebx
	mov	ebx, DWORD PTR _val_new$[esp]
	push	ebp
	mov	ebp, DWORD PTR _val_old$[esp+4]
	push	esi
	push	edi
	mov	edi, edx
	npad	2
$LL4@exec_both:

; 84   : 	assert (&atom != 0);
; 85   : 	assert (&ftor != 0);
; 86   : 
; 87   : 	T					val_cur;
; 88   : 	do
; 89   : 	{
; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\aiosub.hpp

; 48   : 	return (old_val - _operand);

	mov	edx, esi
	sub	edx, DWORD PTR [edi+4]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	DWORD PTR [ebx], edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 92   : 		val_old = atom.cas (val_new, val_cur);

	mov	DWORD PTR [ebp], eax

; 93   : 	}
; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL4@exec_both

; 95   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$exec_both@IV?$AioSub@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioSub@I@1@AAI2@Z ENDP ; conc::AtomicIntOp::exec_both<unsigned int,conc::AioSub<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@E@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
??$forward@E@std@@YA$$QAEAAE@Z PROC			; std::forward<unsigned char>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@E@std@@YA$$QAEAAE@Z ENDP			; std::forward<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@EE@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAE$$QAE@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@EE@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAE$$QAE@Z PROC ; std::allocator_traits<AllocAlign<unsigned char,16> >::construct<unsigned char,unsigned char>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File c:\github\mvtools\sources\allocalign.hpp

; 116  : 	new (ptr) T (t);

	test	edx, edx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx], al
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 626  : 		}

	ret	0
??$construct@EE@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXAAV?$AllocAlign@E$0BA@@@PAE$$QAE@Z ENDP ; std::allocator_traits<AllocAlign<unsigned char,16> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiosub.hpp
;	COMDAT ??R?$AioSub@I@conc@@QBEII@Z
_TEXT	SEGMENT
_old_val$ = 8						; size = 4
??R?$AioSub@I@conc@@QBEII@Z PROC			; conc::AioSub<unsigned int>::operator(), COMDAT
; _this$ = ecx

; 48   : 	return (old_val - _operand);

	mov	eax, DWORD PTR _old_val$[esp-4]
	sub	eax, DWORD PTR [ecx+4]

; 49   : }

	ret	4
??R?$AioSub@I@conc@@QBEII@Z ENDP			; conc::AioSub<unsigned int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\allocalign.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Construct1@EE@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXU?$integral_constant@_N$0A@@1@AAV?$AllocAlign@E$0BA@@@PAE$$QAE@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Args_0>$ = 12					; size = 4
??$_Construct1@EE@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXU?$integral_constant@_N$0A@@1@AAV?$AllocAlign@E$0BA@@@PAE$$QAE@Z PROC ; std::allocator_traits<AllocAlign<unsigned char,16> >::_Construct1<unsigned char,unsigned char>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File c:\github\mvtools\sources\allocalign.hpp

; 116  : 	new (ptr) T (t);

	test	edx, edx
	je	SHORT $LN8@Construct1
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx], al
$LN8@Construct1:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 617  : 		}

	ret	0
??$_Construct1@EE@?$allocator_traits@V?$AllocAlign@E$0BA@@@@std@@SAXU?$integral_constant@_N$0A@@1@AAV?$AllocAlign@E$0BA@@@PAE$$QAE@Z ENDP ; std::allocator_traits<AllocAlign<unsigned char,16> >::_Construct1<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\allocalign.hpp
;	COMDAT ?construct@?$AllocAlign@E$0BA@@@QAEXPAEABE@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_t$ = 12						; size = 4
?construct@?$AllocAlign@E$0BA@@@QAEXPAEABE@Z PROC	; AllocAlign<unsigned char,16>::construct, COMDAT
; _this$dead$ = ecx

; 114  : 	assert (ptr != 0);
; 115  : 
; 116  : 	new (ptr) T (t);

	mov	ecx, DWORD PTR _ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _t$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx], al
$LN3@construct:

; 117  : }

	ret	8
?construct@?$AllocAlign@E$0BA@@@QAEXPAEABE@Z ENDP	; AllocAlign<unsigned char,16>::construct
_TEXT	ENDS
END
