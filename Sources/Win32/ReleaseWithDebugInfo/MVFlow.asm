; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvflow.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BP@CLENLPGI@MFlow?5?3?5wrong?5super?5frame?5clip?$AA@ ; `string'
PUBLIC	??_7MVFlow@@6B@					; MVFlow::`vftable'
PUBLIC	??_R0?AVMVFlow@@@8				; MVFlow `RTTI Type Descriptor'
PUBLIC	??_R3MVFlow@@8					; MVFlow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MVFlow@@8					; MVFlow::`RTTI Base Class Array'
PUBLIC	??_R4MVFlow@@6B@				; MVFlow::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@MVFlow@@8				; MVFlow::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@MVFlow@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVFlow@@8 DD FLAT:??_R0?AVMVFlow@@@8	; MVFlow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVFlow@@8
rdata$r	ENDS
;	COMDAT ??_R4MVFlow@@6B@
rdata$r	SEGMENT
??_R4MVFlow@@6B@ DD 00H					; MVFlow::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVFlow@@@8
	DD	FLAT:??_R3MVFlow@@8
rdata$r	ENDS
;	COMDAT ??_R2MVFlow@@8
rdata$r	SEGMENT
??_R2MVFlow@@8 DD FLAT:??_R1A@?0A@EA@MVFlow@@8		; MVFlow::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R3MVFlow@@8
rdata$r	SEGMENT
??_R3MVFlow@@8 DD 00H					; MVFlow::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVFlow@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVFlow@@@8
data$r	SEGMENT
??_R0?AVMVFlow@@@8 DD FLAT:??_7type_info@@6B@		; MVFlow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVFlow@@', 00H
data$r	ENDS
;	COMDAT ??_7MVFlow@@6B@
CONST	SEGMENT
??_7MVFlow@@6B@ DD FLAT:??_R4MVFlow@@6B@		; MVFlow::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVFlow@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVFlow@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BP@CLENLPGI@MFlow?5?3?5wrong?5super?5frame?5clip?$AA@
CONST	SEGMENT
??_C@_0BP@CLENLPGI@MFlow?5?3?5wrong?5super?5frame?5clip?$AA@ DB 'MFlow : '
	DB	'wrong super frame clip', 00H		; `string'
PUBLIC	??$Shift_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,2>
PUBLIC	??$Shift_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,1>
PUBLIC	??$Shift_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,0>
PUBLIC	??$Shift_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,2>
PUBLIC	??$Shift_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,1>
PUBLIC	??$Shift_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,0>
PUBLIC	??$Fetch_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,2>
PUBLIC	??$Fetch_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,1>
PUBLIC	??$Fetch_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,0>
PUBLIC	??$Fetch_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,2>
PUBLIC	??$Fetch_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,1>
PUBLIC	??$Fetch_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,0>
PUBLIC	??$Shift@G@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z	; MVFlow::Shift<unsigned short>
PUBLIC	??$Shift@E@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z	; MVFlow::Shift<unsigned char>
PUBLIC	??$Fetch@G@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z	; MVFlow::Fetch<unsigned short>
PUBLIC	??$Fetch@E@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z	; MVFlow::Fetch<unsigned char>
PUBLIC	??$min@F@std@@YAABFABF0@Z			; std::min<short>
PUBLIC	?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVFlow::GetFrame
PUBLIC	??1MVFlow@@UAE@XZ				; MVFlow::~MVFlow
PUBLIC	??_GMVFlow@@UAEPAXI@Z				; MVFlow::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVFlow@@UAGHHH@Z			; MVFlow::SetCacheHints
PUBLIC	??4PClip@@QAEXPAVIClip@@@Z			; PClip::operator=
PUBLIC	??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z ; MVFlow::MVFlow
EXTRN	??_EMVFlow@@UAEPAXI@Z:PROC			; MVFlow::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$8
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVFlow@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1MVFlow@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVFlow@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlow@@UAE@XZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlow@@UAE@XZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlow@@UAE@XZ$12
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$15
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$16
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$17
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$20
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
_super$ = 12						; size = 4
__mvec$ = 16						; size = 4
__time256$ = 20						; size = 4
__mode$ = 24						; size = 4
tv1155 = 28						; size = 4
_nHeightS$1$ = 28					; size = 4
__fields$ = 28						; size = 1
_nSCD1$ = 32						; size = 4
_nSuperPel$1$ = 36					; size = 4
_nSCD2$ = 36						; size = 4
_nSuperWidth$1$ = 40					; size = 4
tv1173 = 40						; size = 4
tv1102 = 40						; size = 4
$T2 = 40						; size = 4
$T3 = 40						; size = 4
$T4 = 40						; size = 4
$T5 = 40						; size = 4
__isse$ = 40						; size = 1
tv1149 = 44						; size = 4
_nSuperHPad$1$ = 44					; size = 4
__planar$ = 44						; size = 1
__timeclip$ = 48					; size = 4
_env$ = 52						; size = 4
??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z PROC ; MVFlow::MVFlow, COMDAT
; _this$ = ecx

; 34   : {/*

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflow.cpp

; 30   :   GenericVideoFilter(_child),

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN42@MVFlow
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN42@MVFlow
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN42@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 30   :   GenericVideoFilter(_child),

	mov	ecx, esi
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 31   :   MVFilter(_mvec, "MFlow", env, 1, 0),

	mov	ebx, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR __mvec$[ebp]
	push	0
	push	1
	push	ebx
	push	OFFSET ??_C@_05HIENMBJA@MFlow?$AA@
	push	ecx
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter

; 32   :   mvClip(_mvec, nSCD1, nSCD2, env, 1, 0)

	push	0
	push	1
	push	ebx
	push	DWORD PTR _nSCD2$[ebp]
	lea	eax, DWORD PTR __mvec$[ebp]

; 34   : {/*

	mov	DWORD PTR [esi], OFFSET ??_7MVFlow@@6B@
	push	DWORD PTR _nSCD1$[ebp]
	lea	ecx, DWORD PTR [esi+152]
	push	eax
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edi, edi
	je	SHORT $LN46@MVFlow
	cmp	DWORD PTR [edi], 228			; 000000e4H
	jbe	SHORT $LN46@MVFlow
	mov	eax, DWORD PTR [edi+228]
	lea	ecx, DWORD PTR [esi+404]
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN46@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 48   :   time256 = _time256;

	mov	eax, DWORD PTR __time256$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	DWORD PTR [esi+392], eax

; 49   :   mode = _mode;

	mov	eax, DWORD PTR __mode$[ebp]
	mov	DWORD PTR [esi+396], eax

; 50   : 
; 51   :   isse = _isse;

	mov	al, BYTE PTR __isse$[ebp]
	mov	BYTE PTR [esi+401], al

; 52   :   fields = _fields;

	mov	al, BYTE PTR __fields$[ebp]
	mov	BYTE PTR [esi+400], al

; 53   :   planar = _planar;

	mov	al, BYTE PTR __planar$[ebp]
	mov	BYTE PTR [esi+402], al
	mov	eax, DWORD PTR _super$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN22@MVFlow
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN21@MVFlow
$LN22@MVFlow:
	push	eax
; File c:\github\mvtools\sources\mvflow.cpp

; 56   :   memcpy(&params, &super->GetVideoInfo().num_audio_samples, 8);

	call	ecx
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edx, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN21@MVFlow:
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [edx+36]

; 57   :   int nHeightS = params.nHeight;

	movzx	ebx, cx

; 58   :   int nSuperHPad = params.nHPad;

	shr	ecx, 16					; 00000010H
	movzx	ecx, cl
	mov	DWORD PTR _nSuperHPad$1$[ebp], ecx

; 59   :   int nSuperVPad = params.nVPad;
; 60   :   int nSuperPel = params.nPel;

	movzx	ecx, dl
	mov	DWORD PTR _nSuperPel$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nHeightS$1$[ebp], ebx
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN24@MVFlow
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN23@MVFlow
$LN24@MVFlow:
	push	eax
; File c:\github\mvtools\sources\mvflow.cpp

; 63   :   int nSuperWidth = super->GetVideoInfo().width; // really super

	call	ecx
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edx, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN23@MVFlow:
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR _env$[ebp]
	mov	DWORD PTR _nSuperWidth$1$[ebp], edx
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	je	SHORT $LN25@MVFlow

; 64   :   int nSuperHeight = super->GetVideoInfo().height;

	push	eax
	call	ecx
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edx, DWORD PTR _nSuperWidth$1$[ebp]
$LN25@MVFlow:

; 65   : 
; 66   :   if (nHeight != nHeightS
; 67   :     || nWidth != nSuperWidth - nSuperHPad * 2
; 68   :     || nPel != nSuperPel)

	mov	eax, DWORD PTR _nHeightS$1$[ebp]
	cmp	DWORD PTR [esi+96], eax
	jne	SHORT $LN3@MVFlow
	mov	eax, DWORD PTR _nSuperHPad$1$[ebp]
	add	eax, eax
	sub	edx, eax
	cmp	DWORD PTR [esi+92], edx
	jne	SHORT $LN3@MVFlow
	mov	eax, DWORD PTR _nSuperPel$1$[ebp]
	cmp	DWORD PTR [esi+104], eax
	je	SHORT $LN2@MVFlow
$LN3@MVFlow:

; 69   :   {
; 70   :     env->ThrowError("MFlow : wrong super frame clip");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0BP@CLENLPGI@MFlow?5?3?5wrong?5super?5frame?5clip?$AA@
	push	ebx
	call	DWORD PTR [eax+20]
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 8
$LN2@MVFlow:

; 71   :   }
; 72   : 
; 73   :   if (nPel == 1)

	cmp	DWORD PTR [esi+104], 1
	jne	SHORT $LN4@MVFlow
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	test	edi, edi
	je	SHORT $LN70@MVFlow
	cmp	DWORD PTR [edi], 244			; 000000f4H
	jbe	SHORT $LN70@MVFlow
	lea	eax, DWORD PTR _super$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+244]
; File c:\github\mvtools\sources\mvflow.cpp

; 75   :   else

	jmp	SHORT $LN99@MVFlow
$LN4@MVFlow:

; 76   :     finest = new MVFinest(super, isse, env);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	mov	DWORD PTR $T5[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	movzx	ecx, BYTE PTR [esi+401]
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflow.cpp

; 76   :     finest = new MVFinest(super, isse, env);

	push	ecx
	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN66@MVFlow
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN66@MVFlow
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR _super$[ebp]
	push	edx
	call	eax
$LN66@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 76   :     finest = new MVFinest(super, isse, env);

	mov	ecx, edi
	call	??0MVFinest@@QAE@VPClip@@_NPAVIScriptEnvironment@@@Z ; MVFinest::MVFinest
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\include\avisynth.h

; 939  :   void operator=(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN70@MVFlow
	cmp	DWORD PTR [eax], 240			; 000000f0H
	jbe	SHORT $LN70@MVFlow
	mov	eax, DWORD PTR [eax+240]
	push	ecx
$LN99@MVFlow:
	lea	ecx, DWORD PTR [esi+404]
	call	eax
$LN70@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 85   :   nBlkXP = (nBlkX*(nBlkSizeX - nOverlapX) + nOverlapX < nWidth) ? nBlkX + 1 : nBlkX;

	mov	edx, DWORD PTR [esi+76]
	sub	edx, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+64]
	mov	eax, ecx
	imul	eax, edx
	add	eax, DWORD PTR [esi+108]
	cmp	eax, DWORD PTR [esi+92]
	jge	SHORT $LN12@MVFlow
	inc	ecx
$LN12@MVFlow:

; 86   :   nBlkYP = (nBlkY*(nBlkSizeY - nOverlapY) + nOverlapY < nHeight) ? nBlkY + 1 : nBlkY;

	mov	eax, DWORD PTR [esi+112]
	mov	edi, DWORD PTR [esi+80]
	mov	ebx, DWORD PTR [esi+68]
	sub	edi, eax
	mov	DWORD PTR tv1155[ebp], eax
	mov	eax, ebx
	imul	eax, edi
	mov	DWORD PTR [esi+440], ecx
	mov	DWORD PTR tv1173[ebp], ebx
	add	eax, DWORD PTR [esi+112]
	cmp	eax, DWORD PTR [esi+96]
	jge	SHORT $LN14@MVFlow
	inc	ebx
	mov	DWORD PTR tv1173[ebp], ebx
$LN14@MVFlow:

; 87   :   nWidthP = nBlkXP*(nBlkSizeX - nOverlapX) + nOverlapX;
; 88   :   nHeightP = nBlkYP*(nBlkSizeY - nOverlapY) + nOverlapY;

	imul	edi, DWORD PTR tv1173[ebp]
	mov	eax, DWORD PTR tv1155[ebp]
	imul	edx, ecx
	mov	DWORD PTR [esi+444], ebx
	mov	ebx, DWORD PTR [esi+108]
	add	eax, edi
	mov	DWORD PTR tv1102[ebp], edi
	mov	DWORD PTR [esi+452], eax
	add	ebx, edx
	mov	DWORD PTR [esi+448], ebx

; 89   :   // for YV12
; 90   :   nWidthPUV = nWidthP / xRatioUV;

	mov	eax, ebx
	mov	esi, DWORD PTR [esi+120]
	cdq
	idiv	esi
	mov	DWORD PTR tv1149[ebp], esi

; 91   :   nHeightPUV = nHeightP / yRatioUV;

	mov	esi, DWORD PTR tv1155[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _this$[ebp]

; 107  :   VXFullY = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	push	128					; 00000080H
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR [eax+456], edi
	mov	eax, DWORD PTR tv1102[ebp]
	lea	eax, DWORD PTR [eax+esi]
	mov	esi, DWORD PTR _this$[ebp]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+460], eax
	mov	eax, DWORD PTR [edx+96]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+476], eax
	mov	eax, DWORD PTR [edx+92]
	cdq
	idiv	DWORD PTR tv1149[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+472], eax
	mov	eax, DWORD PTR [edx+84]
	cdq
	idiv	DWORD PTR tv1149[ebp]
	mov	DWORD PTR [esi+480], eax
	mov	eax, DWORD PTR [esi+88]
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	ecx, DWORD PTR [ebx+15]
	mov	ebx, esi
; File c:\github\mvtools\sources\mvflow.cpp

; 97   :   nVPaddingUV = nVPadding / yRatioUV;

	mov	DWORD PTR [esi+484], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	and	ecx, -16				; fffffff0H
; File c:\github\mvtools\sources\mvflow.cpp

; 107  :   VXFullY = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	esi, DWORD PTR __imp___aligned_malloc
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [edi+15]
	and	eax, -16				; fffffff0H
; File c:\github\mvtools\sources\mvflow.cpp

; 101  :   VPitchUV = AlignNumber(nWidthPUV, 16);

	mov	DWORD PTR [ebx+468], eax

; 107  :   VXFullY = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR tv1102[ebp]
	add	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [ebx+464], ecx
	imul	ecx, eax
	lea	eax, DWORD PTR [ecx*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+408], eax

; 108  :   VXFullUV = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+468]
	imul	eax, DWORD PTR [ebx+460]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+412], eax

; 109  : 
; 110  :   VYFullY = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+464]
	imul	eax, DWORD PTR [ebx+452]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+416], eax

; 111  :   VYFullUV = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+468]
	imul	eax, DWORD PTR [ebx+460]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+420], eax

; 112  : 
; 113  :   VXSmallY = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+444]
	imul	eax, DWORD PTR [ebx+440]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+424], eax

; 114  :   VYSmallY = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+444]
	imul	eax, DWORD PTR [ebx+440]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+432], eax

; 115  :   VXSmallUV = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+444]
	imul	eax, DWORD PTR [ebx+440]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+428], eax

; 116  :   VYSmallUV = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+444]
	imul	eax, DWORD PTR [ebx+440]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi

; 117  : 
; 118  :   int CPUF_Resize = env->GetCPUFlags();

	mov	ecx, DWORD PTR _env$[ebp]
	add	esp, 64					; 00000040H
	mov	DWORD PTR [ebx+436], eax
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+4]
	mov	esi, eax

; 119  :   if (!isse) CPUF_Resize = (CPUF_Resize & !CPUF_INTEGER_SSE) & !CPUF_SSE2;

	xor	eax, eax
	cmp	BYTE PTR [ebx+401], al

; 120  : 
; 121  :   upsizer = new SimpleResize(nWidthP, nHeightP, nBlkXP, nBlkYP, CPUF_Resize);

	push	40					; 00000028H
	cmove	esi, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+444]
	push	DWORD PTR [ebx+440]
	push	DWORD PTR [ebx+452]
	push	DWORD PTR [ebx+448]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize

; 122  :   upsizerUV = new SimpleResize(nWidthPUV, nHeightPUV, nBlkXP, nBlkYP, CPUF_Resize);

	push	40					; 00000028H
	mov	DWORD PTR [ebx+488], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+444]
	push	DWORD PTR [ebx+440]
	push	DWORD PTR [ebx+460]
	push	DWORD PTR [ebx+456]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize
	mov	DWORD PTR [ebx+492], eax

; 123  : 
; 124  :   /* 2.5.11.22 no LUT
; 125  :   if (timeclip == 0)
; 126  :   {
; 127  :     LUTV = new VectLut [1];
; 128  :     Create_LUTV(time256, LUTV [0]);
; 129  :   }
; 130  :   else
; 131  :   {
; 132  :     LUTV = new VectLut [256];
; 133  :     for (int t256 = 0; t256 < 256; ++t256)
; 134  :     {
; 135  :       Create_LUTV(t256, LUTV [t256]);
; 136  :     }
; 137  :   }
; 138  :   */
; 139  : 
; 140  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN7@MVFlow
	cmp	BYTE PTR [ebx+402], 0
	jne	SHORT $LN7@MVFlow

; 141  :   {
; 142  :     DstPlanes = new YUY2Planes(nWidth, nHeight);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, eax
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	call	??0YUY2Planes@@QAE@HH@Z			; YUY2Planes::YUY2Planes
	mov	DWORD PTR [ebx+496], eax
$LN7@MVFlow:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN78@MVFlow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN78@MVFlow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN78@MVFlow:
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	test	eax, eax
	je	SHORT $LN83@MVFlow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN83@MVFlow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _super$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN83@MVFlow:
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	eax, eax
	je	SHORT $LN88@MVFlow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN88@MVFlow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __mvec$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN88@MVFlow:
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	eax, eax
	je	SHORT $LN96@MVFlow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN96@MVFlow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __timeclip$[ebp]
	call	eax
$LN96@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 144  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR __timeclip$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR __mvec$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _super$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$8:
	push	112					; 00000070H
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$14:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$15:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z ENDP ; MVFlow::MVFlow
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??4PClip@@QAEXPAVIClip@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??4PClip@@QAEXPAVIClip@@@Z PROC				; PClip::operator=, COMDAT
; _this$ = ecx

; 939  :   void operator=(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@operator
	cmp	DWORD PTR [eax], 240			; 000000f0H
	jbe	SHORT $LN3@operator
	mov	eax, DWORD PTR [eax+240]
	jmp	eax
$LN3@operator:
	ret	4
??4PClip@@QAEXPAVIClip@@@Z ENDP				; PClip::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.h
;	COMDAT ?SetCacheHints@MVFlow@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVFlow@@UAGHHH@Z PROC			; MVFlow::SetCacheHints, COMDAT

; 96   :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 97   :   }

	ret	12					; 0000000cH
?SetCacheHints@MVFlow@@UAGHHH@Z ENDP			; MVFlow::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVFlow@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVFlow@@UAEPAXI@Z PROC				; MVFlow::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVFlow@@UAE@XZ			; MVFlow::~MVFlow
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	504					; 000001f8H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVFlow@@UAEPAXI@Z ENDP				; MVFlow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??1MVFlow@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVFlow@@UAE@XZ PROC					; MVFlow::~MVFlow, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVFlow@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 148  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	edi, DWORD PTR __imp___aligned_free
	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [esi], OFFSET ??_7MVFlow@@6B@
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN11@MVFlow
	cmp	BYTE PTR [esi+402], 0
	jne	SHORT $LN11@MVFlow

; 149  :   {
; 150  :     delete DstPlanes;

	mov	ebx, DWORD PTR [esi+496]
	test	ebx, ebx
	je	SHORT $LN11@MVFlow
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN11@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 153  :   delete upsizer;

	mov	ebx, DWORD PTR [esi+488]
	test	ebx, ebx
	je	SHORT $LN18@MVFlow
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN18@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 154  :   delete upsizerUV;

	mov	ebx, DWORD PTR [esi+492]
	test	ebx, ebx
	je	SHORT $LN25@MVFlow
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN25@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 156  :   _aligned_free(VXFullY);

	push	DWORD PTR [esi+408]
	call	edi

; 157  :   _aligned_free(VXFullUV);

	push	DWORD PTR [esi+412]
	call	edi

; 158  :   _aligned_free(VYFullY);

	push	DWORD PTR [esi+416]
	call	edi

; 159  :   _aligned_free(VYFullUV);

	push	DWORD PTR [esi+420]
	call	edi

; 160  :   _aligned_free(VXSmallY);

	push	DWORD PTR [esi+424]
	call	edi

; 161  :   _aligned_free(VYSmallY);

	push	DWORD PTR [esi+432]
	call	edi

; 162  :   _aligned_free(VXSmallUV);

	push	DWORD PTR [esi+428]
	call	edi

; 163  :   _aligned_free(VYSmallUV);

	push	DWORD PTR [esi+436]
	call	edi
	add	esp, 32					; 00000020H
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN33@MVFlow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN33@MVFlow
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mvflow.cpp

; 165  : }

	lea	ecx, DWORD PTR [esi+404]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
$LN33@MVFlow:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi+152], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN44@MVFlow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN44@MVFlow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+160]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN44@MVFlow:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+152], OFFSET ??_7IClip@@6B@

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN61@MVFlow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN61@MVFlow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN61@MVFlow:
; File c:\github\mvtools\sources\mvflow.cpp

; 165  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvflow.cpp

; 165  : }

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVFlow@@UAE@XZ$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlow@@UAE@XZ$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlow@@UAE@XZ$12:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVFlow@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVFlow@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVFlow@@UAE@XZ ENDP					; MVFlow::~MVFlow
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -108						; size = 4
_height$1$ = -104					; size = 4
_width$1$ = -104					; size = 4
_width$1$ = -104					; size = 4
_height$1$ = -104					; size = 4
_width$1$ = -104					; size = 4
_width$1$ = -104					; size = 4
$T3 = -104						; size = 2
_t256$ = -100						; size = 4
_width$1$ = -96						; size = 4
_width$1$ = -96						; size = 4
_nref$1$ = -96						; size = 4
_mvn$ = -92						; size = 4
_npel$1$ = -88						; size = 4
_i$1$ = -88						; size = 4
$T4 = -88						; size = 2
$T5 = -88						; size = 4
_pDstYUY2$1$ = -84					; size = 4
_nDstPitchYUY2$1$ = -80					; size = 4
_nOffsetY$1$ = -76					; size = 4
_ref$ = -72						; size = 4
_pRef$3$ = -68						; size = 4
_nRefPitches$3$ = -64					; size = 4
_pRef$2$ = -60						; size = 4
_nRefPitches$2$ = -56					; size = 4
_nRefPitches$1$ = -52					; size = 4
_dst$ = -48						; size = 4
_pRef$1$ = -44						; size = 4
_nDstPitches$3$ = -40					; size = 4
_nDstPitches$2$ = -36					; size = 4
_pDst$2$ = -32						; size = 4
_pDst$1$ = -28						; size = 4
_nOffsetUV$1$ = -24					; size = 4
_pDst$3$ = -20						; size = 4
_usable_flag$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_max_pixel_value$1$ = 8					; size = 4
_src$6 = 8						; size = 4
_nDstPitchYUY2$ = 8					; size = 4
_pDstYUY2$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_height$1$ = 16						; size = 4
_height$1$ = 16						; size = 4
_height$1$ = 16						; size = 4
_height$1$ = 16						; size = 4
_n$ = 16						; size = 4
_nDstPitches$1$ = 20					; size = 4
$T7 = 20						; size = 4
_env$ = 20						; size = 4
?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVFlow::GetFrame, COMDAT

; 314  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 96					; 00000060H
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR $T2[ebp], 0
	test	eax, eax
	je	SHORT $LN47@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN47@GetFrame
	mov	eax, DWORD PTR [eax+252]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN47@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 315  :   PVideoFrame dst, ref, t256;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN51@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN51@GetFrame
	mov	eax, DWORD PTR [eax+252]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN51@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 315  :   PVideoFrame dst, ref, t256;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN55@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN55@GetFrame
	mov	eax, DWORD PTR [eax+252]
	lea	ecx, DWORD PTR _t256$[ebp]
	call	eax
$LN55@GetFrame:
	push	ebx
	push	esi
	push	edi
; File c:\github\mvtools\sources\mvflow.cpp

; 315  :   PVideoFrame dst, ref, t256;

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 316  :   BYTE *pDst[3];
; 317  :   const BYTE *pRef[3];
; 318  :   int nDstPitches[3], nRefPitches[3];
; 319  :   //const BYTE *pt256[3];
; 320  :   //int nt256Pitches[3];
; 321  :   unsigned char *pDstYUY2;
; 322  :   int nDstPitchYUY2;
; 323  : 
; 324  :   bool				usable_flag = mvClip.IsUsable(); // in 2 5.11.22 later

	mov	esi, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [esi+372]
	mov	ecx, DWORD PTR [esi+240]
	push	DWORD PTR [esi+368]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	SHORT $LN61@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [esi+220]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	mov	BYTE PTR _usable_flag$1$[ebp], 1
	test	al, al
	jne	SHORT $LN62@GetFrame
$LN61@GetFrame:
	mov	BYTE PTR _usable_flag$1$[ebp], 0
$LN62@GetFrame:
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	ebx, DWORD PTR [esi+292]
; File c:\github\mvtools\sources\mvflow.cpp

; 330  :   if (off < 0)

	test	ebx, ebx
	jns	SHORT $LN14@GetFrame

; 331  :   {
; 332  :     nref = -off;// special static mode

	neg	ebx
	mov	DWORD PTR _nref$1$[ebp], ebx

; 333  :   }
; 334  :   else

	jmp	SHORT $LN17@GetFrame
$LN14@GetFrame:
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [esi+296]
; File c:\github\mvtools\sources\mvflow.cpp

; 335  :     if (mvClip.IsBackward())

	test	al, al
	je	SHORT $LN16@GetFrame

; 336  :     {
; 337  :       nref = n + off;

	add	ebx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _nref$1$[ebp], ebx

; 338  :     }
; 339  :     else

	jmp	SHORT $LN17@GetFrame
$LN16@GetFrame:

; 340  :     {
; 341  :       nref = n - off;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, ebx
	mov	ebx, eax
	mov	DWORD PTR _nref$1$[ebp], eax
$LN17@GetFrame:

; 342  :     }
; 343  : 
; 344  :   PVideoFrame mvn = mvClip.GetFrame(n, env);

	mov	edi, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR _mvn$[ebp]
	mov	eax, DWORD PTR [esi+152]
	push	edi
	push	DWORD PTR _n$[ebp]
	push	ecx
	lea	ecx, DWORD PTR [esi+152]
	push	ecx
	call	DWORD PTR [eax+4]

; 345  :   mvClip.Update(mvn, env);// backward from next to current

	push	edi
	lea	eax, DWORD PTR _mvn$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	eax
	lea	ecx, DWORD PTR [esi+152]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN73@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN73@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvn$[ebp]
	push	0
	call	eax
$LN73@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 348  :   if (usable_flag)

	cmp	BYTE PTR _usable_flag$1$[ebp], 0

; 350  :     ref = finest->GetFrame(nref, env);//  ref for  compensation

	push	edi
	je	$LN18@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+404]
; File c:\github\mvtools\sources\mvflow.cpp

; 350  :     ref = finest->GetFrame(nref, env);//  ref for  compensation

	lea	edx, DWORD PTR $T7[ebp]
	push	ebx
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN79@GetFrame
	cmp	DWORD PTR [eax], 268			; 0000010cH
	jbe	SHORT $LN79@GetFrame
	mov	eax, DWORD PTR [eax+268]
	push	ecx
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN79@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN83@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN83@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR $T7[ebp]
	call	eax
$LN83@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 351  :     dst = env->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	eax, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\mvflow.cpp

; 351  :     dst = env->NewVideoFrame(vi);

	mov	ecx, DWORD PTR [edi]
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	push	edi
	call	DWORD PTR [ecx+56]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	ebx, ebx
	je	SHORT $LN88@GetFrame
	cmp	DWORD PTR [ebx], 268			; 0000010cH
	jbe	SHORT $LN88@GetFrame
	push	eax
	mov	eax, DWORD PTR [ebx+268]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN88@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	test	ebx, ebx
	je	SHORT $LN92@GetFrame
	cmp	DWORD PTR [ebx], 272			; 00000110H
	jbe	SHORT $LN92@GetFrame
	mov	eax, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR $T5[ebp]
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN92@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\mvflow.cpp

; 359  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN20@GetFrame

; 360  :     {
; 361  :       if (!planar)

	cmp	BYTE PTR [esi+402], 0
	jne	SHORT $LN22@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	ebx, ebx
	je	SHORT $LN99@GetFrame
	cmp	DWORD PTR [ebx], 220			; 000000dcH
	jbe	SHORT $LN99@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+220]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	jmp	SHORT $LN100@GetFrame
$LN99@GetFrame:
	mov	DWORD PTR _pDstYUY2$1$[ebp], 0
$LN100@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	ebx, ebx
	je	SHORT $LN105@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN105@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
	jmp	SHORT $LN106@GetFrame
$LN105@GetFrame:
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], 0
$LN106@GetFrame:
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [esi+496]
; File c:\github\mvtools\sources\mvflow.cpp

; 365  :         pDst[0] = DstPlanes->GetPtr();

	mov	ecx, DWORD PTR [eax]

; 367  :         pDst[2] = DstPlanes->GetPtrV();

	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR _pDst$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pDst$2$[ebp], ecx

; 368  :         nDstPitches[0] = DstPlanes->GetPitch();

	mov	ecx, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvflow.cpp

; 367  :         pDst[2] = DstPlanes->GetPtrV();

	mov	DWORD PTR _pDst$3$[ebp], edi
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	DWORD PTR _nDstPitches$2$[ebp], eax
; File c:\github\mvtools\sources\mvflow.cpp

; 370  :         nDstPitches[2] = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 371  :       }
; 372  :       else

	jmp	$LN561@GetFrame
$LN22@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	ebx, ebx
	je	SHORT $LN123@GetFrame
	cmp	DWORD PTR [ebx], 220			; 000000dcH
	jbe	SHORT $LN123@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+220]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN124@GetFrame
$LN123@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN124@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	ebx, ebx
	je	SHORT $LN129@GetFrame
	cmp	DWORD PTR [ebx], 196			; 000000c4H
	jbe	SHORT $LN129@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+196]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN130@GetFrame
$LN129@GetFrame:
	xor	eax, eax
$LN130@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 376  :         pDst[1] = pDst[0] + dst->GetRowSize() / 2;

	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	add	edi, DWORD PTR _pDst$1$[ebp]
	mov	DWORD PTR _pDst$2$[ebp], edi
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	ebx, ebx
	je	SHORT $LN135@GetFrame
	cmp	DWORD PTR [ebx], 196			; 000000c4H
	jbe	SHORT $LN135@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+196]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN136@GetFrame
$LN135@GetFrame:
	xor	eax, eax
$LN136@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 377  :         pDst[2] = pDst[1] + dst->GetRowSize() / 4;

	cdq
	and	edx, 3
	add	edx, eax
	sar	edx, 2
	add	edx, edi
	mov	DWORD PTR _pDst$3$[ebp], edx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	ebx, ebx
	je	SHORT $LN141@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN141@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN552@GetFrame
$LN141@GetFrame:
	xor	ecx, ecx
$LN552@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 380  :         nDstPitches[2] = nDstPitches[0];

	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitches$2$[ebp], ecx
	mov	DWORD PTR _nDstPitches$3$[ebp], ecx
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
$LN561@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	mov	DWORD PTR _nDstPitches$1$[ebp], ecx

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	ebx, ebx
	je	SHORT $LN147@GetFrame
	cmp	DWORD PTR [ebx], 212			; 000000d4H
	jbe	SHORT $LN147@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+212]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$1$[ebp], eax
	jmp	SHORT $LN148@GetFrame
$LN147@GetFrame:
	mov	DWORD PTR _pRef$1$[ebp], 0
$LN148@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	ebx, ebx
	je	SHORT $LN153@GetFrame
	cmp	DWORD PTR [ebx], 196			; 000000c4H
	jbe	SHORT $LN153@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+196]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN154@GetFrame
$LN153@GetFrame:
	xor	eax, eax
$LN154@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 384  :       pRef[1] = pRef[0] + ref->GetRowSize() / 2;

	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	add	edi, DWORD PTR _pRef$1$[ebp]
	mov	DWORD PTR _pRef$2$[ebp], edi
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	ebx, ebx
	je	SHORT $LN159@GetFrame
	cmp	DWORD PTR [ebx], 196			; 000000c4H
	jbe	SHORT $LN159@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+196]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN160@GetFrame
$LN159@GetFrame:
	xor	eax, eax
$LN160@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 385  :       pRef[2] = pRef[1] + ref->GetRowSize() / 4;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, edi
	mov	DWORD PTR _pRef$3$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	ebx, ebx
	je	SHORT $LN165@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN165@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	0
	call	eax
	mov	edi, eax
	mov	DWORD PTR _nRefPitches$1$[ebp], edi
; File c:\github\mvtools\sources\mvflow.cpp

; 387  :       nRefPitches[1] = nRefPitches[0];

	mov	DWORD PTR _nRefPitches$2$[ebp], edi

; 388  :       nRefPitches[2] = nRefPitches[0];

	mov	DWORD PTR _nRefPitches$3$[ebp], edi

; 389  :       /* comment oout 2.6.0.5 specific timeclip
; 390  :       if (timeclip != 0)
; 391  :       {
; 392  :         pt256[0] = t256->GetReadPtr();
; 393  :         pt256[1] = pt256[0] + t256->GetRowSize() / 2;
; 394  :         pt256[2] = pt256[1] + t256->GetRowSize() / 4;
; 395  :         nt256Pitches[0] = t256->GetPitch();
; 396  :         nt256Pitches[1] = nt256Pitches[0];
; 397  :         nt256Pitches[2] = nt256Pitches[0];
; 398  :       }
; 399  :       */
; 400  :     }
; 401  :     else

	jmp	$LN21@GetFrame
$LN165@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	xor	edi, edi
	mov	DWORD PTR _nRefPitches$1$[ebp], edi
; File c:\github\mvtools\sources\mvflow.cpp

; 387  :       nRefPitches[1] = nRefPitches[0];

	mov	DWORD PTR _nRefPitches$2$[ebp], edi

; 388  :       nRefPitches[2] = nRefPitches[0];

	mov	DWORD PTR _nRefPitches$3$[ebp], edi

; 389  :       /* comment oout 2.6.0.5 specific timeclip
; 390  :       if (timeclip != 0)
; 391  :       {
; 392  :         pt256[0] = t256->GetReadPtr();
; 393  :         pt256[1] = pt256[0] + t256->GetRowSize() / 2;
; 394  :         pt256[2] = pt256[1] + t256->GetRowSize() / 4;
; 395  :         nt256Pitches[0] = t256->GetPitch();
; 396  :         nt256Pitches[1] = nt256Pitches[0];
; 397  :         nt256Pitches[2] = nt256Pitches[0];
; 398  :       }
; 399  :       */
; 400  :     }
; 401  :     else

	jmp	$LN21@GetFrame
$LN20@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	ebx, ebx
	je	SHORT $LN171@GetFrame
	cmp	DWORD PTR [ebx], 220			; 000000dcH
	jbe	SHORT $LN171@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+220]
	push	1
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN172@GetFrame
$LN171@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN172@GetFrame:
	test	ebx, ebx
	je	SHORT $LN177@GetFrame
	cmp	DWORD PTR [ebx], 220			; 000000dcH
	jbe	SHORT $LN177@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+220]
	push	2
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$2$[ebp], eax
	jmp	SHORT $LN178@GetFrame
$LN177@GetFrame:
	mov	DWORD PTR _pDst$2$[ebp], 0
$LN178@GetFrame:
	test	ebx, ebx
	je	SHORT $LN183@GetFrame
	cmp	DWORD PTR [ebx], 220			; 000000dcH
	jbe	SHORT $LN183@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+220]
	push	4
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN554@GetFrame
$LN183@GetFrame:
	xor	edi, edi
$LN554@GetFrame:
	mov	DWORD PTR _pDst$3$[ebp], edi

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	ebx, ebx
	je	SHORT $LN189@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN189@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	1
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
	jmp	SHORT $LN190@GetFrame
$LN189@GetFrame:
	mov	DWORD PTR _nDstPitches$1$[ebp], 0
$LN190@GetFrame:
	test	ebx, ebx
	je	SHORT $LN195@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN195@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	2
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$2$[ebp], eax
	jmp	SHORT $LN196@GetFrame
$LN195@GetFrame:
	mov	DWORD PTR _nDstPitches$2$[ebp], 0
$LN196@GetFrame:
	test	ebx, ebx
	je	SHORT $LN201@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN201@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	4
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
	jmp	SHORT $LN202@GetFrame
$LN201@GetFrame:
	mov	DWORD PTR _nDstPitches$3$[ebp], 0
$LN202@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	ebx, ebx
	je	SHORT $LN207@GetFrame
	cmp	DWORD PTR [ebx], 212			; 000000d4H
	jbe	SHORT $LN207@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+212]
	push	1
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$1$[ebp], eax
	jmp	SHORT $LN208@GetFrame
$LN207@GetFrame:
	mov	DWORD PTR _pRef$1$[ebp], 0
$LN208@GetFrame:
	test	ebx, ebx
	je	SHORT $LN213@GetFrame
	cmp	DWORD PTR [ebx], 212			; 000000d4H
	jbe	SHORT $LN213@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+212]
	push	2
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$2$[ebp], eax
	jmp	SHORT $LN214@GetFrame
$LN213@GetFrame:
	mov	DWORD PTR _pRef$2$[ebp], 0
$LN214@GetFrame:
	test	ebx, ebx
	je	SHORT $LN219@GetFrame
	cmp	DWORD PTR [ebx], 212			; 000000d4H
	jbe	SHORT $LN219@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+212]
	push	4
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$3$[ebp], eax
	jmp	SHORT $LN220@GetFrame
$LN219@GetFrame:
	mov	DWORD PTR _pRef$3$[ebp], 0
$LN220@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	ebx, ebx
	je	SHORT $LN225@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN225@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	1
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN555@GetFrame
$LN225@GetFrame:
	xor	edi, edi
$LN555@GetFrame:
	mov	DWORD PTR _nRefPitches$1$[ebp], edi
	test	ebx, ebx
	je	SHORT $LN231@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN231@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	2
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$2$[ebp], eax
	jmp	SHORT $LN232@GetFrame
$LN231@GetFrame:
	mov	DWORD PTR _nRefPitches$2$[ebp], 0
$LN232@GetFrame:
	test	ebx, ebx
	je	SHORT $LN237@GetFrame
	cmp	DWORD PTR [ebx], 192			; 000000c0H
	jbe	SHORT $LN237@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [ebx+192]
	push	4
	call	eax
	mov	DWORD PTR _nRefPitches$3$[ebp], eax
	jmp	SHORT $LN238@GetFrame
$LN237@GetFrame:
	mov	DWORD PTR _nRefPitches$3$[ebp], 0
$LN238@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 415  :       nRefPitches[2] = VPITCH(ref);

	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
$LN21@GetFrame:

; 416  : 
; 417  :       /* comment oout 2.6.0.5 specific timeclip
; 418  :       if (timeclip != 0)
; 419  :       {
; 420  :         pt256[0] = YRPLAN(t256);
; 421  :         pt256[1] = URPLAN(t256);
; 422  :         pt256[2] = VRPLAN(t256);
; 423  :         nt256Pitches[0] = YPITCH(t256);
; 424  :         nt256Pitches[1] = UPITCH(t256);
; 425  :         nt256Pitches[2] = VPITCH(t256);
; 426  :       }
; 427  :       */
; 428  :     }
; 429  : 
; 430  : 
; 431  :     int nOffsetY = nRefPitches[0] * nVPadding*nPel + nHPadding*nPel*pixelsize;

	mov	ecx, DWORD PTR [esi+136]
	mov	ebx, DWORD PTR [esi+88]
	mov	eax, DWORD PTR [esi+84]
	imul	ebx, edi
	imul	eax, ecx

; 432  :     int nOffsetUV = nRefPitches[1] * nVPaddingUV*nPel + nHPaddingUV*nPel*pixelsize;
; 433  : 
; 434  :     MakeVectorSmallMasks(mvClip, nBlkX, nBlkY, VXSmallY, nBlkXP, VYSmallY, nBlkXP);

	mov	edx, DWORD PTR [esi+64]
	add	ebx, eax
	mov	eax, DWORD PTR [esi+480]
	imul	ebx, DWORD PTR [esi+104]
	imul	eax, ecx
	lea	ecx, DWORD PTR [esi+152]
	mov	DWORD PTR _nOffsetY$1$[ebp], ebx
	mov	ebx, DWORD PTR [esi+484]
	imul	ebx, DWORD PTR _nRefPitches$2$[ebp]
	add	ebx, eax
	mov	eax, DWORD PTR [esi+440]
	imul	ebx, DWORD PTR [esi+104]
	push	eax
	push	DWORD PTR [esi+432]
	push	eax
	push	DWORD PTR [esi+424]
	mov	DWORD PTR _nOffsetUV$1$[ebp], ebx
	push	DWORD PTR [esi+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 435  :     if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [esi+440]
	add	esp, 20					; 00000014H
	cmp	eax, DWORD PTR [esi+64]
	jle	SHORT $LN3@GetFrame

; 436  :     {
; 437  :       for (int j = 0; j < nBlkY; j++)

	xor	edi, edi
	cmp	DWORD PTR [esi+68], edi
	jle	SHORT $LN3@GetFrame

; 439  :         VXSmallY[j*nBlkXP + nBlkX] = std::min(VXSmallY[j*nBlkXP + nBlkX - 1], short(0)); // not positive

	mov	DWORD PTR $T4[ebp], edi
$LL4@GetFrame:
	mov	ecx, DWORD PTR [esi+440]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflow.cpp

; 439  :         VXSmallY[j*nBlkXP + nBlkX] = std::min(VXSmallY[j*nBlkXP + nBlkX - 1], short(0)); // not positive

	mov	eax, DWORD PTR [esi+424]
	imul	ecx, edi
	add	ecx, DWORD PTR [esi+64]
	lea	edx, DWORD PTR [eax+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [edx-2]
; File c:\github\mvtools\sources\mvflow.cpp

; 439  :         VXSmallY[j*nBlkXP + nBlkX] = std::min(VXSmallY[j*nBlkXP + nBlkX - 1], short(0)); // not positive

	lea	ecx, DWORD PTR [edx-2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T4[ebp]
	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflow.cpp

; 439  :         VXSmallY[j*nBlkXP + nBlkX] = std::min(VXSmallY[j*nBlkXP + nBlkX - 1], short(0)); // not positive

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx], ax

; 440  :         VYSmallY[j*nBlkXP + nBlkX] = VYSmallY[j*nBlkXP + nBlkX - 1];

	mov	ecx, DWORD PTR [esi+440]
	mov	eax, DWORD PTR [esi+432]
	imul	ecx, edi
	inc	edi
	add	ecx, DWORD PTR [esi+64]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [ecx-2]
	mov	WORD PTR [ecx], ax
	cmp	edi, DWORD PTR [esi+68]
	jl	SHORT $LL4@GetFrame
$LN3@GetFrame:

; 441  :       }
; 442  :     }
; 443  :     if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [esi+444]
	cmp	eax, DWORD PTR [esi+68]
	jle	$LN6@GetFrame

; 445  :       for (int i = 0; i < nBlkXP; i++)

	xor	ebx, ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	DWORD PTR [esi+440], ebx
	jle	SHORT $LN6@GetFrame

; 448  :         VYSmallY[nBlkXP*nBlkY + i] = std::min(VYSmallY[nBlkXP*(nBlkY - 1) + i], short(0)); // not positive

	mov	DWORD PTR $T3[ebp], ebx
	npad	4
$LL7@GetFrame:

; 447  :         VXSmallY[nBlkXP*nBlkY + i] = VXSmallY[nBlkXP*(nBlkY - 1) + i];

	mov	ecx, DWORD PTR [esi+68]
	mov	edi, DWORD PTR [esi+440]
	mov	edx, DWORD PTR [esi+424]
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, edi
	imul	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T3[ebp]
; File c:\github\mvtools\sources\mvflow.cpp

; 447  :         VXSmallY[nBlkXP*nBlkY + i] = VXSmallY[nBlkXP*(nBlkY - 1) + i];

	add	eax, ebx
	add	edi, ebx
	movzx	eax, WORD PTR [edx+eax*2]
	mov	WORD PTR [edx+edi*2], ax

; 448  :         VYSmallY[nBlkXP*nBlkY + i] = std::min(VYSmallY[nBlkXP*(nBlkY - 1) + i], short(0)); // not positive

	mov	edx, DWORD PTR [esi+68]
	mov	ebx, DWORD PTR [esi+440]
	mov	edi, DWORD PTR [esi+432]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	esi, esi
; File c:\github\mvtools\sources\mvflow.cpp

; 448  :         VYSmallY[nBlkXP*nBlkY + i] = std::min(VYSmallY[nBlkXP*(nBlkY - 1) + i], short(0)); // not positive

	lea	eax, DWORD PTR [edx-1]
	imul	eax, ebx
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	si, WORD PTR [edi+eax*2]
; File c:\github\mvtools\sources\mvflow.cpp

; 445  :       for (int i = 0; i < nBlkXP; i++)

	mov	esi, DWORD PTR _this$[ebp]

; 448  :         VYSmallY[nBlkXP*nBlkY + i] = std::min(VYSmallY[nBlkXP*(nBlkY - 1) + i], short(0)); // not positive

	lea	eax, DWORD PTR [edi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflow.cpp

; 448  :         VYSmallY[nBlkXP*nBlkY + i] = std::min(VYSmallY[nBlkXP*(nBlkY - 1) + i], short(0)); // not positive

	imul	ebx, edx
	movzx	eax, WORD PTR [ecx]
	add	ebx, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [edi+ebx*2], ax
	mov	ebx, DWORD PTR _i$1$[ebp]
	inc	ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	ebx, DWORD PTR [esi+440]
	jl	SHORT $LL7@GetFrame
$LN6@GetFrame:

; 453  :       ClipFnc::compute_fieldshift(finest, fields, nPel, n, nref);

	mov	al, BYTE PTR [esi+400]
; File c:\github\mvtools\sources\clipfnc.cpp

; 53   : 	int				fieldshift = 0;

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflow.cpp

; 453  :       ClipFnc::compute_fieldshift(finest, fields, nPel, n, nref);

	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR _npel$1$[ebp], ecx
; File c:\github\mvtools\sources\clipfnc.cpp

; 55   : 	if (field_flag && npel > 1 && ((nsrc - nref) & 1) != 0)

	test	al, al
	je	SHORT $LN249@GetFrame
	cmp	ecx, 1
	jle	SHORT $LN249@GetFrame
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, edx
	mov	edi, DWORD PTR _nref$1$[ebp]
	sub	eax, edi
	test	al, 1
	je	SHORT $LN249@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+404]
; File c:\github\mvtools\sources\clipfnc.cpp

; 57   : 		const bool		parity_src = clp->GetParity (nsrc);

	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [esi+404]
; File c:\github\mvtools\sources\clipfnc.cpp

; 57   : 		const bool		parity_src = clp->GetParity (nsrc);

	mov	bl, al

; 58   : 		const bool		parity_ref = clp->GetParity (nref);

	push	edi
	push	ecx
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]

; 59   : 
; 60   : 		if (parity_src && ! parity_ref)

	test	bl, bl
	je	SHORT $LN247@GetFrame
	test	al, al
	jne	SHORT $LN541@GetFrame

; 61   : 		{
; 62   : 			fieldshift = npel / 2;

	mov	eax, DWORD PTR _npel$1$[ebp]
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	jmp	SHORT $LN249@GetFrame
$LN247@GetFrame:

; 63   : 		}
; 64   : 		else if (parity_ref && ! parity_src)

	test	al, al
	je	SHORT $LN541@GetFrame

; 65   : 		{
; 66   : 			fieldshift = -(npel / 2);

	mov	eax, DWORD PTR _npel$1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ebx, eax
	neg	ebx
	jmp	SHORT $LN249@GetFrame
$LN541@GetFrame:
	xor	ebx, ebx
$LN249@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 455  :     for (int j = 0; j < nBlkYP; j++)

	xor	edi, edi
	cmp	DWORD PTR [esi+444], edi
	jle	SHORT $LN9@GetFrame
	mov	eax, DWORD PTR [esi+440]
$LL10@GetFrame:

; 456  :     {
; 457  :       for (int i = 0; i < nBlkXP; i++)

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN8@GetFrame
	npad	7
$LL13@GetFrame:

; 458  :       {
; 459  :         VYSmallY[j*nBlkXP + i] += fieldShift;

	mov	ecx, DWORD PTR [esi+440]
	mov	eax, DWORD PTR [esi+432]
	imul	ecx, edi
	add	ecx, edx
	inc	edx
	add	WORD PTR [eax+ecx*2], bx
	mov	eax, DWORD PTR [esi+440]
	cmp	edx, eax
	jl	SHORT $LL13@GetFrame
$LN8@GetFrame:

; 455  :     for (int j = 0; j < nBlkYP; j++)

	inc	edi
	cmp	edi, DWORD PTR [esi+444]
	jl	SHORT $LL10@GetFrame
$LN9@GetFrame:

; 460  :       }
; 461  :     }
; 462  : 
; 463  :     VectorSmallMaskYToHalfUV(VXSmallY, nBlkXP, nBlkYP, VXSmallUV, xRatioUV);

	push	DWORD PTR [esi+120]
	mov	edx, DWORD PTR [esi+440]
	push	DWORD PTR [esi+428]
	mov	ecx, DWORD PTR [esi+424]
	push	DWORD PTR [esi+444]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 464  :     VectorSmallMaskYToHalfUV(VYSmallY, nBlkXP, nBlkYP, VYSmallUV, yRatioUV);

	push	DWORD PTR [esi+124]
	mov	edx, DWORD PTR [esi+440]
	push	DWORD PTR [esi+436]
	mov	ecx, DWORD PTR [esi+432]
	push	DWORD PTR [esi+444]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 465  : 
; 466  :     // upsize (bilinear interpolate) vector masks to fullframe size
; 467  : 
; 468  :     int dummyplane = PLANAR_Y; // use luma plane resizer code for all planes if we resize from luma small mask
; 469  :     upsizer->SimpleResizeDo_uint16(VXFullY, nWidthP, nHeightP, VPitchY, VXSmallY, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [esi+440]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [esi+488]
	push	eax
	push	eax
	push	DWORD PTR [esi+424]
	push	DWORD PTR [esi+464]
	push	DWORD PTR [esi+452]
	push	DWORD PTR [esi+448]
	push	DWORD PTR [esi+408]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 470  :     upsizer->SimpleResizeDo_uint16(VYFullY, nWidthP, nHeightP, VPitchY, VYSmallY, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [esi+440]
	mov	ecx, DWORD PTR [esi+488]
	push	eax
	push	eax
	push	DWORD PTR [esi+432]
	push	DWORD PTR [esi+464]
	push	DWORD PTR [esi+452]
	push	DWORD PTR [esi+448]
	push	DWORD PTR [esi+416]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 471  :     upsizerUV->SimpleResizeDo_uint16(VXFullUV, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUV, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [esi+440]
	mov	ecx, DWORD PTR [esi+492]
	push	eax
	push	eax
	push	DWORD PTR [esi+428]
	push	DWORD PTR [esi+468]
	push	DWORD PTR [esi+460]
	push	DWORD PTR [esi+456]
	push	DWORD PTR [esi+412]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 472  :     upsizerUV->SimpleResizeDo_uint16(VYFullUV, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUV, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [esi+440]
	mov	ecx, DWORD PTR [esi+492]
	push	eax
	push	eax
	push	DWORD PTR [esi+436]
	push	DWORD PTR [esi+468]
	push	DWORD PTR [esi+460]
	push	DWORD PTR [esi+456]
	push	DWORD PTR [esi+420]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 473  : 
; 474  :     if (mode == 1)

	cmp	DWORD PTR [esi+396], 1
	jne	$LN267@GetFrame

; 475  :     {
; 476  :       MemZoneSet(pDst[0], 0, nWidth*pixelsize, nHeight, 0, 0, nDstPitches[0]);

	mov	ecx, DWORD PTR [esi+92]
	imul	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+96]
	mov	ebx, DWORD PTR _pDst$1$[ebp]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN257@GetFrame
	mov	edi, DWORD PTR _nDstPitches$1$[ebp]
	mov	esi, eax
	npad	4
$LL258@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	0
	push	ebx
	call	_memset
	mov	ecx, DWORD PTR _width$1$[ebp]
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	ebx, edi
	sub	esi, 1
	jne	SHORT $LL258@GetFrame
	mov	esi, DWORD PTR _this$[ebp]
$LN257@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 477  :       MemZoneSet(pDst[1], 0, nWidthUV*pixelsize, nHeightUV, 0, 0, nDstPitches[1]);

	mov	ecx, DWORD PTR [esi+472]
	imul	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+476]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN262@GetFrame
	mov	ebx, DWORD PTR _nDstPitches$2$[ebp]
	mov	esi, eax
	mov	edi, DWORD PTR _pDst$2$[ebp]
	npad	2
$LL263@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	0
	push	edi
	call	_memset
	mov	ecx, DWORD PTR _width$1$[ebp]
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	edi, ebx
	sub	esi, 1
	jne	SHORT $LL263@GetFrame
	mov	esi, DWORD PTR _this$[ebp]
$LN262@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 478  :       MemZoneSet(pDst[2], 0, nWidthUV*pixelsize, nHeightUV, 0, 0, nDstPitches[2]);

	mov	ecx, DWORD PTR [esi+472]
	imul	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+476]
	mov	ebx, DWORD PTR _pDst$3$[ebp]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN267@GetFrame
	mov	edi, DWORD PTR _nDstPitches$3$[ebp]
	mov	esi, eax
	npad	2
$LL268@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	0
	push	ebx
	call	_memset
	mov	ecx, DWORD PTR _width$1$[ebp]
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	ebx, edi
	sub	esi, 1
	jne	SHORT $LL268@GetFrame
	mov	esi, DWORD PTR _this$[ebp]
$LN267@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 504  :       if (mode == 0) // fetch mode

	mov	eax, DWORD PTR [esi+396]
	test	eax, eax
	jne	$LN27@GetFrame

; 505  :       {
; 506  :         if (pixelsize == 1) {

	cmp	DWORD PTR [esi+136], 1

; 507  :           Fetch<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, nRefPitches[0], VXFullY, VPitchY, VYFullY, VPitchY, nWidth, nHeight, time256); //padded

	mov	ecx, DWORD PTR [esi+392]
	mov	edx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+464]

; 249  :   if (nPel == 1)

	mov	ebx, DWORD PTR [esi+104]
	mov	edi, DWORD PTR _nDstPitches$1$[ebp]

; 505  :       {
; 506  :         if (pixelsize == 1) {

	jne	$LN29@GetFrame

; 249  :   if (nPel == 1)

	cmp	ebx, 1
	jne	SHORT $LN271@GetFrame

; 250  :   {
; 251  :     Fetch_NPel <pixel_t,/*T256P,*/ 0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Fetch_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,0>
	jmp	SHORT $LN275@GetFrame
$LN271@GetFrame:

; 253  :   else if (nPel == 2)

	cmp	ebx, 2
	jne	SHORT $LN273@GetFrame

; 254  :   {
; 255  :     Fetch_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Fetch_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,1>
	jmp	SHORT $LN275@GetFrame
$LN273@GetFrame:

; 256  :   }
; 257  :   else if (nPel == 4)

	cmp	ebx, 4
	jne	SHORT $LN275@GetFrame

; 258  :   {
; 259  :     Fetch_NPel <pixel_t,/*T256P, */2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Fetch_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,2>
$LN275@GetFrame:

; 249  :   if (nPel == 1)

	mov	ecx, DWORD PTR [esi+104]

; 508  :           Fetch<uint8_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, nRefPitches[1], VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV, time256);

	mov	edi, DWORD PTR [esi+476]
	mov	eax, DWORD PTR [esi+468]

; 249  :   if (nPel == 1)

	mov	edx, DWORD PTR [esi+392]
	cmp	ecx, 1
	jne	SHORT $LN278@GetFrame

; 250  :   {
; 251  :     Fetch_NPel <pixel_t,/*T256P,*/ 0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Fetch_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,0>
	jmp	SHORT $LN282@GetFrame
$LN278@GetFrame:

; 253  :   else if (nPel == 2)

	cmp	ecx, 2
	jne	SHORT $LN280@GetFrame

; 254  :   {
; 255  :     Fetch_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Fetch_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,1>
	jmp	SHORT $LN282@GetFrame
$LN280@GetFrame:

; 256  :   }
; 257  :   else if (nPel == 4)

	cmp	ecx, 4
	jne	SHORT $LN282@GetFrame

; 258  :   {
; 259  :     Fetch_NPel <pixel_t,/*T256P, */2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Fetch_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,2>
$LN282@GetFrame:

; 249  :   if (nPel == 1)

	cmp	DWORD PTR [esi+104], 1

; 509  :           Fetch<uint8_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, nRefPitches[2], VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV, time256);

	mov	edx, DWORD PTR [esi+476]
	mov	edi, DWORD PTR [esi+472]
	mov	eax, DWORD PTR [esi+468]

; 249  :   if (nPel == 1)

	mov	ebx, DWORD PTR _pDst$3$[ebp]
	mov	ecx, DWORD PTR [esi+392]
	jne	$LN285@GetFrame

; 250  :   {
; 251  :     Fetch_NPel <pixel_t,/*T256P,*/ 0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	ebx
	call	??$Fetch_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,0>
$LN548@GetFrame:
	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
$LN549@GetFrame:
	mov	edi, DWORD PTR _pDst$3$[ebp]
$LN424@GetFrame:

; 546  :         }
; 547  :         /*
; 548  :         Shift(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, nRefPitches[0],
; 549  :           VXFullY, VPitchY, VYFullY, VPitchY, nWidth, nHeight,
; 550  :           Time256ProviderPlane(pt256[0], nt256Pitches[0], LUTV, LUTV));
; 551  :         Shift(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, nRefPitches[1],
; 552  :           VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV,
; 553  :           Time256ProviderPlane(pt256[1], nt256Pitches[1], LUTV, LUTV));
; 554  :         Shift(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, nRefPitches[2],
; 555  :           VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV,
; 556  :           Time256ProviderPlane(pt256[2], nt256Pitches[2], LUTV, LUTV));
; 557  :           */
; 558  :       }
; 559  :     }
; 560  : 
; 561  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN428@GetFrame
	cmp	BYTE PTR [esi+402], 0
	jne	$LN428@GetFrame

; 563  :       YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	mov	al, BYTE PTR [esi+401]
	mov	ecx, DWORD PTR [esi+96]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	test	al, al
; File c:\github\mvtools\sources\mvflow.cpp

; 563  :       YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	mov	edx, DWORD PTR [esi+92]
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	mov	eax, DWORD PTR _pDst$1$[ebp]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	je	$LN427@GetFrame
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	al, 15					; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	jne	$LN427@GetFrame

; 155  :     //U and V don't have to be aligned since we user movq to read from those
; 156  :     convert_yv16_to_yuy2_sse2(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	ecx
	push	edx
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	mov	edx, DWORD PTR _pDst$2$[ebp]
	mov	ecx, eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	ebx
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	edi
	call	?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_sse2

; 157  :   }
; 158  :   else

	jmp	$LN556@GetFrame
$LN285@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 253  :   else if (nPel == 2)

	cmp	DWORD PTR [esi+104], 2
	jne	SHORT $LN287@GetFrame

; 254  :   {
; 255  :     Fetch_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	ebx
	call	??$Fetch_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,1>
	jmp	$LN548@GetFrame
$LN287@GetFrame:

; 256  :   }
; 257  :   else if (nPel == 4)

	cmp	DWORD PTR [esi+104], 4
	jne	$LN548@GetFrame

; 258  :   {
; 259  :     Fetch_NPel <pixel_t,/*T256P, */2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	ebx
	call	??$Fetch_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,2>

; 510  :         }
; 511  :         else {

	jmp	$LN548@GetFrame
$LN29@GetFrame:

; 249  :   if (nPel == 1)

	cmp	ebx, 1
	jne	SHORT $LN292@GetFrame

; 250  :   {
; 251  :     Fetch_NPel <pixel_t,/*T256P,*/ 0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Fetch_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,0>
	jmp	SHORT $LN296@GetFrame
$LN292@GetFrame:

; 253  :   else if (nPel == 2)

	cmp	ebx, 2
	jne	SHORT $LN294@GetFrame

; 254  :   {
; 255  :     Fetch_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Fetch_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,1>
	jmp	SHORT $LN296@GetFrame
$LN294@GetFrame:

; 256  :   }
; 257  :   else if (nPel == 4)

	cmp	ebx, 4
	jne	SHORT $LN296@GetFrame

; 258  :   {
; 259  :     Fetch_NPel <pixel_t,/*T256P, */2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Fetch_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,2>
$LN296@GetFrame:

; 249  :   if (nPel == 1)

	mov	ecx, DWORD PTR [esi+104]

; 512  :           Fetch<uint16_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, nRefPitches[0], VXFullY, VPitchY, VYFullY, VPitchY, nWidth, nHeight, time256); //padded
; 513  :           Fetch<uint16_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, nRefPitches[1], VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV, time256);

	mov	edi, DWORD PTR [esi+476]
	mov	eax, DWORD PTR [esi+468]

; 249  :   if (nPel == 1)

	mov	edx, DWORD PTR [esi+392]
	cmp	ecx, 1
	jne	SHORT $LN299@GetFrame

; 250  :   {
; 251  :     Fetch_NPel <pixel_t,/*T256P,*/ 0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Fetch_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,0>
	jmp	SHORT $LN303@GetFrame
$LN299@GetFrame:

; 253  :   else if (nPel == 2)

	cmp	ecx, 2
	jne	SHORT $LN301@GetFrame

; 254  :   {
; 255  :     Fetch_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Fetch_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,1>
	jmp	SHORT $LN303@GetFrame
$LN301@GetFrame:

; 256  :   }
; 257  :   else if (nPel == 4)

	cmp	ecx, 4
	jne	SHORT $LN303@GetFrame

; 258  :   {
; 259  :     Fetch_NPel <pixel_t,/*T256P, */2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Fetch_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,2>
$LN303@GetFrame:

; 249  :   if (nPel == 1)

	cmp	DWORD PTR [esi+104], 1

; 514  :           Fetch<uint16_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, nRefPitches[2], VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV, time256);

	mov	edx, DWORD PTR [esi+476]
	mov	edi, DWORD PTR [esi+472]
	mov	eax, DWORD PTR [esi+468]

; 249  :   if (nPel == 1)

	mov	ebx, DWORD PTR _pDst$3$[ebp]
	mov	ecx, DWORD PTR [esi+392]
	jne	SHORT $LN306@GetFrame

; 250  :   {
; 251  :     Fetch_NPel <pixel_t,/*T256P,*/ 0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	ebx
	call	??$Fetch_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,0>
	jmp	$LN548@GetFrame
$LN306@GetFrame:

; 253  :   else if (nPel == 2)

	cmp	DWORD PTR [esi+104], 2
	jne	SHORT $LN308@GetFrame

; 254  :   {
; 255  :     Fetch_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	ebx
	call	??$Fetch_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,1>
	jmp	$LN548@GetFrame
$LN308@GetFrame:

; 256  :   }
; 257  :   else if (nPel == 4)

	cmp	DWORD PTR [esi+104], 4
	jne	$LN548@GetFrame

; 258  :   {
; 259  :     Fetch_NPel <pixel_t,/*T256P, */2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	ebx
	call	??$Fetch_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,2>

; 515  :         }

	jmp	$LN548@GetFrame
$LN27@GetFrame:

; 516  :         /*
; 517  :         Fetch(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, nRefPitches[0],
; 518  :           VXFullY, VPitchY, VYFullY, VPitchY, nWidth, nHeight,
; 519  :           Time256ProviderPlane(pt256[0], nt256Pitches[0], LUTV, LUTV)); //padded
; 520  :         Fetch(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, nRefPitches[1],
; 521  :           VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV,
; 522  :           Time256ProviderPlane(pt256[1], nt256Pitches[1], LUTV, LUTV));
; 523  :         Fetch(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, nRefPitches[2],
; 524  :           VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV,
; 525  :           Time256ProviderPlane(pt256[2], nt256Pitches[2], LUTV, LUTV));
; 526  :           */
; 527  :       }
; 528  :       else if (mode == 1) // shift mode

	cmp	eax, 1
	jne	$LN548@GetFrame

; 529  :       {
; 530  :         if (pixelsize == 1) {

	cmp	DWORD PTR [esi+136], eax
	jne	$LN32@GetFrame

; 531  :           MemZoneSet(pDst[0], 255, nWidth, nHeight, 0, 0, nDstPitches[0]);

	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+92]
	mov	edi, DWORD PTR _pDst$1$[ebp]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN314@GetFrame
	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
	mov	esi, eax
$LL315@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	255					; 000000ffH
	push	edi
	call	_memset
	mov	ecx, DWORD PTR _width$1$[ebp]
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	edi, ebx
	sub	esi, 1
	jne	SHORT $LL315@GetFrame
	mov	esi, DWORD PTR _this$[ebp]
$LN314@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 532  :           MemZoneSet(pDst[1], 255, nWidthUV, nHeightUV, 0, 0, nDstPitches[1]);

	mov	eax, DWORD PTR [esi+476]
	mov	ecx, DWORD PTR [esi+472]
	mov	edi, DWORD PTR _pDst$2$[ebp]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN319@GetFrame
	mov	ebx, DWORD PTR _nDstPitches$2$[ebp]
	mov	esi, eax
	npad	4
$LL320@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	255					; 000000ffH
	push	edi
	call	_memset
	mov	ecx, DWORD PTR _width$1$[ebp]
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	edi, ebx
	sub	esi, 1
	jne	SHORT $LL320@GetFrame
	mov	esi, DWORD PTR _this$[ebp]
$LN319@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 533  :           MemZoneSet(pDst[2], 255, nWidthUV, nHeightUV, 0, 0, nDstPitches[2]);

	mov	eax, DWORD PTR [esi+476]
	mov	ecx, DWORD PTR [esi+472]
	mov	edi, DWORD PTR _pDst$3$[ebp]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN324@GetFrame
	mov	ebx, DWORD PTR _nDstPitches$3$[ebp]
	mov	esi, eax
	npad	6
$LL325@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	255					; 000000ffH
	push	edi
	call	_memset
	mov	ecx, DWORD PTR _width$1$[ebp]
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	edi, ebx
	sub	esi, 1
	jne	SHORT $LL325@GetFrame
	mov	esi, DWORD PTR _this$[ebp]
$LN324@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 194  :   if (nPel == 1)

	mov	edi, DWORD PTR [esi+104]

; 534  :           Shift<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, nRefPitches[0], VXFullY, VPitchY, VYFullY, VPitchY, nWidth, nHeight, time256);

	mov	ecx, DWORD PTR [esi+392]
	mov	edx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+464]

; 194  :   if (nPel == 1)

	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
	cmp	edi, 1
	jne	SHORT $LN328@GetFrame

; 195  :   {
; 196  :     Shift_NPel <pixel_t,/*T256P,*/0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Shift_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,0>
	jmp	SHORT $LN332@GetFrame
$LN328@GetFrame:

; 197  :   }
; 198  :   else if (nPel == 2)

	cmp	edi, 2
	jne	SHORT $LN330@GetFrame

; 199  :   {
; 200  :     Shift_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Shift_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,1>
	jmp	SHORT $LN332@GetFrame
$LN330@GetFrame:

; 201  :   }
; 202  :   else if (nPel == 4)

	cmp	edi, 4
	jne	SHORT $LN332@GetFrame

; 203  :   {
; 204  :     Shift_NPel <pixel_t,/*T256P,*/ 2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	ecx
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Shift_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,2>
$LN332@GetFrame:

; 194  :   if (nPel == 1)

	mov	ecx, DWORD PTR [esi+104]

; 535  :           Shift<uint8_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, nRefPitches[1], VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV, time256);

	mov	ebx, DWORD PTR [esi+476]
	mov	eax, DWORD PTR [esi+468]

; 194  :   if (nPel == 1)

	mov	edx, DWORD PTR [esi+392]
	cmp	ecx, 1
	jne	SHORT $LN335@GetFrame

; 195  :   {
; 196  :     Shift_NPel <pixel_t,/*T256P,*/0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Shift_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,0>
	jmp	SHORT $LN339@GetFrame
$LN335@GetFrame:

; 197  :   }
; 198  :   else if (nPel == 2)

	cmp	ecx, 2
	jne	SHORT $LN337@GetFrame

; 199  :   {
; 200  :     Shift_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Shift_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,1>
	jmp	SHORT $LN339@GetFrame
$LN337@GetFrame:

; 201  :   }
; 202  :   else if (nPel == 4)

	cmp	ecx, 4
	jne	SHORT $LN339@GetFrame

; 203  :   {
; 204  :     Shift_NPel <pixel_t,/*T256P,*/ 2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Shift_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,2>
$LN339@GetFrame:

; 194  :   if (nPel == 1)

	cmp	DWORD PTR [esi+104], 1

; 536  :           Shift<uint8_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, nRefPitches[2], VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV, time256);

	mov	edx, DWORD PTR [esi+476]
	mov	ebx, DWORD PTR [esi+472]
	mov	eax, DWORD PTR [esi+468]

; 194  :   if (nPel == 1)

	mov	edi, DWORD PTR _pDst$3$[ebp]
	mov	ecx, DWORD PTR [esi+392]
	jne	SHORT $LN342@GetFrame

; 195  :   {
; 196  :     Shift_NPel <pixel_t,/*T256P,*/0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	ebx
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	edi
	call	??$Shift_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,0>
	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
	jmp	$LN424@GetFrame
$LN342@GetFrame:

; 197  :   }
; 198  :   else if (nPel == 2)

	cmp	DWORD PTR [esi+104], 2
	jne	SHORT $LN344@GetFrame

; 199  :   {
; 200  :     Shift_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	ebx
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	edi
	call	??$Shift_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,1>
	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
	jmp	$LN424@GetFrame
$LN344@GetFrame:

; 201  :   }
; 202  :   else if (nPel == 4)

	cmp	DWORD PTR [esi+104], 4
	jne	SHORT $LN545@GetFrame

; 203  :   {
; 204  :     Shift_NPel <pixel_t,/*T256P,*/ 2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	ebx
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	edi
	call	??$Shift_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,2>
$LN545@GetFrame:

; 537  :         }
; 538  :         else { // pixelsize == 2

	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
	jmp	$LN424@GetFrame
$LN32@GetFrame:

; 539  :           int max_pixel_value = (1 << bits_per_pixel) - 1;

	mov	ecx, DWORD PTR [esi+140]
	mov	eax, 1
; File c:\github\mvtools\sources\copycode.cpp

; 59   :   size_t size = height * pitch / sizeof(pixel_t);

	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
; File c:\github\mvtools\sources\mvflow.cpp

; 539  :           int max_pixel_value = (1 << bits_per_pixel) - 1;

	shl	eax, cl
; File c:\github\mvtools\sources\copycode.cpp

; 59   :   size_t size = height * pitch / sizeof(pixel_t);

	mov	ecx, ebx
	imul	ecx, DWORD PTR [esi+96]
; File c:\github\mvtools\sources\mvflow.cpp

; 539  :           int max_pixel_value = (1 << bits_per_pixel) - 1;

	dec	eax
	mov	DWORD PTR _max_pixel_value$1$[ebp], eax
; File c:\github\mvtools\sources\copycode.cpp

; 59   :   size_t size = height * pitch / sizeof(pixel_t);

	shr	ecx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2797 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

	je	SHORT $LN363@GetFrame
; File c:\github\mvtools\sources\mvflow.cpp

; 539  :           int max_pixel_value = (1 << bits_per_pixel) - 1;

	mov	edi, DWORD PTR _pDst$1$[ebp]
	movzx	edx, ax
	mov	eax, edx
	shl	edx, 16					; 00000010H
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
	mov	eax, DWORD PTR _max_pixel_value$1$[ebp]
$LN363@GetFrame:
; File c:\github\mvtools\sources\copycode.cpp

; 59   :   size_t size = height * pitch / sizeof(pixel_t);

	mov	ecx, ebx
	imul	ecx, DWORD PTR [esi+96]
	shr	ecx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2797 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

	je	SHORT $LN382@GetFrame
; File c:\github\mvtools\sources\mvflow.cpp

; 541  :           fill_plane<uint16_t>(pDst[1], nHeight, nDstPitches[0], max_pixel_value);

	mov	edi, DWORD PTR _pDst$2$[ebp]
	movzx	edx, ax
	mov	eax, edx
	shl	edx, 16					; 00000010H
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
$LN382@GetFrame:
; File c:\github\mvtools\sources\copycode.cpp

; 59   :   size_t size = height * pitch / sizeof(pixel_t);

	mov	ecx, ebx
	imul	ecx, DWORD PTR [esi+96]
	shr	ecx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2797 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

	je	SHORT $LN401@GetFrame
; File c:\github\mvtools\sources\mvflow.cpp

; 542  :           fill_plane<uint16_t>(pDst[2], nHeight, nDstPitches[0], max_pixel_value);

	mov	eax, DWORD PTR _max_pixel_value$1$[ebp]
	mov	edi, DWORD PTR _pDst$3$[ebp]
	movzx	edx, ax
	mov	eax, edx
	shl	edx, 16					; 00000010H
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
$LN401@GetFrame:

; 194  :   if (nPel == 1)

	cmp	DWORD PTR [esi+104], 1

; 543  :           Shift<uint16_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, nRefPitches[0], VXFullY, VPitchY, VYFullY, VPitchY, nWidth, nHeight, time256);

	mov	edx, DWORD PTR [esi+96]
	mov	edi, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [esi+464]

; 194  :   if (nPel == 1)

	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
	mov	ecx, DWORD PTR [esi+392]
	jne	SHORT $LN406@GetFrame

; 195  :   {
; 196  :     Shift_NPel <pixel_t,/*T256P,*/0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Shift_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,0>
	jmp	SHORT $LN410@GetFrame
$LN406@GetFrame:

; 197  :   }
; 198  :   else if (nPel == 2)

	cmp	DWORD PTR [esi+104], 2
	jne	SHORT $LN408@GetFrame

; 199  :   {
; 200  :     Shift_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Shift_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,1>
	jmp	SHORT $LN410@GetFrame
$LN408@GetFrame:

; 201  :   }
; 202  :   else if (nPel == 4)

	cmp	DWORD PTR [esi+104], 4
	jne	SHORT $LN410@GetFrame

; 203  :   {
; 204  :     Shift_NPel <pixel_t,/*T256P,*/ 2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	push	eax
	push	DWORD PTR [esi+416]
	push	eax
	push	DWORD PTR [esi+408]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	push	DWORD PTR _nRefPitches$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _pDst$1$[ebp]
	call	??$Shift_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,2>
$LN410@GetFrame:

; 194  :   if (nPel == 1)

	mov	ecx, DWORD PTR [esi+104]

; 544  :           Shift<uint16_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, nRefPitches[1], VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV, time256);

	mov	edi, DWORD PTR [esi+476]
	mov	eax, DWORD PTR [esi+468]

; 194  :   if (nPel == 1)

	mov	edx, DWORD PTR [esi+392]
	cmp	ecx, 1
	jne	SHORT $LN413@GetFrame

; 195  :   {
; 196  :     Shift_NPel <pixel_t,/*T256P,*/0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Shift_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,0>
	jmp	SHORT $LN417@GetFrame
$LN413@GetFrame:

; 197  :   }
; 198  :   else if (nPel == 2)

	cmp	ecx, 2
	jne	SHORT $LN415@GetFrame

; 199  :   {
; 200  :     Shift_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Shift_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,1>
	jmp	SHORT $LN417@GetFrame
$LN415@GetFrame:

; 201  :   }
; 202  :   else if (nPel == 4)

	cmp	ecx, 4
	jne	SHORT $LN417@GetFrame

; 203  :   {
; 204  :     Shift_NPel <pixel_t,/*T256P,*/ 2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	mov	ecx, DWORD PTR [esi+472]
	push	edx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+420]
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+412]
	push	eax
	push	DWORD PTR _nRefPitches$2$[ebp]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	call	??$Shift_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,2>
$LN417@GetFrame:

; 194  :   if (nPel == 1)

	cmp	DWORD PTR [esi+104], 1

; 545  :           Shift<uint16_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, nRefPitches[2], VXFullUV, VPitchUV, VYFullUV, VPitchUV, nWidthUV, nHeightUV, time256);

	mov	edx, DWORD PTR [esi+476]
	mov	edi, DWORD PTR [esi+472]
	mov	eax, DWORD PTR [esi+468]

; 194  :   if (nPel == 1)

	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
	mov	ecx, DWORD PTR [esi+392]
	jne	SHORT $LN420@GetFrame

; 195  :   {
; 196  :     Shift_NPel <pixel_t,/*T256P,*/0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	mov	edi, DWORD PTR _pDst$3$[ebp]
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	edi
	call	??$Shift_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,0>
	jmp	$LN424@GetFrame
$LN420@GetFrame:

; 197  :   }
; 198  :   else if (nPel == 2)

	cmp	DWORD PTR [esi+104], 2
	jne	SHORT $LN422@GetFrame

; 199  :   {
; 200  :     Shift_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	mov	edi, DWORD PTR _pDst$3$[ebp]
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	edi
	call	??$Shift_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,1>
	jmp	$LN424@GetFrame
$LN422@GetFrame:

; 201  :   }
; 202  :   else if (nPel == 4)

	cmp	DWORD PTR [esi+104], 4
	jne	$LN549@GetFrame

; 203  :   {
; 204  :     Shift_NPel <pixel_t,/*T256P,*/ 2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);

	push	ecx
	push	edx
	push	edi
	mov	edi, DWORD PTR _pDst$3$[ebp]
	push	eax
	push	DWORD PTR [esi+420]
	push	eax
	push	DWORD PTR [esi+412]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	edi
	call	??$Shift_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,2>
	jmp	$LN424@GetFrame
$LN427@GetFrame:
; File c:\github\mvtools\sources\yuy2planes.cpp

; 160  :     convert_yv16_to_yuy2_c(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	ecx
	push	edx
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	mov	edx, DWORD PTR _pDst$2$[ebp]
	mov	ecx, eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	ebx
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	edi
	call	?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_c
$LN556@GetFrame:
	add	esp, 28					; 0000001cH
$LN428@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	edx, edx
	je	SHORT $LN434@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN434@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN434@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 8
	test	edx, edx
	je	SHORT $LN438@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN438@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvn$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN438@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	test	edx, edx
	je	SHORT $LN443@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN443@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _t256$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN443@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN448@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN448@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN448@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File c:\github\mvtools\sources\mvflow.cpp

; 566  :     return dst;

	jmp	$LN560@GetFrame
$LN18@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvflow.cpp

; 571  :     PVideoFrame	src = child->GetFrame(n, env);

	lea	edx, DWORD PTR _src$6[ebp]
	push	DWORD PTR _n$[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\mvflow.cpp

; 571  :     PVideoFrame	src = child->GetFrame(n, env);

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN460@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN460@GetFrame
	lea	eax, DWORD PTR _src$6[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN460@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	edx, edx
	je	SHORT $LN464@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN464@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$6[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN464@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	test	edx, edx
	je	SHORT $LN469@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN469@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvn$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN469@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	edx, edx
	je	SHORT $LN474@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN474@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _t256$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN474@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	edx, edx
	je	SHORT $LN479@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN479@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN479@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
$LN560@GetFrame:
	test	edx, edx
	je	SHORT $LN484@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN484@GetFrame
	mov	edx, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN484@GetFrame:
; File c:\github\mvtools\sources\mvflow.cpp

; 575  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _dst$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _ref$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _t256$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR _mvn$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$14:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$15:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7:
	lea	ecx, DWORD PTR _src$6[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$17:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$18:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$19:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$20:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVFlow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVFlow::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ??$AlignNumber@H@@YAHHH@Z
_TEXT	SEGMENT
??$AlignNumber@H@@YAHHH@Z PROC				; AlignNumber<int>, COMDAT
; _n$ = ecx
; _align$dead$ = edx

; 137  :   assert(IS_POWER2(align));
; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [ecx+15]
	and	eax, -16				; fffffff0H

; 139  : }

	ret	0
??$AlignNumber@H@@YAHHH@Z ENDP				; AlignNumber<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$min@F@std@@YAABFABF0@Z
_TEXT	SEGMENT
??$min@F@std@@YAABFABF0@Z PROC				; std::min<short>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	cmovl	ecx, edx
	mov	eax, ecx

; 3650 : 	}

	ret	0
??$min@F@std@@YAABFABF0@Z ENDP				; std::min<short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Fetch@E@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_pdst$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Fetch@E@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC		; MVFlow::Fetch<unsigned char>, COMDAT
; _this$ = ecx

; 249  :   if (nPel == 1)

	mov	eax, DWORD PTR [ecx+104]
	cmp	eax, 1
	je	??$Fetch_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,0>

; 250  :   {
; 251  :     Fetch_NPel <pixel_t,/*T256P,*/ 0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);
; 252  :   }
; 253  :   else if (nPel == 2)

	cmp	eax, 2
	je	??$Fetch_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,1>

; 254  :   {
; 255  :     Fetch_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);
; 256  :   }
; 257  :   else if (nPel == 4)

	cmp	eax, 4
	je	??$Fetch_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned char,2>

; 258  :   {
; 259  :     Fetch_NPel <pixel_t,/*T256P, */2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);
; 260  :   }
; 261  : }

	ret	44					; 0000002cH
??$Fetch@E@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP		; MVFlow::Fetch<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Fetch@G@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_pdst$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Fetch@G@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC		; MVFlow::Fetch<unsigned short>, COMDAT
; _this$ = ecx

; 249  :   if (nPel == 1)

	mov	eax, DWORD PTR [ecx+104]
	cmp	eax, 1
	je	??$Fetch_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,0>

; 250  :   {
; 251  :     Fetch_NPel <pixel_t,/*T256P,*/ 0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);
; 252  :   }
; 253  :   else if (nPel == 2)

	cmp	eax, 2
	je	??$Fetch_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,1>

; 254  :   {
; 255  :     Fetch_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);
; 256  :   }
; 257  :   else if (nPel == 4)

	cmp	eax, 4
	je	??$Fetch_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Fetch_NPel<unsigned short,2>

; 258  :   {
; 259  :     Fetch_NPel <pixel_t,/*T256P, */2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256 /*t256_provider*/);
; 260  :   }
; 261  : }

	ret	44					; 0000002cH
??$Fetch@G@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP		; MVFlow::Fetch<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Shift@E@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_pdst$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Shift@E@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC		; MVFlow::Shift<unsigned char>, COMDAT
; _this$ = ecx

; 193  :   // shift mode
; 194  :   if (nPel == 1)

	mov	eax, DWORD PTR [ecx+104]
	cmp	eax, 1
	je	??$Shift_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,0>

; 195  :   {
; 196  :     Shift_NPel <pixel_t,/*T256P,*/0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);
; 197  :   }
; 198  :   else if (nPel == 2)

	cmp	eax, 2
	je	??$Shift_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,1>

; 199  :   {
; 200  :     Shift_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);
; 201  :   }
; 202  :   else if (nPel == 4)

	cmp	eax, 4
	je	??$Shift_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned char,2>

; 203  :   {
; 204  :     Shift_NPel <pixel_t,/*T256P,*/ 2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);
; 205  :   }
; 206  : }

	ret	44					; 0000002cH
??$Shift@E@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP		; MVFlow::Shift<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Shift@G@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_pdst$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Shift@G@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC		; MVFlow::Shift<unsigned short>, COMDAT
; _this$ = ecx

; 193  :   // shift mode
; 194  :   if (nPel == 1)

	mov	eax, DWORD PTR [ecx+104]
	cmp	eax, 1
	je	??$Shift_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,0>

; 195  :   {
; 196  :     Shift_NPel <pixel_t,/*T256P,*/0>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);
; 197  :   }
; 198  :   else if (nPel == 2)

	cmp	eax, 2
	je	??$Shift_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,1>

; 199  :   {
; 200  :     Shift_NPel <pixel_t,/*T256P,*/ 1>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);
; 201  :   }
; 202  :   else if (nPel == 4)

	cmp	eax, 4
	je	??$Shift_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ; MVFlow::Shift_NPel<unsigned short,2>

; 203  :   {
; 204  :     Shift_NPel <pixel_t,/*T256P,*/ 2>(pdst, dst_pitch, pref, ref_pitch, VXFull, VXPitch, VYFull, VYPitch, width, height, time256/*t256_provider*/);
; 205  :   }
; 206  : }

	ret	44					; 0000002cH
??$Shift@G@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP		; MVFlow::Shift<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Fetch_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
tv317 = 8						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
tv316 = 16						; size = 4
_pref8$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Fetch_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC ; MVFlow::Fetch_NPel<unsigned char,0>, COMDAT
; _this$dead$ = ecx

; 271  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 272  : 
; 273  :   for (int h = 0; h < height; h++)

	cmp	DWORD PTR _height$[esp-4], 0
	push	ebx
	mov	ebx, DWORD PTR _pdst8$[esp]
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+4]
	jle	$LN3@Fetch_NPel

; 268  :   dst_pitch /= sizeof(pixel_t);
; 269  :   ref_pitch /= sizeof(pixel_t);
; 270  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);

	mov	eax, DWORD PTR _VXPitch$[esp+4]
	mov	edx, DWORD PTR _width$[esp+4]
	add	eax, eax
	mov	ecx, DWORD PTR _VXFull$[esp+4]
	mov	DWORD PTR tv317[esp+4], eax
	mov	eax, DWORD PTR _VYPitch$[esp+4]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv316[esp+8], eax
	push	edi
$LL4@Fetch_NPel:

; 274  :   {
; 275  :     for (int w = 0; w < width; w++)

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN6@Fetch_NPel
	mov	edi, DWORD PTR _VYFull$[esp+12]
	mov	esi, ecx
	sub	edi, ecx
$LL7@Fetch_NPel:

; 276  :     {
; 277  :       // ex 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 278  : 
; 279  : /*   2.5.11.22:
; 280  :      pel==1
; 281  :       int vx = ((VXFull[w])*time256 + 128) >> 8;
; 282  :       int vy = ((VYFull[w])*time256 + 128) >> 8;
; 283  :       pdst[w] = pref[vy*ref_pitch + vx + w];
; 284  :      pel==2 use interpolated image
; 285  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 286  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 287  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<1)];
; 288  :      pel==4
; 289  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 290  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 291  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<2)];
; 292  :       */
; 293  :       /* 2.6.0.5
; 294  :       int vx = t256_provider.get_vect_f (time256, VXFull[w]);
; 295  :       int vy = t256_provider.get_vect_f (time256, VYFull[w]);
; 296  :       */
; 297  :       int vx = ((VXFull[w])*time256 + 128) >> 8; // 2.5.11.22
; 298  :       int vy = ((VYFull[w])*time256 + 128) >> 8; // 2.5.11.22 

	movsx	edx, WORD PTR [edi+esi]
	lea	esi, DWORD PTR [esi+2]
	imul	edx, DWORD PTR _time256$[esp+12]
	movsx	ecx, WORD PTR [esi-2]
	imul	ecx, DWORD PTR _time256$[esp+12]
	sub	edx, -128				; ffffff80H
	sar	edx, 8

; 299  : 
; 300  :       pdst[w] = pref[vy*ref_pitch + vx + (w << NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+12]
	sub	ecx, -128				; ffffff80H
	sar	ecx, 8
	add	edx, eax
	add	ecx, edx
	mov	edx, DWORD PTR _width$[esp+12]
	mov	cl, BYTE PTR [ecx+ebp]
	mov	BYTE PTR [eax+ebx], cl
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL7@Fetch_NPel
	mov	ecx, DWORD PTR _VXFull$[esp+12]
$LN6@Fetch_NPel:

; 301  :     }
; 302  :     pref += (ref_pitch) << NPELL2;
; 303  :     pdst += dst_pitch;
; 304  :     // do nothing t256_provider.jump_to_next_row ();
; 305  :     VXFull += VXPitch;

	add	ecx, DWORD PTR tv317[esp+12]

; 306  :     VYFull += VYPitch;

	mov	eax, DWORD PTR tv316[esp+12]
	add	ebp, DWORD PTR _ref_pitch$[esp+12]
	add	ebx, DWORD PTR _dst_pitch$[esp+12]
	add	DWORD PTR _VYFull$[esp+12], eax
	sub	DWORD PTR _height$[esp+12], 1
	mov	DWORD PTR _VXFull$[esp+12], ecx
	jne	SHORT $LL4@Fetch_NPel
	pop	edi
	pop	esi
$LN3@Fetch_NPel:
	pop	ebp
	pop	ebx

; 307  :   }
; 308  : }

	ret	44					; 0000002cH
??$Fetch_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP ; MVFlow::Fetch_NPel<unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Fetch_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
tv322 = 8						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
tv321 = 16						; size = 4
_pref8$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv320 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Fetch_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC	; MVFlow::Fetch_NPel<unsigned char,1>, COMDAT
; _this$dead$ = ecx

; 271  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 272  : 
; 273  :   for (int h = 0; h < height; h++)

	cmp	DWORD PTR _height$[esp-4], 0
	push	ebx
	mov	ebx, DWORD PTR _pdst8$[esp]
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+4]
	jle	$LN3@Fetch_NPel

; 268  :   dst_pitch /= sizeof(pixel_t);
; 269  :   ref_pitch /= sizeof(pixel_t);
; 270  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);

	mov	eax, DWORD PTR _ref_pitch$[esp+4]
	mov	edx, DWORD PTR _width$[esp+4]
	add	eax, eax
	mov	ecx, DWORD PTR _VXFull$[esp+4]
	mov	DWORD PTR tv322[esp+4], eax
	mov	eax, DWORD PTR _VXPitch$[esp+4]
	add	eax, eax
	mov	DWORD PTR tv321[esp+4], eax
	mov	eax, DWORD PTR _VYPitch$[esp+4]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv320[esp+8], eax
	push	edi
	npad	3
$LL4@Fetch_NPel:

; 274  :   {
; 275  :     for (int w = 0; w < width; w++)

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN6@Fetch_NPel
	mov	edi, DWORD PTR _VYFull$[esp+12]
	mov	esi, ecx
	sub	edi, ecx
	npad	2
$LL7@Fetch_NPel:

; 276  :     {
; 277  :       // ex 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 278  : 
; 279  : /*   2.5.11.22:
; 280  :      pel==1
; 281  :       int vx = ((VXFull[w])*time256 + 128) >> 8;
; 282  :       int vy = ((VYFull[w])*time256 + 128) >> 8;
; 283  :       pdst[w] = pref[vy*ref_pitch + vx + w];
; 284  :      pel==2 use interpolated image
; 285  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 286  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 287  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<1)];
; 288  :      pel==4
; 289  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 290  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 291  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<2)];
; 292  :       */
; 293  :       /* 2.6.0.5
; 294  :       int vx = t256_provider.get_vect_f (time256, VXFull[w]);
; 295  :       int vy = t256_provider.get_vect_f (time256, VYFull[w]);
; 296  :       */
; 297  :       int vx = ((VXFull[w])*time256 + 128) >> 8; // 2.5.11.22
; 298  :       int vy = ((VYFull[w])*time256 + 128) >> 8; // 2.5.11.22 

	movsx	edx, WORD PTR [edi+esi]
	lea	esi, DWORD PTR [esi+2]
	imul	edx, DWORD PTR _time256$[esp+12]
	movsx	ecx, WORD PTR [esi-2]
	imul	ecx, DWORD PTR _time256$[esp+12]
	sub	edx, -128				; ffffff80H
	sar	edx, 8

; 299  : 
; 300  :       pdst[w] = pref[vy*ref_pitch + vx + (w << NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+12]
	sub	ecx, -128				; ffffff80H
	sar	ecx, 8
	add	ecx, ebp
	add	ecx, edx
	mov	edx, DWORD PTR _width$[esp+12]
	mov	cl, BYTE PTR [ecx+eax*2]
	mov	BYTE PTR [eax+ebx], cl
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL7@Fetch_NPel
	mov	ecx, DWORD PTR _VXFull$[esp+12]
$LN6@Fetch_NPel:

; 301  :     }
; 302  :     pref += (ref_pitch) << NPELL2;
; 303  :     pdst += dst_pitch;
; 304  :     // do nothing t256_provider.jump_to_next_row ();
; 305  :     VXFull += VXPitch;

	add	ecx, DWORD PTR tv321[esp+12]

; 306  :     VYFull += VYPitch;

	mov	eax, DWORD PTR tv320[esp+12]
	add	ebp, DWORD PTR tv322[esp+12]
	add	ebx, DWORD PTR _dst_pitch$[esp+12]
	add	DWORD PTR _VYFull$[esp+12], eax
	sub	DWORD PTR _height$[esp+12], 1
	mov	DWORD PTR _VXFull$[esp+12], ecx
	jne	SHORT $LL4@Fetch_NPel
	pop	edi
	pop	esi
$LN3@Fetch_NPel:
	pop	ebp
	pop	ebx

; 307  :   }
; 308  : }

	ret	44					; 0000002cH
??$Fetch_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP	; MVFlow::Fetch_NPel<unsigned char,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Fetch_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
tv326 = 8						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
tv325 = 16						; size = 4
_pref8$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv324 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Fetch_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC	; MVFlow::Fetch_NPel<unsigned char,2>, COMDAT
; _this$dead$ = ecx

; 271  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 272  : 
; 273  :   for (int h = 0; h < height; h++)

	cmp	DWORD PTR _height$[esp-4], 0
	push	ebx
	mov	ebx, DWORD PTR _pdst8$[esp]
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+4]
	jle	$LN3@Fetch_NPel

; 268  :   dst_pitch /= sizeof(pixel_t);
; 269  :   ref_pitch /= sizeof(pixel_t);
; 270  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);

	mov	eax, DWORD PTR _ref_pitch$[esp+4]
	mov	edx, DWORD PTR _width$[esp+4]
	mov	ecx, DWORD PTR _VXFull$[esp+4]
	shl	eax, 2
	mov	DWORD PTR tv326[esp+4], eax
	mov	eax, DWORD PTR _VXPitch$[esp+4]
	add	eax, eax
	mov	DWORD PTR tv325[esp+4], eax
	mov	eax, DWORD PTR _VYPitch$[esp+4]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv324[esp+8], eax
	push	edi
	npad	2
$LL4@Fetch_NPel:

; 274  :   {
; 275  :     for (int w = 0; w < width; w++)

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN6@Fetch_NPel
	mov	edi, DWORD PTR _VYFull$[esp+12]
	mov	esi, ecx
	sub	edi, ecx
	npad	2
$LL7@Fetch_NPel:

; 276  :     {
; 277  :       // ex 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 278  : 
; 279  : /*   2.5.11.22:
; 280  :      pel==1
; 281  :       int vx = ((VXFull[w])*time256 + 128) >> 8;
; 282  :       int vy = ((VYFull[w])*time256 + 128) >> 8;
; 283  :       pdst[w] = pref[vy*ref_pitch + vx + w];
; 284  :      pel==2 use interpolated image
; 285  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 286  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 287  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<1)];
; 288  :      pel==4
; 289  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 290  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 291  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<2)];
; 292  :       */
; 293  :       /* 2.6.0.5
; 294  :       int vx = t256_provider.get_vect_f (time256, VXFull[w]);
; 295  :       int vy = t256_provider.get_vect_f (time256, VYFull[w]);
; 296  :       */
; 297  :       int vx = ((VXFull[w])*time256 + 128) >> 8; // 2.5.11.22
; 298  :       int vy = ((VYFull[w])*time256 + 128) >> 8; // 2.5.11.22 

	movsx	edx, WORD PTR [edi+esi]
	lea	esi, DWORD PTR [esi+2]
	imul	edx, DWORD PTR _time256$[esp+12]
	movsx	ecx, WORD PTR [esi-2]
	imul	ecx, DWORD PTR _time256$[esp+12]
	sub	edx, -128				; ffffff80H
	sar	edx, 8

; 299  : 
; 300  :       pdst[w] = pref[vy*ref_pitch + vx + (w << NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+12]
	sub	ecx, -128				; ffffff80H
	sar	ecx, 8
	add	ecx, ebp
	add	ecx, edx
	mov	edx, DWORD PTR _width$[esp+12]
	mov	cl, BYTE PTR [ecx+eax*4]
	mov	BYTE PTR [eax+ebx], cl
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL7@Fetch_NPel
	mov	ecx, DWORD PTR _VXFull$[esp+12]
$LN6@Fetch_NPel:

; 301  :     }
; 302  :     pref += (ref_pitch) << NPELL2;
; 303  :     pdst += dst_pitch;
; 304  :     // do nothing t256_provider.jump_to_next_row ();
; 305  :     VXFull += VXPitch;

	add	ecx, DWORD PTR tv325[esp+12]

; 306  :     VYFull += VYPitch;

	mov	eax, DWORD PTR tv324[esp+12]
	add	ebp, DWORD PTR tv326[esp+12]
	add	ebx, DWORD PTR _dst_pitch$[esp+12]
	add	DWORD PTR _VYFull$[esp+12], eax
	sub	DWORD PTR _height$[esp+12], 1
	mov	DWORD PTR _VXFull$[esp+12], ecx
	jne	SHORT $LL4@Fetch_NPel
	pop	edi
	pop	esi
$LN3@Fetch_NPel:
	pop	ebp
	pop	ebx

; 307  :   }
; 308  : }

	ret	44					; 0000002cH
??$Fetch_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP	; MVFlow::Fetch_NPel<unsigned char,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Fetch_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_pdst8$ = 8						; size = 4
tv323 = 12						; size = 4
_dst_pitch$ = 12					; size = 4
tv322 = 16						; size = 4
_pref8$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv321 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv320 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Fetch_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC ; MVFlow::Fetch_NPel<unsigned short,0>, COMDAT
; _this$dead$ = ecx

; 268  :   dst_pitch /= sizeof(pixel_t);
; 269  :   ref_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _ref_pitch$[esp-4]
	mov	ecx, DWORD PTR _dst_pitch$[esp-4]
	push	ebx

; 270  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 271  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 272  : 
; 273  :   for (int h = 0; h < height; h++)

	mov	ebx, DWORD PTR _height$[esp]
	shr	eax, 1
	shr	ecx, 1
	mov	DWORD PTR _ref_pitch$[esp], eax
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+4]
	test	ebx, ebx
	jle	$LN3@Fetch_NPel
	mov	edx, DWORD PTR _VYFull$[esp+4]
	add	eax, eax
	mov	DWORD PTR tv323[esp+4], eax
	lea	eax, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _VXFull$[esp+4]
	mov	DWORD PTR tv322[esp+4], eax
	mov	eax, DWORD PTR _VXPitch$[esp+4]
	add	eax, eax
	mov	DWORD PTR tv321[esp+4], eax
	mov	eax, DWORD PTR _VYPitch$[esp+4]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv320[esp+8], eax
	mov	eax, DWORD PTR _pdst8$[esp+8]
	push	edi
$LL4@Fetch_NPel:

; 274  :   {
; 275  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	cmp	DWORD PTR _width$[esp+12], esi
	jle	SHORT $LN6@Fetch_NPel
	mov	ebx, DWORD PTR _pdst8$[esp+12]
	mov	edi, edx
	sub	edi, ecx
	mov	eax, ecx
	sub	ebx, ecx
	npad	11
$LL7@Fetch_NPel:

; 276  :     {
; 277  :       // ex 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 278  : 
; 279  : /*   2.5.11.22:
; 280  :      pel==1
; 281  :       int vx = ((VXFull[w])*time256 + 128) >> 8;
; 282  :       int vy = ((VYFull[w])*time256 + 128) >> 8;
; 283  :       pdst[w] = pref[vy*ref_pitch + vx + w];
; 284  :      pel==2 use interpolated image
; 285  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 286  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 287  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<1)];
; 288  :      pel==4
; 289  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 290  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 291  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<2)];
; 292  :       */
; 293  :       /* 2.6.0.5
; 294  :       int vx = t256_provider.get_vect_f (time256, VXFull[w]);
; 295  :       int vy = t256_provider.get_vect_f (time256, VYFull[w]);
; 296  :       */
; 297  :       int vx = ((VXFull[w])*time256 + 128) >> 8; // 2.5.11.22
; 298  :       int vy = ((VYFull[w])*time256 + 128) >> 8; // 2.5.11.22 

	movsx	edx, WORD PTR [edi+eax]
	lea	eax, DWORD PTR [eax+2]
	imul	edx, DWORD PTR _time256$[esp+12]
	movsx	ecx, WORD PTR [eax-2]
	imul	ecx, DWORD PTR _time256$[esp+12]
	sub	edx, -128				; ffffff80H
	sar	edx, 8

; 299  : 
; 300  :       pdst[w] = pref[vy*ref_pitch + vx + (w << NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+12]
	sub	ecx, -128				; ffffff80H
	sar	ecx, 8
	add	edx, esi
	inc	esi
	add	ecx, edx
	mov	cx, WORD PTR [ebp+ecx*2]
	mov	WORD PTR [ebx+eax-2], cx
	cmp	esi, DWORD PTR _width$[esp+12]
	jl	SHORT $LL7@Fetch_NPel
	mov	ecx, DWORD PTR _VXFull$[esp+12]
	mov	eax, DWORD PTR _pdst8$[esp+12]
	mov	edx, DWORD PTR _VYFull$[esp+12]
	mov	ebx, DWORD PTR _height$[esp+12]
$LN6@Fetch_NPel:

; 301  :     }
; 302  :     pref += (ref_pitch) << NPELL2;
; 303  :     pdst += dst_pitch;

	add	eax, DWORD PTR tv322[esp+12]

; 304  :     // do nothing t256_provider.jump_to_next_row ();
; 305  :     VXFull += VXPitch;

	add	ecx, DWORD PTR tv321[esp+12]

; 306  :     VYFull += VYPitch;

	add	edx, DWORD PTR tv320[esp+12]
	add	ebp, DWORD PTR tv323[esp+12]
	sub	ebx, 1
	mov	DWORD PTR _pdst8$[esp+12], eax
	mov	DWORD PTR _VXFull$[esp+12], ecx
	mov	DWORD PTR _VYFull$[esp+12], edx
	mov	DWORD PTR _height$[esp+12], ebx
	jne	$LL4@Fetch_NPel
	pop	edi
	pop	esi
$LN3@Fetch_NPel:
	pop	ebp
	pop	ebx

; 307  :   }
; 308  : }

	ret	44					; 0000002cH
??$Fetch_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP ; MVFlow::Fetch_NPel<unsigned short,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Fetch_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_pdst8$ = 8						; size = 4
tv336 = 12						; size = 4
_dst_pitch$ = 12					; size = 4
tv335 = 16						; size = 4
_pref8$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv334 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv333 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Fetch_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC	; MVFlow::Fetch_NPel<unsigned short,1>, COMDAT
; _this$dead$ = ecx

; 268  :   dst_pitch /= sizeof(pixel_t);
; 269  :   ref_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _ref_pitch$[esp-4]
	mov	ecx, DWORD PTR _dst_pitch$[esp-4]
	push	ebx

; 270  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 271  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 272  : 
; 273  :   for (int h = 0; h < height; h++)

	mov	ebx, DWORD PTR _height$[esp]
	shr	eax, 1
	shr	ecx, 1
	mov	DWORD PTR _ref_pitch$[esp], eax
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+4]
	test	ebx, ebx
	jle	$LN3@Fetch_NPel
	mov	edx, DWORD PTR _VYFull$[esp+4]
	shl	eax, 2
	mov	DWORD PTR tv336[esp+4], eax
	lea	eax, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _VXFull$[esp+4]
	mov	DWORD PTR tv335[esp+4], eax
	mov	eax, DWORD PTR _VXPitch$[esp+4]
	add	eax, eax
	mov	DWORD PTR tv334[esp+4], eax
	mov	eax, DWORD PTR _VYPitch$[esp+4]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv333[esp+8], eax
	mov	eax, DWORD PTR _pdst8$[esp+8]
	push	edi
$LL4@Fetch_NPel:

; 274  :   {
; 275  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	cmp	DWORD PTR _width$[esp+12], esi
	jle	SHORT $LN6@Fetch_NPel
	mov	ebx, DWORD PTR _pdst8$[esp+12]
	mov	edi, edx
	sub	edi, ecx
	mov	eax, ecx
	sub	ebx, ecx
	npad	10
$LL7@Fetch_NPel:

; 276  :     {
; 277  :       // ex 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 278  : 
; 279  : /*   2.5.11.22:
; 280  :      pel==1
; 281  :       int vx = ((VXFull[w])*time256 + 128) >> 8;
; 282  :       int vy = ((VYFull[w])*time256 + 128) >> 8;
; 283  :       pdst[w] = pref[vy*ref_pitch + vx + w];
; 284  :      pel==2 use interpolated image
; 285  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 286  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 287  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<1)];
; 288  :      pel==4
; 289  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 290  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 291  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<2)];
; 292  :       */
; 293  :       /* 2.6.0.5
; 294  :       int vx = t256_provider.get_vect_f (time256, VXFull[w]);
; 295  :       int vy = t256_provider.get_vect_f (time256, VYFull[w]);
; 296  :       */
; 297  :       int vx = ((VXFull[w])*time256 + 128) >> 8; // 2.5.11.22
; 298  :       int vy = ((VYFull[w])*time256 + 128) >> 8; // 2.5.11.22 

	movsx	edx, WORD PTR [edi+eax]
	lea	eax, DWORD PTR [eax+2]
	imul	edx, DWORD PTR _time256$[esp+12]
	movsx	ecx, WORD PTR [eax-2]
	imul	ecx, DWORD PTR _time256$[esp+12]
	sub	edx, -128				; ffffff80H
	sar	edx, 8

; 299  : 
; 300  :       pdst[w] = pref[vy*ref_pitch + vx + (w << NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+12]
	sub	ecx, -128				; ffffff80H
	sar	ecx, 8
	add	edx, ecx
	lea	ecx, DWORD PTR [edx+esi*2]
	inc	esi
	mov	cx, WORD PTR [ebp+ecx*2]
	mov	WORD PTR [ebx+eax-2], cx
	cmp	esi, DWORD PTR _width$[esp+12]
	jl	SHORT $LL7@Fetch_NPel
	mov	ecx, DWORD PTR _VXFull$[esp+12]
	mov	eax, DWORD PTR _pdst8$[esp+12]
	mov	edx, DWORD PTR _VYFull$[esp+12]
	mov	ebx, DWORD PTR _height$[esp+12]
$LN6@Fetch_NPel:

; 301  :     }
; 302  :     pref += (ref_pitch) << NPELL2;
; 303  :     pdst += dst_pitch;

	add	eax, DWORD PTR tv335[esp+12]

; 304  :     // do nothing t256_provider.jump_to_next_row ();
; 305  :     VXFull += VXPitch;

	add	ecx, DWORD PTR tv334[esp+12]

; 306  :     VYFull += VYPitch;

	add	edx, DWORD PTR tv333[esp+12]
	add	ebp, DWORD PTR tv336[esp+12]
	sub	ebx, 1
	mov	DWORD PTR _pdst8$[esp+12], eax
	mov	DWORD PTR _VXFull$[esp+12], ecx
	mov	DWORD PTR _VYFull$[esp+12], edx
	mov	DWORD PTR _height$[esp+12], ebx
	jne	$LL4@Fetch_NPel
	pop	edi
	pop	esi
$LN3@Fetch_NPel:
	pop	ebp
	pop	ebx

; 307  :   }
; 308  : }

	ret	44					; 0000002cH
??$Fetch_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP	; MVFlow::Fetch_NPel<unsigned short,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Fetch_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_pdst8$ = 8						; size = 4
tv336 = 12						; size = 4
_dst_pitch$ = 12					; size = 4
tv335 = 16						; size = 4
_pref8$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv334 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv333 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Fetch_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC	; MVFlow::Fetch_NPel<unsigned short,2>, COMDAT
; _this$dead$ = ecx

; 268  :   dst_pitch /= sizeof(pixel_t);
; 269  :   ref_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _ref_pitch$[esp-4]
	mov	ecx, DWORD PTR _dst_pitch$[esp-4]
	push	ebx

; 270  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 271  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 272  : 
; 273  :   for (int h = 0; h < height; h++)

	mov	ebx, DWORD PTR _height$[esp]
	shr	eax, 1
	shr	ecx, 1
	mov	DWORD PTR _ref_pitch$[esp], eax
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+4]
	test	ebx, ebx
	jle	$LN3@Fetch_NPel
	mov	edx, DWORD PTR _VYFull$[esp+4]
	shl	eax, 3
	mov	DWORD PTR tv336[esp+4], eax
	lea	eax, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _VXFull$[esp+4]
	mov	DWORD PTR tv335[esp+4], eax
	mov	eax, DWORD PTR _VXPitch$[esp+4]
	add	eax, eax
	mov	DWORD PTR tv334[esp+4], eax
	mov	eax, DWORD PTR _VYPitch$[esp+4]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv333[esp+8], eax
	mov	eax, DWORD PTR _pdst8$[esp+8]
	push	edi
$LL4@Fetch_NPel:

; 274  :   {
; 275  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	cmp	DWORD PTR _width$[esp+12], esi
	jle	SHORT $LN6@Fetch_NPel
	mov	ebx, DWORD PTR _pdst8$[esp+12]
	mov	edi, edx
	sub	edi, ecx
	mov	eax, ecx
	sub	ebx, ecx
	npad	10
$LL7@Fetch_NPel:

; 276  :     {
; 277  :       // ex 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 278  : 
; 279  : /*   2.5.11.22:
; 280  :      pel==1
; 281  :       int vx = ((VXFull[w])*time256 + 128) >> 8;
; 282  :       int vy = ((VYFull[w])*time256 + 128) >> 8;
; 283  :       pdst[w] = pref[vy*ref_pitch + vx + w];
; 284  :      pel==2 use interpolated image
; 285  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 286  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 287  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<1)];
; 288  :      pel==4
; 289  :       int vx = ((VXFull[w])*time256 + 128)>>8;
; 290  :       int vy = ((VYFull[w])*time256 + 128)>>8;
; 291  :       pdst[w] = pref[vy*ref_pitch + vx + (w<<2)];
; 292  :       */
; 293  :       /* 2.6.0.5
; 294  :       int vx = t256_provider.get_vect_f (time256, VXFull[w]);
; 295  :       int vy = t256_provider.get_vect_f (time256, VYFull[w]);
; 296  :       */
; 297  :       int vx = ((VXFull[w])*time256 + 128) >> 8; // 2.5.11.22
; 298  :       int vy = ((VYFull[w])*time256 + 128) >> 8; // 2.5.11.22 

	movsx	edx, WORD PTR [edi+eax]
	lea	eax, DWORD PTR [eax+2]
	imul	edx, DWORD PTR _time256$[esp+12]
	movsx	ecx, WORD PTR [eax-2]
	imul	ecx, DWORD PTR _time256$[esp+12]
	sub	edx, -128				; ffffff80H
	sar	edx, 8

; 299  : 
; 300  :       pdst[w] = pref[vy*ref_pitch + vx + (w << NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+12]
	sub	ecx, -128				; ffffff80H
	sar	ecx, 8
	add	edx, ecx
	lea	ecx, DWORD PTR [edx+esi*4]
	inc	esi
	mov	cx, WORD PTR [ebp+ecx*2]
	mov	WORD PTR [ebx+eax-2], cx
	cmp	esi, DWORD PTR _width$[esp+12]
	jl	SHORT $LL7@Fetch_NPel
	mov	ecx, DWORD PTR _VXFull$[esp+12]
	mov	eax, DWORD PTR _pdst8$[esp+12]
	mov	edx, DWORD PTR _VYFull$[esp+12]
	mov	ebx, DWORD PTR _height$[esp+12]
$LN6@Fetch_NPel:

; 301  :     }
; 302  :     pref += (ref_pitch) << NPELL2;
; 303  :     pdst += dst_pitch;

	add	eax, DWORD PTR tv335[esp+12]

; 304  :     // do nothing t256_provider.jump_to_next_row ();
; 305  :     VXFull += VXPitch;

	add	ecx, DWORD PTR tv334[esp+12]

; 306  :     VYFull += VYPitch;

	add	edx, DWORD PTR tv333[esp+12]
	add	ebp, DWORD PTR tv336[esp+12]
	sub	ebx, 1
	mov	DWORD PTR _pdst8$[esp+12], eax
	mov	DWORD PTR _VXFull$[esp+12], ecx
	mov	DWORD PTR _VYFull$[esp+12], edx
	mov	DWORD PTR _height$[esp+12], ebx
	jne	$LL4@Fetch_NPel
	pop	edi
	pop	esi
$LN3@Fetch_NPel:
	pop	ebp
	pop	ebx

; 307  :   }
; 308  : }

	ret	44					; 0000002cH
??$Fetch_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP	; MVFlow::Fetch_NPel<unsigned short,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Shift_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_h$1$ = -8						; size = 4
tv304 = -4						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref8$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv301 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv303 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Shift_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC ; MVFlow::Shift_NPel<unsigned char,0>, COMDAT
; _this$dead$ = ecx

; 212  : {

	sub	esp, 8

; 213  :   dst_pitch /= sizeof(pixel_t);
; 214  :   ref_pitch /= sizeof(pixel_t);
; 215  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 216  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 217  : 
; 218  :   for (int h = 0; h < height; h++)

	xor	edx, edx
	mov	DWORD PTR _h$1$[esp+8], edx
	cmp	DWORD PTR _height$[esp+4], edx
	jle	$LN3@Shift_NPel
	mov	eax, DWORD PTR _VXPitch$[esp+4]
	mov	ecx, DWORD PTR _pref8$[esp+4]
	add	eax, eax
	push	ebx
	mov	ebx, DWORD PTR _width$[esp+8]
	mov	DWORD PTR tv304[esp+12], eax
	mov	eax, DWORD PTR _VYPitch$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _VYFull$[esp+12]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv303[esp+16], eax
	mov	eax, DWORD PTR _pdst8$[esp+16]
	push	edi
	npad	6
$LL4@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	test	ebx, ebx
	jle	$LN6@Shift_NPel
	mov	eax, DWORD PTR _VXFull$[esp+20]
	mov	edi, ebp
	sub	eax, ebp
	mov	DWORD PTR tv301[esp+20], eax
	npad	10
$LL7@Shift_NPel:

; 221  :     {
; 222  :       // time provider 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 223  : 
; 224  :       // very simple half-pixel using,  must be by image interpolation really (later)
; 225  :       // pre 2.5.11.22 int vx = -((VXFull[w]-128)*time256) / (256 << NPELL2);
; 226  :       // pre 2.5.11.22 int vy = -((VYFull[w]-128)*time256) / (256 << NPELL2);
; 227  :       int vx = (-VXFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [eax+edi]
	mov	eax, 128				; 00000080H
	imul	ecx, DWORD PTR _time256$[esp+20]
	sub	eax, ecx

; 228  :       int vy = (-VYFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edi]
	imul	ecx, DWORD PTR _time256$[esp+20]
	cdq
	and	edx, 255				; 000000ffH
	lea	ebp, DWORD PTR [edx+eax]
	mov	eax, 128				; 00000080H
	sub	eax, ecx
	sar	ebp, 8
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx

; 229  :       int href = h + vy;

	mov	edx, DWORD PTR _h$1$[esp+24]
	sar	eax, 8

; 230  :       int wref = w + vx;

	lea	ecx, DWORD PTR [esi+ebp]
	add	edx, eax

; 231  :       if (href >= 0 && href < height && wref >= 0 && wref < width)// bound check if not padded

	js	SHORT $LN5@Shift_NPel
	cmp	edx, DWORD PTR _height$[esp+20]
	jge	SHORT $LN5@Shift_NPel
	test	ecx, ecx
	js	SHORT $LN5@Shift_NPel
	cmp	ecx, ebx
	jge	SHORT $LN5@Shift_NPel

; 232  :         pdst[vy*dst_pitch + vx + w] = pref[w] << NPELL2; // 2.5.11.22 

	imul	eax, DWORD PTR _dst_pitch$[esp+20]
	mov	ecx, DWORD PTR _pref8$[esp+20]
	mov	edx, DWORD PTR _pdst8$[esp+20]
	mov	cl, BYTE PTR [esi+ecx]
	add	eax, ebp
	add	eax, esi
	mov	BYTE PTR [eax+edx], cl
$LN5@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	mov	eax, DWORD PTR tv301[esp+20]
	inc	esi
	add	edi, 2
	cmp	esi, ebx
	jl	SHORT $LL7@Shift_NPel
	mov	eax, DWORD PTR _pdst8$[esp+20]
	mov	ecx, DWORD PTR _pref8$[esp+20]
	mov	edx, DWORD PTR _h$1$[esp+24]
	mov	ebp, DWORD PTR _VYFull$[esp+20]
$LN6@Shift_NPel:

; 233  :     }
; 234  :     pref += ref_pitch << NPELL2; // 2.5.11.22

	add	ecx, DWORD PTR _ref_pitch$[esp+20]
	inc	edx

; 235  :     pdst += dst_pitch;

	add	eax, DWORD PTR _dst_pitch$[esp+20]

; 236  :     // time provider 2.6.0.5 t256_provider.jump_to_next_row ();
; 237  :     VXFull += VXPitch;

	mov	esi, DWORD PTR tv304[esp+24]

; 238  :     VYFull += VYPitch;

	add	ebp, DWORD PTR tv303[esp+20]
	add	DWORD PTR _VXFull$[esp+20], esi
	mov	DWORD PTR _pref8$[esp+20], ecx
	mov	DWORD PTR _pdst8$[esp+20], eax
	mov	DWORD PTR _VYFull$[esp+20], ebp
	mov	DWORD PTR _h$1$[esp+24], edx
	cmp	edx, DWORD PTR _height$[esp+20]
	jl	$LL4@Shift_NPel
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Shift_NPel:

; 239  :   }
; 240  : }

	add	esp, 8
	ret	44					; 0000002cH
??$Shift_NPel@E$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP ; MVFlow::Shift_NPel<unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Shift_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_h$1$ = -8						; size = 4
tv306 = -4						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref8$ = 16						; size = 4
tv302 = 20						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv305 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv304 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Shift_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC	; MVFlow::Shift_NPel<unsigned char,1>, COMDAT
; _this$dead$ = ecx

; 212  : {

	sub	esp, 8

; 213  :   dst_pitch /= sizeof(pixel_t);
; 214  :   ref_pitch /= sizeof(pixel_t);
; 215  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 216  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 217  : 
; 218  :   for (int h = 0; h < height; h++)

	xor	edx, edx
	mov	DWORD PTR _h$1$[esp+8], edx
	cmp	DWORD PTR _height$[esp+4], edx
	jle	$LN3@Shift_NPel
	mov	eax, DWORD PTR _ref_pitch$[esp+4]
	mov	ecx, DWORD PTR _pref8$[esp+4]
	add	eax, eax
	mov	DWORD PTR tv306[esp+8], eax
	mov	eax, DWORD PTR _VXPitch$[esp+4]
	add	eax, eax
	push	ebx
	mov	ebx, DWORD PTR _width$[esp+8]
	mov	DWORD PTR tv305[esp+8], eax
	mov	eax, DWORD PTR _VYPitch$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _VYFull$[esp+12]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv304[esp+16], eax
	mov	eax, DWORD PTR _pdst8$[esp+16]
	push	edi
$LL4@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	test	ebx, ebx
	jle	$LN6@Shift_NPel
	mov	eax, DWORD PTR _VXFull$[esp+20]
	mov	edi, ebp
	sub	eax, ebp
	mov	DWORD PTR tv302[esp+20], eax
	npad	6
$LL7@Shift_NPel:

; 221  :     {
; 222  :       // time provider 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 223  : 
; 224  :       // very simple half-pixel using,  must be by image interpolation really (later)
; 225  :       // pre 2.5.11.22 int vx = -((VXFull[w]-128)*time256) / (256 << NPELL2);
; 226  :       // pre 2.5.11.22 int vy = -((VYFull[w]-128)*time256) / (256 << NPELL2);
; 227  :       int vx = (-VXFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [eax+edi]
	mov	eax, 256				; 00000100H
	imul	ecx, DWORD PTR _time256$[esp+20]
	sub	eax, ecx

; 228  :       int vy = (-VYFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edi]
	imul	ecx, DWORD PTR _time256$[esp+20]
	cdq
	and	edx, 511				; 000001ffH
	lea	ebp, DWORD PTR [edx+eax]
	mov	eax, 256				; 00000100H
	sub	eax, ecx
	sar	ebp, 9
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx

; 229  :       int href = h + vy;

	mov	edx, DWORD PTR _h$1$[esp+24]
	sar	eax, 9

; 230  :       int wref = w + vx;

	lea	ecx, DWORD PTR [esi+ebp]
	add	edx, eax

; 231  :       if (href >= 0 && href < height && wref >= 0 && wref < width)// bound check if not padded

	js	SHORT $LN5@Shift_NPel
	cmp	edx, DWORD PTR _height$[esp+20]
	jge	SHORT $LN5@Shift_NPel
	test	ecx, ecx
	js	SHORT $LN5@Shift_NPel
	cmp	ecx, ebx
	jge	SHORT $LN5@Shift_NPel

; 232  :         pdst[vy*dst_pitch + vx + w] = pref[w] << NPELL2; // 2.5.11.22 

	imul	eax, DWORD PTR _dst_pitch$[esp+20]
	mov	ecx, DWORD PTR _pref8$[esp+20]
	mov	edx, DWORD PTR _pdst8$[esp+20]
	mov	cl, BYTE PTR [esi+ecx]
	add	eax, ebp
	add	cl, cl
	add	eax, esi
	mov	BYTE PTR [eax+edx], cl
$LN5@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	mov	eax, DWORD PTR tv302[esp+20]
	inc	esi
	add	edi, 2
	cmp	esi, ebx
	jl	SHORT $LL7@Shift_NPel
	mov	eax, DWORD PTR _pdst8$[esp+20]
	mov	ecx, DWORD PTR _pref8$[esp+20]
	mov	edx, DWORD PTR _h$1$[esp+24]
	mov	ebp, DWORD PTR _VYFull$[esp+20]
$LN6@Shift_NPel:

; 233  :     }
; 234  :     pref += ref_pitch << NPELL2; // 2.5.11.22

	add	ecx, DWORD PTR tv306[esp+24]
	inc	edx

; 235  :     pdst += dst_pitch;

	add	eax, DWORD PTR _dst_pitch$[esp+20]

; 236  :     // time provider 2.6.0.5 t256_provider.jump_to_next_row ();
; 237  :     VXFull += VXPitch;

	mov	esi, DWORD PTR tv305[esp+20]

; 238  :     VYFull += VYPitch;

	add	ebp, DWORD PTR tv304[esp+20]
	add	DWORD PTR _VXFull$[esp+20], esi
	mov	DWORD PTR _pref8$[esp+20], ecx
	mov	DWORD PTR _pdst8$[esp+20], eax
	mov	DWORD PTR _VYFull$[esp+20], ebp
	mov	DWORD PTR _h$1$[esp+24], edx
	cmp	edx, DWORD PTR _height$[esp+20]
	jl	$LL4@Shift_NPel
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Shift_NPel:

; 239  :   }
; 240  : }

	add	esp, 8
	ret	44					; 0000002cH
??$Shift_NPel@E$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP	; MVFlow::Shift_NPel<unsigned char,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Shift_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
_h$1$ = -8						; size = 4
tv306 = -4						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref8$ = 16						; size = 4
tv302 = 20						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv305 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv304 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Shift_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC	; MVFlow::Shift_NPel<unsigned char,2>, COMDAT
; _this$dead$ = ecx

; 212  : {

	sub	esp, 8

; 213  :   dst_pitch /= sizeof(pixel_t);
; 214  :   ref_pitch /= sizeof(pixel_t);
; 215  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 216  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 217  : 
; 218  :   for (int h = 0; h < height; h++)

	xor	edx, edx
	mov	DWORD PTR _h$1$[esp+8], edx
	cmp	DWORD PTR _height$[esp+4], edx
	jle	$LN3@Shift_NPel
	mov	eax, DWORD PTR _ref_pitch$[esp+4]
	mov	ecx, DWORD PTR _pref8$[esp+4]
	shl	eax, 2
	mov	DWORD PTR tv306[esp+8], eax
	mov	eax, DWORD PTR _VXPitch$[esp+4]
	add	eax, eax
	push	ebx
	mov	ebx, DWORD PTR _width$[esp+8]
	mov	DWORD PTR tv305[esp+8], eax
	mov	eax, DWORD PTR _VYPitch$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _VYFull$[esp+12]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv304[esp+16], eax
	mov	eax, DWORD PTR _pdst8$[esp+16]
	push	edi
$LL4@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	test	ebx, ebx
	jle	$LN6@Shift_NPel
	mov	eax, DWORD PTR _VXFull$[esp+20]
	mov	edi, ebp
	sub	eax, ebp
	mov	DWORD PTR tv302[esp+20], eax
	npad	5
$LL7@Shift_NPel:

; 221  :     {
; 222  :       // time provider 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 223  : 
; 224  :       // very simple half-pixel using,  must be by image interpolation really (later)
; 225  :       // pre 2.5.11.22 int vx = -((VXFull[w]-128)*time256) / (256 << NPELL2);
; 226  :       // pre 2.5.11.22 int vy = -((VYFull[w]-128)*time256) / (256 << NPELL2);
; 227  :       int vx = (-VXFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [eax+edi]
	mov	eax, 512				; 00000200H
	imul	ecx, DWORD PTR _time256$[esp+20]
	sub	eax, ecx

; 228  :       int vy = (-VYFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edi]
	imul	ecx, DWORD PTR _time256$[esp+20]
	cdq
	and	edx, 1023				; 000003ffH
	lea	ebp, DWORD PTR [edx+eax]
	mov	eax, 512				; 00000200H
	sub	eax, ecx
	sar	ebp, 10					; 0000000aH
	cdq
	and	edx, 1023				; 000003ffH
	add	eax, edx

; 229  :       int href = h + vy;

	mov	edx, DWORD PTR _h$1$[esp+24]
	sar	eax, 10					; 0000000aH

; 230  :       int wref = w + vx;

	lea	ecx, DWORD PTR [esi+ebp]
	add	edx, eax

; 231  :       if (href >= 0 && href < height && wref >= 0 && wref < width)// bound check if not padded

	js	SHORT $LN5@Shift_NPel
	cmp	edx, DWORD PTR _height$[esp+20]
	jge	SHORT $LN5@Shift_NPel
	test	ecx, ecx
	js	SHORT $LN5@Shift_NPel
	cmp	ecx, ebx
	jge	SHORT $LN5@Shift_NPel

; 232  :         pdst[vy*dst_pitch + vx + w] = pref[w] << NPELL2; // 2.5.11.22 

	imul	eax, DWORD PTR _dst_pitch$[esp+20]
	mov	ecx, DWORD PTR _pref8$[esp+20]
	mov	edx, DWORD PTR _pdst8$[esp+20]
	mov	cl, BYTE PTR [esi+ecx]
	add	eax, ebp
	shl	cl, 2
	add	eax, esi
	mov	BYTE PTR [eax+edx], cl
$LN5@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	mov	eax, DWORD PTR tv302[esp+20]
	inc	esi
	add	edi, 2
	cmp	esi, ebx
	jl	SHORT $LL7@Shift_NPel
	mov	eax, DWORD PTR _pdst8$[esp+20]
	mov	ecx, DWORD PTR _pref8$[esp+20]
	mov	edx, DWORD PTR _h$1$[esp+24]
	mov	ebp, DWORD PTR _VYFull$[esp+20]
$LN6@Shift_NPel:

; 233  :     }
; 234  :     pref += ref_pitch << NPELL2; // 2.5.11.22

	add	ecx, DWORD PTR tv306[esp+24]
	inc	edx

; 235  :     pdst += dst_pitch;

	add	eax, DWORD PTR _dst_pitch$[esp+20]

; 236  :     // time provider 2.6.0.5 t256_provider.jump_to_next_row ();
; 237  :     VXFull += VXPitch;

	mov	esi, DWORD PTR tv305[esp+20]

; 238  :     VYFull += VYPitch;

	add	ebp, DWORD PTR tv304[esp+20]
	add	DWORD PTR _VXFull$[esp+20], esi
	mov	DWORD PTR _pref8$[esp+20], ecx
	mov	DWORD PTR _pdst8$[esp+20], eax
	mov	DWORD PTR _VYFull$[esp+20], ebp
	mov	DWORD PTR _h$1$[esp+24], edx
	cmp	edx, DWORD PTR _height$[esp+20]
	jl	$LL4@Shift_NPel
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Shift_NPel:

; 239  :   }
; 240  : }

	add	esp, 8
	ret	44					; 0000002cH
??$Shift_NPel@E$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP	; MVFlow::Shift_NPel<unsigned char,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Shift_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
tv313 = -16						; size = 4
tv312 = -12						; size = 4
tv311 = -8						; size = 4
tv310 = -4						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref8$ = 16						; size = 4
_h$1$ = 20						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv307 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv308 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Shift_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC ; MVFlow::Shift_NPel<unsigned short,0>, COMDAT
; _this$dead$ = ecx

; 212  : {

	sub	esp, 16					; 00000010H

; 213  :   dst_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _dst_pitch$[esp+12]

; 214  :   ref_pitch /= sizeof(pixel_t);
; 215  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 216  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 217  : 
; 218  :   for (int h = 0; h < height; h++)

	xor	edx, edx
	mov	ecx, DWORD PTR _ref_pitch$[esp+12]
	shr	eax, 1
	shr	ecx, 1
	mov	DWORD PTR _dst_pitch$[esp+12], eax
	mov	DWORD PTR _h$1$[esp+12], edx
	cmp	DWORD PTR _height$[esp+12], edx
	jle	$LN3@Shift_NPel
	add	eax, eax
	add	ecx, ecx
	mov	DWORD PTR tv312[esp+16], eax
	mov	eax, DWORD PTR _VXPitch$[esp+12]
	add	eax, eax
	mov	DWORD PTR tv313[esp+16], ecx
	mov	ecx, DWORD PTR _VYFull$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR _width$[esp+16]
	mov	DWORD PTR tv311[esp+20], eax
	mov	eax, DWORD PTR _VYPitch$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+20]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv310[esp+28], eax
	mov	eax, DWORD PTR _pdst8$[esp+24]
	push	edi
$LL4@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	test	ebx, ebx
	jle	$LN6@Shift_NPel
	mov	edx, DWORD PTR _VXFull$[esp+28]
	mov	eax, ebp
	sub	edx, ecx
	mov	edi, ecx
	sub	eax, ecx
	mov	DWORD PTR tv308[esp+28], edx
	mov	DWORD PTR tv307[esp+28], eax
	npad	12
$LL7@Shift_NPel:

; 221  :     {
; 222  :       // time provider 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 223  : 
; 224  :       // very simple half-pixel using,  must be by image interpolation really (later)
; 225  :       // pre 2.5.11.22 int vx = -((VXFull[w]-128)*time256) / (256 << NPELL2);
; 226  :       // pre 2.5.11.22 int vy = -((VYFull[w]-128)*time256) / (256 << NPELL2);
; 227  :       int vx = (-VXFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edx+edi]
	mov	eax, 128				; 00000080H
	imul	ecx, DWORD PTR _time256$[esp+28]
	sub	eax, ecx

; 228  :       int vy = (-VYFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edi]
	imul	ecx, DWORD PTR _time256$[esp+28]
	cdq
	and	edx, 255				; 000000ffH
	lea	ebp, DWORD PTR [edx+eax]
	mov	eax, 128				; 00000080H
	sub	eax, ecx
	sar	ebp, 8
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx

; 229  :       int href = h + vy;

	mov	edx, DWORD PTR _h$1$[esp+28]
	sar	eax, 8

; 230  :       int wref = w + vx;

	lea	ecx, DWORD PTR [esi+ebp]
	add	edx, eax

; 231  :       if (href >= 0 && href < height && wref >= 0 && wref < width)// bound check if not padded

	js	SHORT $LN5@Shift_NPel
	cmp	edx, DWORD PTR _height$[esp+28]
	jge	SHORT $LN5@Shift_NPel
	test	ecx, ecx
	js	SHORT $LN5@Shift_NPel
	cmp	ecx, ebx
	jge	SHORT $LN5@Shift_NPel

; 232  :         pdst[vy*dst_pitch + vx + w] = pref[w] << NPELL2; // 2.5.11.22 

	imul	eax, DWORD PTR _dst_pitch$[esp+28]
	mov	ecx, DWORD PTR tv307[esp+28]
	mov	edx, DWORD PTR _pdst8$[esp+28]
	mov	cx, WORD PTR [ecx+edi]
	add	eax, ebp
	add	eax, esi
	mov	WORD PTR [edx+eax*2], cx
$LN5@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	mov	edx, DWORD PTR tv308[esp+28]
	inc	esi
	add	edi, 2
	cmp	esi, ebx
	jl	SHORT $LL7@Shift_NPel
	mov	eax, DWORD PTR _pdst8$[esp+28]
	mov	ecx, DWORD PTR _VYFull$[esp+28]
	mov	edx, DWORD PTR _h$1$[esp+28]
	mov	ebp, DWORD PTR _pref8$[esp+28]
$LN6@Shift_NPel:

; 233  :     }
; 234  :     pref += ref_pitch << NPELL2; // 2.5.11.22

	add	ebp, DWORD PTR tv313[esp+32]
	inc	edx

; 235  :     pdst += dst_pitch;

	add	eax, DWORD PTR tv312[esp+32]

; 236  :     // time provider 2.6.0.5 t256_provider.jump_to_next_row ();
; 237  :     VXFull += VXPitch;

	mov	esi, DWORD PTR tv311[esp+32]

; 238  :     VYFull += VYPitch;

	add	ecx, DWORD PTR tv310[esp+32]
	add	DWORD PTR _VXFull$[esp+28], esi
	mov	DWORD PTR _pref8$[esp+28], ebp
	mov	DWORD PTR _pdst8$[esp+28], eax
	mov	DWORD PTR _VYFull$[esp+28], ecx
	mov	DWORD PTR _h$1$[esp+28], edx
	cmp	edx, DWORD PTR _height$[esp+28]
	jl	$LL4@Shift_NPel
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Shift_NPel:

; 239  :   }
; 240  : }

	add	esp, 16					; 00000010H
	ret	44					; 0000002cH
??$Shift_NPel@G$0A@@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP ; MVFlow::Shift_NPel<unsigned short,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Shift_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
tv320 = -16						; size = 4
tv319 = -12						; size = 4
tv318 = -8						; size = 4
tv317 = -4						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref8$ = 16						; size = 4
_h$1$ = 20						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv314 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv315 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Shift_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC	; MVFlow::Shift_NPel<unsigned short,1>, COMDAT
; _this$dead$ = ecx

; 212  : {

	sub	esp, 16					; 00000010H

; 213  :   dst_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _dst_pitch$[esp+12]

; 214  :   ref_pitch /= sizeof(pixel_t);
; 215  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 216  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 217  : 
; 218  :   for (int h = 0; h < height; h++)

	xor	edx, edx
	mov	ecx, DWORD PTR _ref_pitch$[esp+12]
	shr	eax, 1
	shr	ecx, 1
	mov	DWORD PTR _dst_pitch$[esp+12], eax
	mov	DWORD PTR _h$1$[esp+12], edx
	cmp	DWORD PTR _height$[esp+12], edx
	jle	$LN3@Shift_NPel
	add	eax, eax
	shl	ecx, 2
	mov	DWORD PTR tv319[esp+16], eax
	mov	eax, DWORD PTR _VXPitch$[esp+12]
	add	eax, eax
	mov	DWORD PTR tv320[esp+16], ecx
	mov	ecx, DWORD PTR _VYFull$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR _width$[esp+16]
	mov	DWORD PTR tv318[esp+20], eax
	mov	eax, DWORD PTR _VYPitch$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+20]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv317[esp+28], eax
	mov	eax, DWORD PTR _pdst8$[esp+24]
	push	edi
	npad	9
$LL4@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	test	ebx, ebx
	jle	$LN6@Shift_NPel
	mov	edx, DWORD PTR _VXFull$[esp+28]
	mov	eax, ebp
	sub	edx, ecx
	mov	edi, ecx
	sub	eax, ecx
	mov	DWORD PTR tv315[esp+28], edx
	mov	DWORD PTR tv314[esp+28], eax
	npad	2
$LL7@Shift_NPel:

; 221  :     {
; 222  :       // time provider 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 223  : 
; 224  :       // very simple half-pixel using,  must be by image interpolation really (later)
; 225  :       // pre 2.5.11.22 int vx = -((VXFull[w]-128)*time256) / (256 << NPELL2);
; 226  :       // pre 2.5.11.22 int vy = -((VYFull[w]-128)*time256) / (256 << NPELL2);
; 227  :       int vx = (-VXFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edx+edi]
	mov	eax, 256				; 00000100H
	imul	ecx, DWORD PTR _time256$[esp+28]
	sub	eax, ecx

; 228  :       int vy = (-VYFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edi]
	imul	ecx, DWORD PTR _time256$[esp+28]
	cdq
	and	edx, 511				; 000001ffH
	lea	ebp, DWORD PTR [edx+eax]
	mov	eax, 256				; 00000100H
	sub	eax, ecx
	sar	ebp, 9
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx

; 229  :       int href = h + vy;

	mov	edx, DWORD PTR _h$1$[esp+28]
	sar	eax, 9

; 230  :       int wref = w + vx;

	lea	ecx, DWORD PTR [esi+ebp]
	add	edx, eax

; 231  :       if (href >= 0 && href < height && wref >= 0 && wref < width)// bound check if not padded

	js	SHORT $LN5@Shift_NPel
	cmp	edx, DWORD PTR _height$[esp+28]
	jge	SHORT $LN5@Shift_NPel
	test	ecx, ecx
	js	SHORT $LN5@Shift_NPel
	cmp	ecx, ebx
	jge	SHORT $LN5@Shift_NPel

; 232  :         pdst[vy*dst_pitch + vx + w] = pref[w] << NPELL2; // 2.5.11.22 

	imul	eax, DWORD PTR _dst_pitch$[esp+28]
	mov	ecx, DWORD PTR tv314[esp+28]
	mov	edx, DWORD PTR _pdst8$[esp+28]
	mov	cx, WORD PTR [ecx+edi]
	add	eax, ebp
	add	cx, cx
	add	eax, esi
	mov	WORD PTR [edx+eax*2], cx
$LN5@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	mov	edx, DWORD PTR tv315[esp+28]
	inc	esi
	add	edi, 2
	cmp	esi, ebx
	jl	SHORT $LL7@Shift_NPel
	mov	eax, DWORD PTR _pdst8$[esp+28]
	mov	ecx, DWORD PTR _VYFull$[esp+28]
	mov	edx, DWORD PTR _h$1$[esp+28]
	mov	ebp, DWORD PTR _pref8$[esp+28]
$LN6@Shift_NPel:

; 233  :     }
; 234  :     pref += ref_pitch << NPELL2; // 2.5.11.22

	add	ebp, DWORD PTR tv320[esp+32]
	inc	edx

; 235  :     pdst += dst_pitch;

	add	eax, DWORD PTR tv319[esp+32]

; 236  :     // time provider 2.6.0.5 t256_provider.jump_to_next_row ();
; 237  :     VXFull += VXPitch;

	mov	esi, DWORD PTR tv318[esp+32]

; 238  :     VYFull += VYPitch;

	add	ecx, DWORD PTR tv317[esp+32]
	add	DWORD PTR _VXFull$[esp+28], esi
	mov	DWORD PTR _pref8$[esp+28], ebp
	mov	DWORD PTR _pdst8$[esp+28], eax
	mov	DWORD PTR _VYFull$[esp+28], ecx
	mov	DWORD PTR _h$1$[esp+28], edx
	cmp	edx, DWORD PTR _height$[esp+28]
	jl	$LL4@Shift_NPel
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Shift_NPel:

; 239  :   }
; 240  : }

	add	esp, 16					; 00000010H
	ret	44					; 0000002cH
??$Shift_NPel@G$00@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP	; MVFlow::Shift_NPel<unsigned short,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflow.cpp
;	COMDAT ??$Shift_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z
_TEXT	SEGMENT
tv320 = -16						; size = 4
tv319 = -12						; size = 4
tv318 = -8						; size = 4
tv317 = -4						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pref8$ = 16						; size = 4
_h$1$ = 20						; size = 4
_ref_pitch$ = 20					; size = 4
_VXFull$ = 24						; size = 4
tv314 = 28						; size = 4
_VXPitch$ = 28						; size = 4
_VYFull$ = 32						; size = 4
tv315 = 36						; size = 4
_VYPitch$ = 36						; size = 4
_width$ = 40						; size = 4
_height$ = 44						; size = 4
_time256$ = 48						; size = 4
??$Shift_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z PROC	; MVFlow::Shift_NPel<unsigned short,2>, COMDAT
; _this$dead$ = ecx

; 212  : {

	sub	esp, 16					; 00000010H

; 213  :   dst_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _dst_pitch$[esp+12]

; 214  :   ref_pitch /= sizeof(pixel_t);
; 215  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 216  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 217  : 
; 218  :   for (int h = 0; h < height; h++)

	xor	edx, edx
	mov	ecx, DWORD PTR _ref_pitch$[esp+12]
	shr	eax, 1
	shr	ecx, 1
	mov	DWORD PTR _dst_pitch$[esp+12], eax
	mov	DWORD PTR _h$1$[esp+12], edx
	cmp	DWORD PTR _height$[esp+12], edx
	jle	$LN3@Shift_NPel
	add	eax, eax
	shl	ecx, 3
	mov	DWORD PTR tv319[esp+16], eax
	mov	eax, DWORD PTR _VXPitch$[esp+12]
	add	eax, eax
	mov	DWORD PTR tv320[esp+16], ecx
	mov	ecx, DWORD PTR _VYFull$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR _width$[esp+16]
	mov	DWORD PTR tv318[esp+20], eax
	mov	eax, DWORD PTR _VYPitch$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR _pref8$[esp+20]
	add	eax, eax
	push	esi
	mov	DWORD PTR tv317[esp+28], eax
	mov	eax, DWORD PTR _pdst8$[esp+24]
	push	edi
	npad	9
$LL4@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	xor	esi, esi
	test	ebx, ebx
	jle	$LN6@Shift_NPel
	mov	edx, DWORD PTR _VXFull$[esp+28]
	mov	eax, ebp
	sub	edx, ecx
	mov	edi, ecx
	sub	eax, ecx
	mov	DWORD PTR tv315[esp+28], edx
	mov	DWORD PTR tv314[esp+28], eax
	npad	2
$LL7@Shift_NPel:

; 221  :     {
; 222  :       // time provider 2.6.0.5 const int		time256 = t256_provider.get_t (w);
; 223  : 
; 224  :       // very simple half-pixel using,  must be by image interpolation really (later)
; 225  :       // pre 2.5.11.22 int vx = -((VXFull[w]-128)*time256) / (256 << NPELL2);
; 226  :       // pre 2.5.11.22 int vy = -((VYFull[w]-128)*time256) / (256 << NPELL2);
; 227  :       int vx = (-VXFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edx+edi]
	mov	eax, 512				; 00000200H
	imul	ecx, DWORD PTR _time256$[esp+28]
	sub	eax, ecx

; 228  :       int vy = (-VYFull[w] * time256 + (128 << NPELL2)) / (256 << NPELL2);

	movsx	ecx, WORD PTR [edi]
	imul	ecx, DWORD PTR _time256$[esp+28]
	cdq
	and	edx, 1023				; 000003ffH
	lea	ebp, DWORD PTR [edx+eax]
	mov	eax, 512				; 00000200H
	sub	eax, ecx
	sar	ebp, 10					; 0000000aH
	cdq
	and	edx, 1023				; 000003ffH
	add	eax, edx

; 229  :       int href = h + vy;

	mov	edx, DWORD PTR _h$1$[esp+28]
	sar	eax, 10					; 0000000aH

; 230  :       int wref = w + vx;

	lea	ecx, DWORD PTR [esi+ebp]
	add	edx, eax

; 231  :       if (href >= 0 && href < height && wref >= 0 && wref < width)// bound check if not padded

	js	SHORT $LN5@Shift_NPel
	cmp	edx, DWORD PTR _height$[esp+28]
	jge	SHORT $LN5@Shift_NPel
	test	ecx, ecx
	js	SHORT $LN5@Shift_NPel
	cmp	ecx, ebx
	jge	SHORT $LN5@Shift_NPel

; 232  :         pdst[vy*dst_pitch + vx + w] = pref[w] << NPELL2; // 2.5.11.22 

	imul	eax, DWORD PTR _dst_pitch$[esp+28]
	mov	ecx, DWORD PTR tv314[esp+28]
	mov	edx, DWORD PTR _pdst8$[esp+28]
	mov	cx, WORD PTR [ecx+edi]
	add	eax, ebp
	shl	cx, 2
	add	eax, esi
	mov	WORD PTR [edx+eax*2], cx
$LN5@Shift_NPel:

; 219  :   {
; 220  :     for (int w = 0; w < width; w++)

	mov	edx, DWORD PTR tv315[esp+28]
	inc	esi
	add	edi, 2
	cmp	esi, ebx
	jl	SHORT $LL7@Shift_NPel
	mov	eax, DWORD PTR _pdst8$[esp+28]
	mov	ecx, DWORD PTR _VYFull$[esp+28]
	mov	edx, DWORD PTR _h$1$[esp+28]
	mov	ebp, DWORD PTR _pref8$[esp+28]
$LN6@Shift_NPel:

; 233  :     }
; 234  :     pref += ref_pitch << NPELL2; // 2.5.11.22

	add	ebp, DWORD PTR tv320[esp+32]
	inc	edx

; 235  :     pdst += dst_pitch;

	add	eax, DWORD PTR tv319[esp+32]

; 236  :     // time provider 2.6.0.5 t256_provider.jump_to_next_row ();
; 237  :     VXFull += VXPitch;

	mov	esi, DWORD PTR tv318[esp+32]

; 238  :     VYFull += VYPitch;

	add	ecx, DWORD PTR tv317[esp+32]
	add	DWORD PTR _VXFull$[esp+28], esi
	mov	DWORD PTR _pref8$[esp+28], ebp
	mov	DWORD PTR _pdst8$[esp+28], eax
	mov	DWORD PTR _VYFull$[esp+28], ecx
	mov	DWORD PTR _h$1$[esp+28], edx
	cmp	edx, DWORD PTR _height$[esp+28]
	jl	$LL4@Shift_NPel
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Shift_NPel:

; 239  :   }
; 240  : }

	add	esp, 16					; 00000010H
	ret	44					; 0000002cH
??$Shift_NPel@G$01@MVFlow@@AAEXPAEHPBEHPAFH2HHHH@Z ENDP	; MVFlow::Shift_NPel<unsigned short,2>
_TEXT	ENDS
END
